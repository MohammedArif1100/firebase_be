const moment = require("moment");
const { Socket } = require("../socket/socketio");
const log4js = require("../log4js");
const logs = log4js.logger;
const db = require("../config/db").db;
var lodash = require("lodash");
const { Sequelize, Op } = require("sequelize");
const { isEqual, includes } = require("lodash");
const errormail = require("../services/mail");
const dotenv = require("dotenv");

dotenv.config();
require("expose-gc")

try {
    var alert_value_list = [];
    async function get_alarm_value_list() {
        alert_value_list = await require("./alertvalue").getalerts();
    }
    get_alarm_value_list()

    const PointmachineAdata = require('../models/pointmachineAdata');
    const PointmachineBdata = require('../models/pointmachineBdata');
    const TrackCircuitFeederData = require('../models/trackcircuitfeederdata');
    const TrackCircuitRelayData = require('../models/trackcircuitrelaydata');
    const PointMachineAlert = require("../models/pointmachinealert");
    const TrackCircuitAlert = require("../models/trackcircuitalert");
    const SignalCircuitAlert = require("../models/signalcircuitalert");
    const TrackCircuitData = require("../models/trackcircuitdata");
    const PointMachineData = require("../models/pointmachinedata");
    const SignalCircuitData = require("../models/signalcircuitdata");
    const NotificationSend = require("../models/notificationsend");
    const NotificationControl = require("../models/notificationcontrol");
    const RegisteredRailwayStations = require("../models/registeredrailwaystation");
    const RegisteredPointMachine = require("../models/registeredpointmachine");
    const RegisteredSignalCircuit = require("../models/registeredsignalcircuit");
    const RegisteredTrackCircuit = require("../models/registeredtrackcircuit");
    const RegisteredUserDetails = require("../models/registereduserdetails");
    const Asserts = require("../models/asserts");
    const AlertMode = require("../models/alertmode");
    const SignalAspectType = require("../models/signalaspecttype");
    const RegisteredRelay = require("../models/registeredrelay");
    const RelayData = require("../models/relaydata");
    const RegisteredBattery = require("../models/registeredbattery");
    const BatteryData = require("../models/batterydata");
    const RegisteredAxleCounter = require("../models/registeredaxlecounter");
    const AxleCounterData = require("../models/axlecounterdata");
    const RegisteredIPS = require("../models/registeredips");
    const IPSData = require("../models/ipsdata");
    const RegisteredLCGate = require("../models/registeredlcgate");
    const LCGateData = require("../models/lcgatedata");
    const AxleCounterAlert = require("../models/axlecounteralert");
    const LCGateAlert = require("../models/lcgatealert");
    const BatteryAlert = require("../models/batteryalert");
    const IPSAlert = require("../models/ipsalert");

    // -------- mqtt setup -----------

    var mqtt = require('mqtt');
    // var mosca = require('mosca');

    var io = require('socket.io-client');

    // var socketcloud = io.connect('http://188.166.176.188:5000', {reconnect: true});
    // var socketcloud = io.connect(process.env.CLOUD_HOST, { reconnect: true });
    // // Add a connect listener
    // socketcloud.on('connect', function (socket) {
    //     logs.info('cloud socket connected!');
    // });

    // socketcloud.on('Signal', data => {
    //     logs.info("signal data received")
    // });

    // socketcloud.on('Track', data => {
    //     logs.info("Track data received")
    // });

    // socketcloud.on('Point', data => {
    //     logs.info("Point data received")
    // });

    // socketcloud.on('Notification', data => {
    //     logs.info("Notification received")
    // });

    var pointmachineAdatas = []
    var pointmachineBdatas = []
    var pointmachineABdatas = []
    var trackcircuitFeederdatas = []
    var trackcircuitRelaydatas = []
    var trackcircuitFeederRelaydatas = []
    var signalcircuitdatas = []
    var axlecounterdatas = []
    var lcgatedatas = []
    var relaydatas = []
    var eibatterydatas = [];
    var ipsbatterydatas = [];
    var ipsdatas = [];
    var trackfeederrelaycount = []

    var pointmachineAlive = []
    var pointmachineANoDirectionAlive = []
    var pointmachineBNoDirectionAlive = []
    var trackcircuitAlive = []
    var signalcircuitAlive = []
    var axlecounterAlive = []
    var lcgateAlive = []
    var eibatteryAlive = [];
    var ipsbatteryAlive = [];
    var ipsAlive = [];

    var pointsalive = []
    var pointsAalive = {}
    var pointsBalive = {}
    var tracksalive = []
    var signalslive = []
    var axlesalive = []
    var lcgatesalive = []
    var eibatteriesalive = [];
    var ipsbatteriesalive = [];
    var ipssalive = [];

    var pointmachineABlogs = []

    var comparepointmachineA = []
    var comparepointmachineB = []
    var comparepointmachineAB = []
    var comparetrackcircuitFeeder = []
    var comparetrackcircuitRelay = []
    var comparesignalcircuit = []
    var compareaxlecounter = []
    var comparelcgate = []
    var compareeibattery = [];
    var compareipsbattery = [];
    var compareips = [];

    var pointmachineWithoutArray = false
    var trackcircuitWithoutArray = false

    // var settings = {
    //     port: parseInt(process.env.MQTT_PORT)
    // }
    // var servers = new mosca.Server(settings);
    // servers.on('start', function () {
    //     //console.log("start mosca server");
    // });

    var client = mqtt.connect(process.env.MQTT_HOST);

    // logs.info('Mqtt server listening')
    // client.on('connect', function()  {setInterval(() => {
    //   client.publish('myTopic', 'test');
    //   console.log('Message Sent from mqtt');
    // }, 5000);
    // })

    alert_value_list = require("./alertvalue").getValues();

    setInterval(() => {
        assertsalive();
    }, parseInt(process.env.SET_ALIVE_INTERVAL));

    var AlertModes = []
    async function get_alert_modes() {
        AlertModes = await AlertMode.findAll({ where: { isdele: false } })
    }
    get_alert_modes()

    function get_alert_message(KEY, VALUE) {
        return Promise.resolve((alert_value_list[alert_value_list.findIndex(x => x.key === KEY)].message).replace('####', VALUE).replace(/unit/gi, alert_value_list[alert_value_list.findIndex(x => x.key === KEY)].unit))
    }

    function get_alerts(KEY) {
        return Promise.resolve(alert_value_list[alert_value_list.findIndex(x => x.key === KEY)])
    }

    function get_alert_id(KEY) {
        return Promise.resolve(alert_value_list[alert_value_list.findIndex(x => x.key === KEY)].id)
    }

    function get_alert_value(KEY) {
        return Promise.resolve(alert_value_list[alert_value_list.findIndex(x => x.key === KEY)].value)
    }

    function get_alert_isactive(KEY) {
        return Promise.resolve(alert_value_list[alert_value_list.findIndex(x => x.key === KEY)].isactive)
    }

    function get_alert_mode(KEY) {
        return Promise.resolve(alert_value_list[alert_value_list.findIndex(x => x.key === KEY)].mode)
    }

    function get_alert_unit(KEY) {
        return Promise.resolve(alert_value_list[alert_value_list.findIndex(x => x.key === KEY)].unit)
    }

    function combine_mes_val_unit(MESSAGE, VALUE, UNIT) {
        return Promise.resolve(MESSAGE.replace('####', VALUE).replace(/unit/gi, UNIT))
    }

    async function assertsalive() {
        try {
            //check for point machine
            var points = pointmachineAlive.filter(x => x.alive_limit < moment())
            if (points.length > 0) {
                var points_json = JSON.parse(JSON.stringify(points));
                // const result = lodash.intersection(points, pointsalive);

                // const userGenres = pointsalive.map(({alive_limit}) => alive_limit);
                // console.log(points.some(({alive_limit}) => userGenres.includes(alive_limit)))      

                // console.log("points", points[0].alive_limit === pointsalive[0].alive_limit ? true  : false)

                //console.log('diff',lodash.differenceBy(pointsalive,points))

                // console.log('equal',lodash.isEqual(points,pointsalive))

                // const results = points.filter(({ alive_limit: id1 }) => !pointsalive.some(({ alive_limit: id2 }) => id2 === id1));
                // console.log('filter',results.length)
                // console.log((points, pointsalive) => a.key === b.key && a.alive_limit === b.alive_limit);

                //if((lodash.differenceBy(pointsalive,points_json).length === 0 && pointsalive.length === 0) || lodash.differenceBy(pointsalive,points_json).length > 0 ) //if(lodash.isEqual(points,pointsalive) == false)
                if (lodash.isEqual(points_json, pointsalive) == false) {
                    //copyarray(points)
                    //pointsalive = Object.create(points)                  
                    //pointsalive = points.slice()
                    //pointsalive = lodash.cloneDeep(points)   
                    //pointsalive = [...points]                               
                    //pointsalive = points 
                    pointsalive = points_json;
                    pointmachinealive_notification(points)
                }
            }

            //check for track machine
            var tracks = trackcircuitAlive.filter(x => x.alive_limit < moment())
            if (tracks.length > 0) {
                var tracks_json = JSON.parse(JSON.stringify(tracks));

                if (lodash.isEqual(tracks_json, tracksalive) == false) {
                    tracksalive = tracks_json
                    trackcircuitalive_notification(tracks)
                }
            }

            //check for signals machine
            var signals = signalcircuitAlive.filter(x => x.alive_limit < moment())
            if (signals.length > 0) {
                var signals_json = JSON.parse(JSON.stringify(signals));

                if (lodash.isEqual(signals_json, signalslive) == false) {
                    signalslive = signals_json
                    signalcircuitalive_notification(signals)
                }
            }

            //check for axle counter
            var axles = axlecounterAlive.filter(x => x.alive_limit < moment())
            if (axles.length > 0) {
                var axles_json = JSON.parse(JSON.stringify(axles));

                if (lodash.isEqual(axles_json, axlesalive) == false) {
                    axlesalive = axles_json
                    axlecounteralive_notification(axles)
                }
            }

            //check for lc gate
            var lcgates = lcgateAlive.filter(x => x.alive_limit < moment())
            if (lcgates.length > 0) {
                var lcgates_json = JSON.parse(JSON.stringify(lcgates));

                if (lodash.isEqual(lcgates_json, lcgatesalive) == false) {
                    lcgatesalive = lcgates_json
                    lcgatealive_notification(lcgates)
                }
            }

            //check for ei battery
            var eibatteries = eibatteryAlive.filter(x => x.alive_limit < moment());
            if (eibatteries.length > 0) {
                var eibatteries_json = JSON.parse(JSON.stringify(eibatteries));

                if (lodash.isEqual(eibatteries_json, eibatteriesalive) == false) {
                    eibatteriesalive = eibatteries_json;
                    eibatteryalive_notification(eibatteries);
                }
            }

            //check for ips battery
            var ipsbatteries = ipsbatteryAlive.filter(x => x.alive_limit < moment());
            if (ipsbatteries.length > 0) {
                var ipsbatteries_json = JSON.parse(JSON.stringify(ipsbatteries));

                if (lodash.isEqual(ipsbatteries_json, ipsbatteriesalive) == false) {
                    ipsbatteriesalive = ipsbatteries_json;
                    ipsbatteryalive_notification(ipsbatteries);
                }
            }

            //check for ips
            var ipss = ipsAlive.filter(x => x.alive_limit < moment());
            if (ipss.length > 0) {
                var ipss_json = JSON.parse(JSON.stringify(ipss));

                if (lodash.isEqual(ipss_json, ipssalive) == false) {
                    ipssalive = ipss_json;
                    ipsalive_notification(ipss);
                }
            }

        }
        catch (ex) {
            logs.error('Error in asserts live' + ex);
            //console.log('Error in asserts live' + ex);
        }
    }

    async function pointmachine_logdifference_AB(A1_log, B1_log, pointmachineid, seconds_value) {
        try {
            if (A1_log != 1 || B1_log != 1) {
                if (A1_log == 1 && B1_log == 0 || A1_log == 0 && B1_log == 1) {
                    const index = pointmachineABlogs.findIndex(obj => { return obj.key === pointmachineid });
                    if (index !== -1) {
                        if (JSON.stringify(pointmachineABlogs[index].log) != JSON.stringify({ A1_log, B1_log })) {
                            var seconds = parseInt(moment().diff(pointmachineABlogs[index].time, 'seconds'))
                            if (seconds >= seconds_value) {
                                //need to send alert
                            }
                            pointmachineABlogs.splice(index, 1)
                            return true
                        }
                        else {
                            return false
                        }
                    }
                    else {
                        pointmachineABlogs.push({ key: pointmachineid, time: moment(), log: { A1_log, B1_log } });
                        return false
                    }
                }
                else {
                    return false
                }
            }
            else {
                const index = pointmachineABlogs.findIndex(obj => { return obj.key === pointmachineid });
                if (index !== -1) {
                    pointmachineABlogs.splice(index, 1)
                }
                return true
            }
        }
        catch (ex) {
            logs.error('mqtt error stationdata/pointmachine_logdifference_AB ' + ex);
            //console.log('mqtt error stationdata/pointmachine_logdifference_AB ' + ex);
            return false
        }
    }

    async function pointmachine_compare_A(pointmachine_data, pointmachineid, value) {
        try {
            let compare_index = comparepointmachineA.findIndex(obj => { return obj.key === pointmachineid; })
            if (compare_index !== -1) {
                comparepointmachineA[compare_index].current_value = pointmachine_data
                var compare_result = await pointmachine_difference_AB(comparepointmachineA[compare_index].previous_value, comparepointmachineA[compare_index].current_value, parseFloat(value))
                comparepointmachineA[compare_index].previous_value = pointmachine_data
                return compare_result
            }
            else {
                comparepointmachineA.push({ key: pointmachineid, previous_value: pointmachine_data, current_value: [] })
                return true
            }
        }
        catch (ex) {
            logs.error('mqtt error stationdata/pointmachine_compare_A ' + ex);
            //console.log('mqtt error stationdata/pointmachine_compare_A ' + ex);
            return false
        }
    }

    async function pointmachine_compare_B(pointmachine_data, pointmachineid, value) {
        try {
            let compare_index = comparepointmachineB.findIndex(obj => { return obj.key === pointmachineid; })
            if (compare_index !== -1) {
                comparepointmachineB[compare_index].current_value = pointmachine_data
                var compare_result = await pointmachine_difference_AB(comparepointmachineB[compare_index].previous_value, comparepointmachineB[compare_index].current_value, parseFloat(value))
                comparepointmachineB[compare_index].previous_value = pointmachine_data
                return compare_result
            }
            else {
                comparepointmachineB.push({ key: pointmachineid, previous_value: pointmachine_data, current_value: [] })
                return true
            }
        }
        catch (ex) {
            logs.error('mqtt error stationdata/pointmachine_compare_B' + ex);
            //console.log('mqtt error stationdata/pointmachine_compare_B ' + ex);
            return false
        }
    }

    async function pointmachine_compare_AB(pointmachine_data, pointmachineid, value) {
        try {
            let compare_index = comparepointmachineAB.findIndex(obj => { return obj.key === pointmachineid; })
            if (compare_index !== -1) {
                comparepointmachineAB[compare_index].current_value = pointmachine_data
                var compare_result = await pointmachine_difference_AB(comparepointmachineAB[compare_index].previous_value, comparepointmachineAB[compare_index].current_value, parseFloat(value))
                comparepointmachineAB[compare_index].previous_value = pointmachine_data
                return compare_result
            }
            else {
                comparepointmachineAB.push({ key: pointmachineid, previous_value: pointmachine_data, current_value: [] })
                return true
            }
        }
        catch (ex) {
            logs.error('mqtt error stationdata/pointmachine_compare_AB ' + ex);
            //console.log('mqtt error stationdata/pointmachine_compare_AB ' + ex);
            return false
        }
    }

    async function pointmachine_difference_AB(previous_data, current_data, percentage_value) {
        try {
            var loop = 0
            var previous_data_values = Object.values(previous_data)
            var current_data_values = Object.values(current_data)
            let found = true
            while (loop < previous_data.length) {
                if ((parseFloat(previous_data_values[loop]) != 0 && parseFloat(current_data_values[loop]) != 0) || parseFloat(previous_data_values[loop]) != 0) {
                    if (((Math.abs(parseFloat(previous_data_values[loop]) - parseFloat(current_data_values[loop]))) / parseFloat(previous_data_values[loop])) * 100 >= percentage_value) {
                        return true
                    }
                }
                loop++
            }
            if (found == true) {
                return false
            }
        }
        catch (ex) {
            logs.error('mqtt error stationdata/pointmachine_difference_AB ' + ex);
            //console.log('mqtt error stationdata/pointmachine_difference_AB ' + ex);
            return false
        }
    }

    async function trackcircuit_compare_Feeder(trackcircuit_data, trackcircuitid, value) {
        try {
            let compare_index = comparetrackcircuitFeeder.findIndex(obj => { return obj.key === trackcircuitid; })
            if (compare_index !== -1) {
                comparetrackcircuitFeeder[compare_index].current_value = trackcircuit_data
                var compare_result = await trackcircuit_difference_Feeder(comparetrackcircuitFeeder[compare_index].previous_value, comparetrackcircuitFeeder[compare_index].current_value, parseFloat(value))
                comparetrackcircuitFeeder[compare_index].previous_value = trackcircuit_data
                return compare_result
            }
            else {
                comparetrackcircuitFeeder.push({ key: trackcircuitid, previous_value: trackcircuit_data, current_value: [] })
                return true
            }
        }
        catch (ex) {
            logs.error('mqtt error stationdata/trackcircuit_compare_Feeder ' + ex);
            //console.log('mqtt error stationdata/trackcircuit_compare_Feeder ' + ex);
            return false
        }
    }

    async function trackcircuit_difference_Feeder(previous_data, current_data, percentage_value) {
        try {
            var loop = 0
            var previous_data_values = Object.values(previous_data)
            var current_data_values = Object.values(current_data)
            let found = true
            while (loop < previous_data.length) {
                if ((parseFloat(previous_data_values[loop]) != 0 && parseFloat(current_data_values[loop]) != 0) || parseFloat(previous_data_values[loop]) != 0) {
                    if (((Math.abs(parseFloat(previous_data_values[loop]) - parseFloat(current_data_values[loop]))) / parseFloat(previous_data_values[loop])) * 100 >= percentage_value) {
                        return true
                    }
                }
                loop++
            }
            if (found == true) {
                return false
            }
        }
        catch (ex) {
            logs.error('mqtt error stationdata/trackcircuit_difference_AB ' + ex);
            //console.log('mqtt error stationdata/trackcircuit_difference_AB ' + ex);
            return false
        }
    }

    async function trackcircuit_compare_Relay(trackcircuit_data, trackcircuitid, value) {
        try {
            let compare_index = comparetrackcircuitRelay.findIndex(obj => { return obj.key === trackcircuitid; })
            if (compare_index !== -1) {
                comparetrackcircuitRelay[compare_index].current_value = trackcircuit_data
                var compare_result = await trackcircuit_difference_Relay(comparetrackcircuitRelay[compare_index].previous_value, comparetrackcircuitRelay[compare_index].current_value, parseFloat(value))
                comparetrackcircuitRelay[compare_index].previous_value = trackcircuit_data
                return compare_result
            }
            else {
                comparetrackcircuitRelay.push({ key: trackcircuitid, previous_value: trackcircuit_data, current_value: [] })
                return true
            }
        }
        catch (ex) {
            logs.error('mqtt error stationdata/trackcircuit_compare_Relay ' + ex);
            //console.log('mqtt error stationdata/trackcircuit_compare_Relay ' + ex);
            return false
        }
    }

    async function trackcircuit_difference_Relay(previous_data, current_data, percentage_value) {
        try {
            var loop = 0
            var previous_data_values = Object.values(previous_data)
            var current_data_values = Object.values(current_data)
            let found = true
            while (loop < previous_data.length) {
                if ((parseFloat(previous_data_values[loop]) != 0 && parseFloat(current_data_values[loop]) != 0) || parseFloat(previous_data_values[loop]) != 0) {
                    if (((Math.abs(parseFloat(previous_data_values[loop]) - parseFloat(current_data_values[loop]))) / parseFloat(previous_data_values[loop])) * 100 >= percentage_value) {
                        return true
                    }
                }
                loop++
            }
            if (found == true) {
                return false
            }
        }
        catch (ex) {
            logs.error('mqtt error stationdata/trackcircuit_difference_AB ' + ex);
            //console.log('mqtt error stationdata/trackcircuit_difference_AB ' + ex);
            return false
        }
    }

    async function signalcircuit_compare(signalcircuit_data, signalcircuitid, value) {
        try {
            let compare_index = comparesignalcircuit.findIndex(obj => { return obj.key === signalcircuitid; })
            if (compare_index !== -1) {
                comparesignalcircuit[compare_index].current_value = signalcircuit_data
                var compare_result = await signalcircuit_difference(comparesignalcircuit[compare_index].previous_value, comparesignalcircuit[compare_index].current_value, parseFloat(value))
                comparesignalcircuit[compare_index].previous_value = signalcircuit_data
                return compare_result
            }
            else {
                comparesignalcircuit.push({ key: signalcircuitid, previous_value: signalcircuit_data, current_value: [] })
                return true
            }
        }
        catch (ex) {
            logs.error('mqtt error stationdata/signalcircuit_compare ' + ex);
            //console.log('mqtt error stationdata/signalcircuit_compare ' + ex);
            return false
        }
    }

    async function signalcircuit_difference(previous_data, current_data, percentage_value) {
        try {
            var loop = 0
            var previous_data_values = Object.values(previous_data)
            var current_data_values = Object.values(current_data)
            let found = true
            while (loop < previous_data.length) {
                if ((parseFloat(previous_data_values[loop]) != 0 && parseFloat(current_data_values[loop]) != 0) || parseFloat(previous_data_values[loop]) != 0) {
                    if (((Math.abs(parseFloat(previous_data_values[loop]) - parseFloat(current_data_values[loop]))) / parseFloat(previous_data_values[loop])) * 100 >= percentage_value) {
                        return true
                    }
                }
                loop++
            }
            if (found == true) {
                return false
            }
        }
        catch (ex) {
            logs.error('mqtt error stationdata/signalcircuit_difference ' + ex);
            //console.log('mqtt error stationdata/signalcircuit_difference ' + ex);
            return false
        }
    }

    async function axlecounter_compare(axlecounter_data, axlecounterid, value) {
        try {
            let compare_index = compareaxlecounter.findIndex(obj => { return obj.key === axlecounterid; })
            if (compare_index !== -1) {
                compareaxlecounter[compare_index].current_value = axlecounter_data
                var compare_result = await axlecounter_difference(compareaxlecounter[compare_index].previous_value, compareaxlecounter[compare_index].current_value, parseFloat(value))
                compareaxlecounter[compare_index].previous_value = axlecounter_data
                return compare_result
            }
            else {
                compareaxlecounter.push({ key: axlecounterid, previous_value: axlecounter_data, current_value: [] })
                return true
            }
        }
        catch (ex) {
            logs.error('mqtt error stationdata/axlecounter_compare ' + ex);
            //console.log('mqtt error stationdata/axlecounter_compare ' + ex);
            return false
        }
    }

    async function axlecounter_difference(previous_data, current_data, percentage_value) {
        try {
            var loop = 0
            var previous_data_values = Object.values(previous_data)
            var current_data_values = Object.values(current_data)
            let found = true
            while (loop < previous_data.length) {
                if ((parseFloat(previous_data_values[loop]) != 0 && parseFloat(current_data_values[loop]) != 0) || parseFloat(previous_data_values[loop]) != 0) {
                    if (((Math.abs(parseFloat(previous_data_values[loop]) - parseFloat(current_data_values[loop]))) / parseFloat(previous_data_values[loop])) * 100 >= percentage_value) {
                        return true
                    }
                }
                loop++
            }
            if (found == true) {
                return false
            }
        }
        catch (ex) {
            logs.error('mqtt error stationdata/axlecounter_difference ' + ex);
            //console.log('mqtt error stationdata/axlecounter_difference ' + ex);
            return false
        }
    }

    async function lcgate_compare(lcgate_data, lcgateid, value) {
        try {
            let compare_index = comparelcgate.findIndex(obj => { return obj.key === lcgateid; })
            if (compare_index !== -1) {
                comparelcgate[compare_index].current_value = lcgate_data
                var compare_result = await lcgate_difference(comparelcgate[compare_index].previous_value, comparelcgate[compare_index].current_value, parseFloat(value))
                comparelcgate[compare_index].previous_value = lcgate_data
                return compare_result
            }
            else {
                comparelcgate.push({ key: lcgateid, previous_value: lcgate_data, current_value: [] })
                return true
            }
        }
        catch (ex) {
            logs.error('mqtt error stationdata/lcgate_compare ' + ex);
            //console.log('mqtt error stationdata/lcgate_compare ' + ex);
            return false
        }
    }

    async function lcgate_difference(previous_data, current_data, percentage_value) {
        try {
            var loop = 0
            var previous_data_values = Object.values(previous_data)
            var current_data_values = Object.values(current_data)
            let found = true
            while (loop < previous_data.length) {
                if ((parseFloat(previous_data_values[loop]) != 0 && parseFloat(current_data_values[loop]) != 0) || parseFloat(previous_data_values[loop]) != 0) {
                    if (((Math.abs(parseFloat(previous_data_values[loop]) - parseFloat(current_data_values[loop]))) / parseFloat(previous_data_values[loop])) * 100 >= percentage_value) {
                        return true
                    }
                }
                loop++
            }
            if (found == true) {
                return false
            }
        }
        catch (ex) {
            logs.error('mqtt error stationdata/lcgate_difference ' + ex);
            //console.log('mqtt error stationdata/lcgate_difference ' + ex);
            return false
        }
    }

    async function eibattery_compare(eibattery_data, batteryid, value) {
        try {
            let compare_index = compareeibattery.findIndex(obj => { return obj.key === batteryid; });
            if (compare_index !== -1) {
                compareeibattery[compare_index].current_value = eibattery_data;
                var compare_result = await eibattery_difference(compareeibattery[compare_index].previous_value, compareeibattery[compare_index].current_value, parseFloat(value));
                compareeibattery[compare_index].previous_value = eibattery_data;
                return compare_result;
            } else {
                compareeibattery.push({ key: batteryid, previous_value: eibattery_data, current_value: [] });
                return true;
            }
        } catch (ex) {
            logs.error("mqtt error stationdata/eibattery_compare " + ex);
            //console.log('mqtt error stationdata/eibattery_compare ' + ex);
            return false;
        }
    }

    async function eibattery_difference(previous_data, current_data, percentage_value) {
        try {
            var loop = 0;
            var previous_data_values = Object.values(previous_data);
            var current_data_values = Object.values(current_data);
            let found = true;
            while (loop < previous_data.length) {
                if ((parseFloat(previous_data_values[loop]) != 0 && parseFloat(current_data_values[loop]) != 0) || parseFloat(previous_data_values[loop]) != 0) {
                    if ((Math.abs(parseFloat(previous_data_values[loop]) - parseFloat(current_data_values[loop])) / parseFloat(previous_data_values[loop])) * 100 >= percentage_value) {
                        return true;
                    }
                }
                loop++;
            }
            if (found == true) {
                return false;
            }
        } catch (ex) {
            logs.error("mqtt error stationdata/eibattery_difference " + ex);
            //console.log('mqtt error stationdata/eibattery_difference ' + ex);
            return false;
        }
    }

    async function ipsbattery_compare(ipsbattery_data, batteryid, value) {
        try {
            let compare_index = compareipsbattery.findIndex((obj) => { return obj.key === batteryid; });
            if (compare_index !== -1) {
                compareipsbattery[compare_index].current_value = ipsbattery_data;
                var compare_result = await eibattery_difference(compareipsbattery[compare_index].previous_value, compareipsbattery[compare_index].current_value, parseFloat(value));
                compareipsbattery[compare_index].previous_value = ipsbattery_data;
                return compare_result;
            } else {
                compareipsbattery.push({ key: batteryid, previous_value: ipsbattery_data, current_value: [] });
                return true;
            }
        } catch (ex) {
            logs.error("mqtt error stationdata/ipsbattery_compare " + ex);
            //console.log('mqtt error stationdata/ipsbattery_compare ' + ex);
            return false;
        }
    }

    async function ipsbattery_difference(previous_data, current_data, percentage_value) {
        try {
            var loop = 0;
            var previous_data_values = Object.values(previous_data);
            var current_data_values = Object.values(current_data);
            let found = true;
            while (loop < previous_data.length) {
                if ((parseFloat(previous_data_values[loop]) != 0 && parseFloat(current_data_values[loop]) != 0) || parseFloat(previous_data_values[loop]) != 0) {
                    if ((Math.abs(parseFloat(previous_data_values[loop]) - parseFloat(current_data_values[loop])) / parseFloat(previous_data_values[loop])) * 100 >= percentage_value) {
                        return true;
                    }
                }
                loop++;
            }
            if (found == true) {
                return false;
            }
        } catch (ex) {
            logs.error("mqtt error stationdata/ipsbattery_difference " + ex);
            //console.log('mqtt error stationdata/ipsbattery_difference ' + ex);
            return false;
        }
    }

    async function ips_compare(ips_data, batteryid, value) {
        try {
            let compare_index = compareips.findIndex(obj => { return obj.key === batteryid; });
            if (compare_index !== -1) {
                compareips[compare_index].current_value = ips_data;
                var compare_result = await ips_difference(compareips[compare_index].previous_value, compareips[compare_index].current_value, parseFloat(value));
                compareips[compare_index].previous_value = ips_data;
                return compare_result;
            } else {
                compareips.push({ key: batteryid, previous_value: ips_data, current_value: [] });
                return true;
            }
        } catch (ex) {
            logs.error("mqtt error stationdata/ips_compare " + ex);
            //console.log('mqtt error stationdata/ips_compare ' + ex);
            return false;
        }
    }

    async function ips_difference(previous_data, current_data, percentage_value) {
        try {
            var loop = 0;
            var previous_data_values = Object.values(previous_data);
            var current_data_values = Object.values(current_data);
            let found = true;
            while (loop < previous_data.length) {
                if ((parseFloat(previous_data_values[loop]) != 0 && parseFloat(current_data_values[loop]) != 0) || parseFloat(previous_data_values[loop]) != 0) {
                    if ((Math.abs(parseFloat(previous_data_values[loop]) - parseFloat(current_data_values[loop])) / parseFloat(previous_data_values[loop])) * 100 >= percentage_value) {
                        return true;
                    }
                }
                loop++;
            }
            if (found == true) {
                return false;
            }
        } catch (ex) {
            logs.error("mqtt error stationdata/ipsb_difference " + ex);
            //console.log('mqtt error stationdata/ips_difference ' + ex);
            return false;
        }
    }

    async function pointmachinealive_notification(alerts) {
        let transaction = await db.transaction({ autocommit: false });
        try {
            let alert_data = {}
            let alert_logs = []

            const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss")

            let mobile_notification_data = []

            for (let j = 0; j < alerts.length; j++) {
                let alertid = ""
                let dataid = ""
                let modeid = lodash.result(lodash.find(AlertModes, { 'mode': alerts[j].mode }), 'id')

                const cycle_index = pointmachineABdatas.findIndex(obj => { return obj.key === alerts[j].key.toString(); });
                if (cycle_index !== -1) {
                    dataid = pointmachineABdatas[cycle_index].id
                }
                if (dataid != "") {
                    alert_data = {
                        pointmachineid: alerts[j].key,
                        pointmachinedataid: dataid,
                        stationid: alerts[j].stationid,
                        message: alerts[j].message,
                        assertid: alerts[j].assertid,
                        modeid: modeid,
                        mode: alerts[j].mode,
                        createddate: current_datetime,
                        isdele: false
                    }
                    alert_logs.push(alert_data)

                    const alertinsert = await PointMachineAlert.create(alert_data, { transaction: transaction }).then(res => alertid = res.id)

                    var get_users = await NotificationControl.findAll({ where: { assertsid: alerts[j].assertid, stationid: alerts[j].stationid, isdele: false } })
                    var get_users_id = lodash.uniq(get_users.map(item => item.userid))

                    for (let i = 0; i < get_users_id.length; i++) {
                        const get_previous_notification = await NotificationSend.findOne({
                            where: { stationid: alerts[j].stationid, assertsid: alerts[j].assertid, alertmessageids: [alerts[j].id], modeid: modeid, userid: get_users_id[i], isseen: false, isdele: false },
                            order: [["id", "DESC"]]
                        })

                        if (get_previous_notification == null) {

                            mobile_notification_data.push({
                                stationid: alerts[j].stationid,
                                stationcode: alerts[j].stationcode,
                                stationname: alerts[j].stationname,
                                assertname: alerts[j].assertname,
                                assertsid: alerts[j].assertid,
                                assertidname: alerts[j].assertidname,
                                alertid: alertid,
                                userid: get_users_id[i],
                                message: alerts[j].message,
                                modeid: modeid,
                                mode: alerts[j].mode,
                                alertmessageids: [alerts[j].id],
                                isseen: false,
                                issend: false,
                                createddate: current_datetime,
                            })
                        }
                    }
                }
            }

            if (mobile_notification_data.length > 0) {
                const notifiyinsert = await NotificationSend.bulkCreate(mobile_notification_data, { transaction: transaction })
                Socket.emit('Notification', mobile_notification_data);
                //socketcloud.emit("Notification", mobile_notification_data)
            }

            logs.info(alerts.map(item => "PointMachine-" + item.assertidname + " communication lost at " + item.stationname + ' station').join(' ; '))
            await transaction.commit();
        }
        catch (ex) {
            await transaction.rollback();
            logs.error('pointmachine alive notification error ' + ex);
            //console.log('pointmachine alive notification error ' + ex);
        }
    }

    async function trackcircuitalive_notification(alerts) {
        let transaction = await db.transaction({ autocommit: false });
        try {
            let alert_data = {}
            let alert_logs = []

            let mobile_notification_data = []

            for (let j = 0; j < alerts.length; j++) {
                let alertid = ""
                let dataid = ""
                let modeid = lodash.result(lodash.find(AlertModes, { 'mode': alerts[j].mode }), 'id')

                const cycle_index = trackcircuitFeederRelaydatas.findIndex(obj => { return obj.key === alerts[j].key.toString(); });
                if (cycle_index !== -1) {
                    dataid = trackcircuitFeederRelaydatas[cycle_index].id
                }
                if (dataid != "") {
                    alert_data = {
                        trackcircuitid: alerts[j].key,
                        trackcircuitdataid: 1,
                        stationid: alerts[j].stationid,
                        message: alerts[j].message,
                        assertsid: alerts[j].assertid,
                        modeid: modeid,
                        mode: alerts[j].mode,
                        createddate: moment(),
                        isdele: false
                    }
                    alert_logs.push(alert_data)

                    const alertinsert = await TrackCircuitAlert.create(alert_data, { transaction: transaction }).then(res => alertid = res.id)

                    var get_users = await NotificationControl.findAll({ where: { assertsid: alerts[j].assertid, stationid: alerts[j].stationid, isdele: false } })
                    var get_users_id = lodash.uniq(get_users.map(item => item.userid))

                    for (let i = 0; i < get_users_id.length; i++) {

                        const get_previous_notification = await NotificationSend.findOne({
                            where: { stationid: alerts[j].stationid, assertsid: alerts[j].assertid, alertmessageids: [alerts[j].id], modeid: modeid, userid: get_users_id[i], isseen: false, isdele: false },
                            order: [["id", "DESC"]]
                        })

                        if (get_previous_notification == null) {
                            mobile_notification_data.push({
                                stationid: alerts[j].stationid,
                                stationcode: alerts[j].stationcode,
                                stationname: alerts[j].stationname,
                                assertname: alerts[j].assertname,
                                assertsid: alerts[j].assertid,
                                assertidname: alerts[j].assertidname,
                                alertid: alertid,
                                userid: get_users_id[i],
                                message: alerts[j].message,
                                modeid: modeid,
                                mode: alerts[j].mode,
                                alertmessageids: [alerts[j].id],
                                isseen: false,
                                issend: false,
                                createddate: moment(),
                            })
                        }
                    }
                }
            }
            if (mobile_notification_data.length > 0) {
                const notifiyinsert = await NotificationSend.bulkCreate(mobile_notification_data, { transaction: transaction })
                Socket.emit('Notification', mobile_notification_data);
                //socketcloud.emit("Notification", mobile_notification_data)
            }
            logs.info(alerts.map(item => "Trackname-" + item.assertidname + " communication lost at " + item.stationname + ' station').join(' ; '))
            await transaction.commit();
        }
        catch (ex) {
            await transaction.rollback();
            logs.error('trackcircuit alive notification error ' + ex);
            //console.log('trackcircuit alive notification error ' + ex);
        }
    }

    async function signalcircuitalive_notification(alerts) {
        let transaction = await db.transaction({ autocommit: false });
        try {
            let alert_data = {}
            let alert_logs = []

            let mobile_notification_data = []

            for (let j = 0; j < alerts.length; j++) {
                let dataid = ""
                let alertid = ""
                let modeid = lodash.result(lodash.find(AlertModes, { 'mode': alerts[j].mode }), 'id')

                const cycle_index = signalcircuitdatas.findIndex(obj => { return obj.key === alerts[j].key.toString(); });
                if (cycle_index !== -1) {
                    dataid = signalcircuitdatas[cycle_index].id
                }
                if (dataid != "") {
                    alert_data = {
                        signalcircuitid: alerts[j].key,
                        signalcircuitdataid: dataid,
                        stationid: alerts[j].stationid,
                        message: alerts[j].message,
                        assertsid: alerts[j].assertid,
                        modeid: modeid,
                        createddate: moment(),
                        isdele: false
                    }
                    alert_logs.push(alert_data)

                    const alertinsert = await SignalCircuitAlert.create(alert_data, { transaction: transaction }).then(res => alertid = res.id)

                    var get_users = await NotificationControl.findAll({ where: { assertsid: alerts[j].assertid, stationid: alerts[j].stationid, isdele: false } })
                    var get_users_id = lodash.uniq(get_users.map(item => item.userid))

                    for (let i = 0; i < get_users_id.length; i++) {

                        const get_previous_notification = await NotificationSend.findOne({
                            where: { stationid: alerts[j].stationid, assertsid: alerts[j].assertid, alertmessageids: [alerts[j].id], modeid: modeid, userid: get_users_id[i], isseen: false, isdele: false },
                            order: [["id", "DESC"]]
                        })

                        if (get_previous_notification == null) {
                            mobile_notification_data.push({
                                stationid: alerts[j].stationid,
                                stationcode: alerts[j].stationcode,
                                stationname: alerts[j].stationname,
                                assertname: alerts[j].assertname,
                                assertsid: alerts[j].assertid,
                                assertidname: alerts[j].signalname,
                                alertid: alertid,
                                userid: get_users_id[i],
                                message: alerts[j].message,
                                modeid: modeid,
                                mode: alerts[j].mode,
                                alertmessageids: [alerts[j].id],
                                isseen: false,
                                issend: false,
                                createddate: moment(),
                            })
                        }
                    }
                }
            }

            if (mobile_notification_data.length > 0) {
                const notifiyinsert = await NotificationSend.bulkCreate(mobile_notification_data, { transaction: transaction })
                Socket.emit('Notification', mobile_notification_data);
                //socketcloud.emit("Notification", mobile_notification_data)
            }
            logs.info(alerts.map(item => "Signalname-" + item.assertidname + " communication lost at " + item.stationname + ' station').join(' ; '))
            await transaction.commit();
        }
        catch (ex) {
            await transaction.rollback();
            logs.error('signalcircuit alive notification error ' + ex);
            //console.log('signalcircuit alive notification error ' + ex);
        }
    }

    async function axlecounteralive_notification(alerts) {
        let transaction = await db.transaction({ autocommit: false });
        try {
            let alert_data = {}
            let alert_logs = []

            let mobile_notification_data = []

            for (let j = 0; j < alerts.length; j++) {
                let dataid = ""
                let alertid = ""
                let modeid = lodash.result(lodash.find(AlertModes, { 'mode': alerts[j].mode }), 'id')

                const cycle_index = axlecounterdatas.findIndex(obj => { return obj.key === alerts[j].key.toString(); });
                if (cycle_index !== -1) {
                    dataid = axlecounterdatas[cycle_index].id
                }
                if (dataid != "") {
                    alert_data = {
                        axlecounterid: alerts[j].key,
                        axlecounterdataid: dataid,
                        stationid: alerts[j].stationid,
                        message: alerts[j].message,
                        assertsid: alerts[j].assertid,
                        modeid: modeid,
                        createddate: moment(),
                        isdele: false
                    }
                    alert_logs.push(alert_data)

                    const alertinsert = await AxleCounterAlert.create(alert_data, { transaction: transaction }).then(res => alertid = res.id)

                    var get_users = await NotificationControl.findAll({ where: { assertsid: alerts[j].assertid, stationid: alerts[j].stationid, isdele: false } })
                    var get_users_id = lodash.uniq(get_users.map(item => item.userid))

                    for (let i = 0; i < get_users_id.length; i++) {

                        const get_previous_notification = await NotificationSend.findOne({
                            where: { stationid: alerts[j].stationid, assertsid: alerts[j].assertid, alertmessageids: [alerts[j].id], modeid: modeid, userid: get_users_id[i], isseen: false, isdele: false },
                            order: [["id", "DESC"]]
                        })

                        if (get_previous_notification == null) {
                            mobile_notification_data.push({
                                stationid: alerts[j].stationid,
                                stationcode: alerts[j].stationcode,
                                stationname: alerts[j].stationname,
                                assertname: alerts[j].assertname,
                                assertsid: alerts[j].assertid,
                                assertidname: alerts[j].signalname,
                                alertid: alertid,
                                userid: get_users_id[i],
                                message: alerts[j].message,
                                modeid: modeid,
                                mode: alerts[j].mode,
                                alertmessageids: [alerts[j].id],
                                isseen: false,
                                issend: false,
                                createddate: moment(),
                            })
                        }
                    }
                }
            }

            if (mobile_notification_data.length > 0) {
                const notifiyinsert = await NotificationSend.bulkCreate(mobile_notification_data, { transaction: transaction })
                Socket.emit('Notification', mobile_notification_data);
                //socketcloud.emit("Notification", mobile_notification_data)
            }
            logs.info(alerts.map(item => "AxleCountername-" + item.assertidname + " communication lost at " + item.stationname + ' station').join(' ; '))
            await transaction.commit();
        }
        catch (ex) {
            await transaction.rollback();
            logs.error('axlecounter alive notification error ' + ex);
            //console.log('axlecounter alive notification error ' + ex);
        }
    }

    async function lcgatealive_notification(alerts) {
        let transaction = await db.transaction({ autocommit: false });
        try {
            let alert_data = {}
            let alert_logs = []

            let mobile_notification_data = []

            for (let j = 0; j < alerts.length; j++) {
                let dataid = ""
                let alertid = ""
                let modeid = lodash.result(lodash.find(AlertModes, { 'mode': alerts[j].mode }), 'id')

                const cycle_index = lcgatedatas.findIndex(obj => { return obj.key === alerts[j].key.toString(); });
                if (cycle_index !== -1) {
                    dataid = lcgatedatas[cycle_index].id
                }
                if (dataid != "") {
                    alert_data = {
                        lcgateid: alerts[j].key,
                        lcgatedataid: dataid,
                        stationid: alerts[j].stationid,
                        message: alerts[j].message,
                        assertsid: alerts[j].assertid,
                        modeid: modeid,
                        createddate: moment(),
                        isdele: false
                    }
                    alert_logs.push(alert_data)

                    const alertinsert = await LCGateAlert.create(alert_data, { transaction: transaction }).then(res => alertid = res.id)

                    var get_users = await NotificationControl.findAll({ where: { assertsid: alerts[j].assertid, stationid: alerts[j].stationid, isdele: false } })
                    var get_users_id = lodash.uniq(get_users.map(item => item.userid))

                    for (let i = 0; i < get_users_id.length; i++) {

                        const get_previous_notification = await NotificationSend.findOne({
                            where: { stationid: alerts[j].stationid, assertsid: alerts[j].assertid, alertmessageids: [alerts[j].id], modeid: modeid, userid: get_users_id[i], isseen: false, isdele: false },
                            order: [["id", "DESC"]]
                        })

                        if (get_previous_notification == null) {
                            mobile_notification_data.push({
                                stationid: alerts[j].stationid,
                                stationcode: alerts[j].stationcode,
                                stationname: alerts[j].stationname,
                                assertname: alerts[j].assertname,
                                assertsid: alerts[j].assertid,
                                assertidname: alerts[j].signalname,
                                alertid: alertid,
                                userid: get_users_id[i],
                                message: alerts[j].message,
                                modeid: modeid,
                                mode: alerts[j].mode,
                                alertmessageids: [alerts[j].id],
                                isseen: false,
                                issend: false,
                                createddate: moment(),
                            })
                        }
                    }
                }
            }

            if (mobile_notification_data.length > 0) {
                const notifiyinsert = await NotificationSend.bulkCreate(mobile_notification_data, { transaction: transaction })
                Socket.emit('Notification', mobile_notification_data);
                //socketcloud.emit("Notification", mobile_notification_data)
            }
            logs.info(alerts.map(item => "LCGateName-" + item.assertidname + " communication lost at " + item.stationname + ' station').join(' ; '))
            await transaction.commit();
        }
        catch (ex) {
            await transaction.rollback();
            logs.error('lcgate alive notification error ' + ex);
            //console.log('lcgate alive notification error ' + ex);
        }
    }

    async function eibatteryalive_notification(alerts) {
        let transaction = await db.transaction({ autocommit: false });
        try {
            let alert_data = {};
            let alert_logs = [];

            let mobile_notification_data = [];

            for (let j = 0; j < alerts.length; j++) {
                let dataid = "";
                let alertid = "";
                let modeid = lodash.result(lodash.find(AlertModes, { mode: alerts[j].mode }), "id");

                const cycle_index = eibatterydatas.findIndex(obj => { return obj.key === alerts[j].key.toString(); });
                if (cycle_index !== -1) {
                    dataid = eibatterydatas[cycle_index].id;
                }
                if (dataid != "") {
                    alert_data = {
                        batteryid: alerts[j].key,
                        batterydataid: dataid,
                        stationid: alerts[j].stationid,
                        message: alerts[j].message,
                        assertsid: alerts[j].assertid,
                        modeid: modeid,
                        createddate: moment(),
                        isdele: false,
                    };
                    alert_logs.push(alert_data);

                    const alertinsert = await BatteryAlert.create(alert_data, { transaction: transaction, }).then((res) => (alertid = res.id));

                    var get_users = await NotificationControl.findAll({ where: { assertsid: alerts[j].assertid, stationid: alerts[j].stationid, isdele: false, }, });
                    var get_users_id = lodash.uniq(get_users.map((item) => item.userid));

                    for (let i = 0; i < get_users_id.length; i++) {
                        const get_previous_notification = await NotificationSend.findOne({
                            where: { stationid: alerts[j].stationid, assertsid: alerts[j].assertid, alertmessageids: [alerts[j].id], modeid: modeid, userid: get_users_id[i], isseen: false, isdele: false, },
                            order: [["id", "DESC"]],
                        });

                        if (get_previous_notification == null) {
                            mobile_notification_data.push({
                                stationid: alerts[j].stationid,
                                stationcode: alerts[j].stationcode,
                                stationname: alerts[j].stationname,
                                assertname: alerts[j].assertname,
                                assertsid: alerts[j].assertid,
                                assertidname: alerts[j].signalname,
                                alertid: alertid,
                                userid: get_users_id[i],
                                message: alerts[j].message,
                                modeid: modeid,
                                mode: alerts[j].mode,
                                alertmessageids: [alerts[j].id],
                                isseen: false,
                                issend: false,
                                createddate: moment(),
                            });
                        }
                    }
                }
            }

            if (mobile_notification_data.length > 0) {
                const notifiyinsert = await NotificationSend.bulkCreate(mobile_notification_data, { transaction: transaction });
                Socket.emit("Notification", mobile_notification_data);
                //socketcloud.emit("Notification", mobile_notification_data)
            }
            logs.info(alerts.map(item => "EIBatteryName-" + item.assertidname + " communication lost at " + item.stationname + " station").join(" ; "));
            await transaction.commit();
        } catch (ex) {
            await transaction.rollback();
            logs.error("eibattery alive notification error " + ex);
            //console.log('eibattery alive notification error ' + ex);
        }
    }

    async function ipsbatteryalive_notification(alerts) {
        let transaction = await db.transaction({ autocommit: false });
        try {
            let alert_data = {};
            let alert_logs = [];

            let mobile_notification_data = [];

            for (let j = 0; j < alerts.length; j++) {
                let dataid = "";
                let alertid = "";
                let modeid = lodash.result(lodash.find(AlertModes, { mode: alerts[j].mode }), "id");

                const cycle_index = ipsbatterydatas.findIndex(obj => { return obj.key === alerts[j].key.toString() });
                if (cycle_index !== -1) {
                    dataid = ipsbatterydatas[cycle_index].id;
                }
                if (dataid != "") {
                    alert_data = {
                        batteryid: alerts[j].key,
                        batterydataid: dataid,
                        stationid: alerts[j].stationid,
                        message: alerts[j].message,
                        assertsid: alerts[j].assertid,
                        modeid: modeid,
                        createddate: moment(),
                        isdele: false,
                    };
                    alert_logs.push(alert_data);

                    const alertinsert = await BatteryAlert.create(alert_data, { transaction: transaction, }).then((res) => (alertid = res.id));

                    var get_users = await NotificationControl.findAll({ where: { assertsid: alerts[j].assertid, stationid: alerts[j].stationid, isdele: false, }, });
                    var get_users_id = lodash.uniq(get_users.map((item) => item.userid));

                    for (let i = 0; i < get_users_id.length; i++) {
                        const get_previous_notification = await NotificationSend.findOne({
                            where: { stationid: alerts[j].stationid, assertsid: alerts[j].assertid, alertmessageids: [alerts[j].id], modeid: modeid, userid: get_users_id[i], isseen: false, isdele: false, },
                            order: [["id", "DESC"]],
                        });

                        if (get_previous_notification == null) {
                            mobile_notification_data.push({
                                stationid: alerts[j].stationid,
                                stationcode: alerts[j].stationcode,
                                stationname: alerts[j].stationname,
                                assertname: alerts[j].assertname,
                                assertsid: alerts[j].assertid,
                                assertidname: alerts[j].signalname,
                                alertid: alertid,
                                userid: get_users_id[i],
                                message: alerts[j].message,
                                modeid: modeid,
                                mode: alerts[j].mode,
                                alertmessageids: [alerts[j].id],
                                isseen: false,
                                issend: false,
                                createddate: moment(),
                            });
                        }
                    }
                }
            }

            if (mobile_notification_data.length > 0) {
                const notifiyinsert = await NotificationSend.bulkCreate(mobile_notification_data, { transaction: transaction });
                Socket.emit("Notification", mobile_notification_data);
                //socketcloud.emit("Notification", mobile_notification_data)
            }
            logs.info(alerts.map((item) => "IPSBatteryName-" + item.assertidname + " communication lost at " + item.stationname + " station").join(" ; "));
            await transaction.commit();
        } catch (ex) {
            await transaction.rollback();
            logs.error("ipsbattery alive notification error " + ex);
            //console.log('ipsbattery alive notification error ' + ex);
        }
    }

    async function ipsalive_notification(alerts) {
        let transaction = await db.transaction({ autocommit: false });
        try {
            let alert_data = {};
            let alert_logs = [];

            let mobile_notification_data = [];

            for (let j = 0; j < alerts.length; j++) {
                let dataid = "";
                let alertid = "";
                let modeid = lodash.result(lodash.find(AlertModes, { mode: alerts[j].mode }), "id");

                const cycle_index = ipsdatas.findIndex(obj => { return obj.key === alerts[j].key.toString(); });
                if (cycle_index !== -1) {
                    dataid = ipsdatas[cycle_index].id;
                }
                if (dataid != "") {
                    alert_data = {
                        batteryid: alerts[j].key,
                        batterydataid: dataid,
                        stationid: alerts[j].stationid,
                        message: alerts[j].message,
                        assertsid: alerts[j].assertid,
                        modeid: modeid,
                        createddate: moment(),
                        isdele: false,
                    };
                    alert_logs.push(alert_data);

                    const alertinsert = await IPSAlert.create(alert_data, { transaction: transaction, }).then((res) => (alertid = res.id));

                    var get_users = await NotificationControl.findAll({ where: { assertsid: alerts[j].assertid, stationid: alerts[j].stationid, isdele: false, }, });
                    var get_users_id = lodash.uniq(get_users.map((item) => item.userid));

                    for (let i = 0; i < get_users_id.length; i++) {
                        const get_previous_notification = await NotificationSend.findOne({
                            where: { stationid: alerts[j].stationid, assertsid: alerts[j].assertid, alertmessageids: [alerts[j].id], modeid: modeid, userid: get_users_id[i], isseen: false, isdele: false, },
                            order: [["id", "DESC"]],
                        });

                        if (get_previous_notification == null) {
                            mobile_notification_data.push({
                                stationid: alerts[j].stationid,
                                stationcode: alerts[j].stationcode,
                                stationname: alerts[j].stationname,
                                assertname: alerts[j].assertname,
                                assertsid: alerts[j].assertid,
                                assertidname: alerts[j].signalname,
                                alertid: alertid,
                                userid: get_users_id[i],
                                message: alerts[j].message,
                                modeid: modeid,
                                mode: alerts[j].mode,
                                alertmessageids: [alerts[j].id],
                                isseen: false,
                                issend: false,
                                createddate: moment(),
                            });
                        }
                    }
                }
            }

            if (mobile_notification_data.length > 0) {
                const notifiyinsert = await NotificationSend.bulkCreate(mobile_notification_data, { transaction: transaction });
                Socket.emit("Notification", mobile_notification_data);
                //socketcloud.emit("Notification", mobile_notification_data)
            }
            logs.info(alerts.map((item) => "EIBatteryName-" + item.assertidname + " communication lost at " + item.stationname + " station").join(" ; "));
            await transaction.commit();
        } catch (ex) {
            await transaction.rollback();
            logs.error("ips alive notification error " + ex);
            //console.log('ips alive notification error ' + ex);
        }
    }


    //Mqtt subscriper
    client.on('connect', function () {

        // when a message arrives, do something with it
        client.subscribe('stationdata', function () {
            client.on('message', function (topic, message, packet) {
                //logs.info('stationdata values received', moment().format("YYYY-MM-DD HH:mm:ss"))
                //const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss")        
                //console.log('stationdata values received');
            })
        });

        // Active - Point Machine 1A
        client.subscribe('stationdata/PM_1A', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/PM_1A') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/PM_1A', moment().format("YYYY-MM-DD HH:mm:ss"))
                        //console.log('stationdata/PM_1A', moment().format("YYYY-MM-DD HH:mm:ss")
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss")
                        var pointmachine_1A_data = packet.payload.toString().split(',');
                        logs.info('stationdata/PM_1A', pointmachine_1A_data)

                        var allzero = pointmachine_1A_data.slice(2, 15).every(x => x === '0')

                        let pointmachineid = parseInt(pointmachine_1A_data[0]).toString(16).split("")[0]
                        let pointmachineterminal = String.fromCharCode(parseInt((parseInt(pointmachine_1A_data[0]).toString(16).split("")[1] + parseInt(pointmachine_1A_data[0]).toString(16).split("")[2]), 16))

                        const register_pointmachineid = await RegisteredPointMachine.findOne({ where: { id: pointmachineid, isdele: false } })

                        var logvalues = parseInt(pointmachine_1A_data[1], 10).toString(2).padStart(4, '0');

                        // var A1_run = logvalues[logvalues.length - 1] == 1 ? logvalues[logvalues.length - 1] : logvalues[logvalues.length - 2] == 1 ? logvalues[logvalues.length - 2] : 0
                        // var A1_log = logvalues[logvalues.length - 3] == 1 ? logvalues[logvalues.length - 3] : logvalues[logvalues.length - 4] == 1 ? logvalues[logvalues.length - 4] : 0                        

                        var A1_log = parseInt(pointmachine_1A_data[1]);

                        if (register_pointmachineid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_pointmachineid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Point Machine" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                var alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${asserts.assertname}@POINT_MACHINE_PERCENTAGE_DIFFERENCE`)
                                var final_result = false;
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await pointmachine_compare_A(pointmachine_1A_data.slice(2, 15), pointmachineid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_POINT_MACHINE_OPERATION`)
                                var log_result = false;
                                if (alert_name_values.isactive === true) {
                                    if (A1_log) {
                                        log_result = true
                                    }
                                }
                                else {
                                    log_result = true
                                }

                                final_result = compare_result && log_result == true ? true
                                    : compare_result == false && log_result == true ? true
                                        : false

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_timdec_values = parseFloat(process.env.TIME_DECIMAL_POINT)
                                let alert_pointalive_values = await get_alerts(`${station_id}@${pointmachineid}@${asserts.assertname}@SET_POINT_MACHINE_ALIVE`)

                                var index = pointmachineAlive.findIndex(obj => { return obj.key === pointmachineid; });
                                if (index !== -1) {
                                    pointmachineAlive[index].value = moment()
                                    pointmachineAlive[index].alive_limit = moment().add(parseInt(alert_pointalive_values.value), 'seconds')
                                    pointmachineAlive[index].message = await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit)
                                }
                                else {
                                    pointmachineAlive.push({
                                        key: pointmachineid, value: moment(), alive_limit: moment().add(parseInt(alert_pointalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit), mode: alert_pointalive_values.mode, id: alert_pointalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_pointmachineid.pointmachinename
                                    });
                                }

                                var pointA_direction = 0
                                if (parseFloat(pointmachine_1A_data[2]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_A_VOLTAGE`)) && parseFloat(pointmachine_1A_data[2]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_A_VOLTAGE`))) {
                                    pointA_direction = 1
                                }
                                else if (parseFloat(pointmachine_1A_data[3]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_A_VOLTAGE`)) && parseFloat(pointmachine_1A_data[3]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_A_VOLTAGE`))) {
                                    pointA_direction = 2
                                }
                                if (pointA_direction == 0) {
                                    if (parseFloat(pointmachine_1A_data[2]).toFixed(alert_voldec_values) < parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_A_VOLTAGE`)) && parseFloat(pointmachine_1A_data[3]).toFixed(alert_voldec_values) < parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`))) {
                                        if ((parseFloat(pointmachine_1A_data[6]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_OPERATING_A_CURRENT_AVG`))) && (parseFloat(pointmachine_1A_data[6]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_OPERATING_B_CURRENT_AVG`)))) {
                                            pointA_direction = 1
                                        }
                                        else {
                                            if ((parseFloat(pointmachine_1A_data[8]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_OPERATING_A_CURRENT_AVG`))) && (parseFloat(pointmachine_1A_data[8]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_OPERATING_B_CURRENT_AVG`)))) {
                                                pointA_direction = 2
                                            }
                                        }
                                    }
                                }
                                var index = pointmachineANoDirectionAlive.findIndex(obj => { return obj.key === pointmachineid; });
                                if (pointA_direction == 0) {
                                    if (index == -1) {
                                        pointmachineANoDirectionAlive.push({
                                            key: pointmachineid, value: moment(),
                                            message: await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit), mode: alert_pointalive_values.mode, id: alert_pointalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_pointmachineid.pointmachinename
                                        });
                                    }
                                    else {
                                        var pointAs = pointmachineANoDirectionAlive[index]
                                        var pointAsec = parseInt(moment().diff(pointAs.value, 'seconds'))
                                        var pointAnosec = parseInt(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@SET_NO_DIRECTION_ALIVE`))
                                        if (pointAsec > pointAnosec) {
                                            if ((lodash.isEqual(pointsAalive, pointAs) === false && pointsAalive == {}) || lodash.isEqual(pointsAalive, pointAs) === false) {
                                                pointsAalive = { ...pointAs }
                                                pointmachinealive_notification([pointAs])
                                            }
                                        }
                                    }
                                }
                                else {
                                    if (index !== -1) {
                                        pointmachineANoDirectionAlive.splice(index, 1)
                                        pointsAalive = {}
                                    }
                                }

                                if (final_result == true) {
                                    var cylcle_count = 1;
                                    if (pointA_direction === 1) {
                                        const cycle_index = pointmachineAdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Normal` });
                                        if (cycle_index !== -1) {
                                            cylcle_count = pointmachineAdatas[cycle_index].value + 1
                                            pointmachineAdatas[cycle_index].value = pointmachineAdatas[cycle_index].value + 1
                                        }
                                        else {
                                            var normal_count = [await PointmachineAdata.findOne({
                                                where: { pointmachineid: pointmachineid, direction: 'Normal' }
                                            })]
                                            normal_count = normal_count[0] !== null ? normal_count : []
                                            if (normal_count.length > 0) {
                                                cylcle_count = normal_count[0].cyclecount + 1
                                            }
                                            pointmachineAdatas.push({ key: `${pointmachineid}@Normal`, value: cylcle_count });
                                        }
                                    }
                                    else if (pointA_direction === 2) {
                                        const cycle_index = pointmachineAdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Reverse` });
                                        if (cycle_index !== -1) {
                                            cylcle_count = pointmachineAdatas[cycle_index].value + 1
                                            pointmachineAdatas[cycle_index].value = pointmachineAdatas[cycle_index].value + 1
                                        }
                                        else {
                                            var normal_count = [await PointmachineAdata.findOne({
                                                order: [["id", "DESC"]],
                                                where: { pointmachineid: pointmachineid, direction: 'Reverse' }
                                            })]
                                            normal_count = normal_count[0] !== null ? normal_count : []
                                            if (normal_count.length > 0) {
                                                cylcle_count = normal_count[0].cyclecount + 1
                                            }
                                            pointmachineAdatas.push({ key: `${pointmachineid}@Reverse`, value: cylcle_count });
                                        }
                                    }

                                    let point_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        pointmachineid: parseInt(pointmachineid),
                                        pointmachinename: register_pointmachineid.pointmachinename,
                                        cyclecount: cylcle_count,
                                        pointmachineterminal: pointmachineterminal,
                                        direction: pointA_direction == 1 ? 'Normal' : pointA_direction == 2 ? 'Reverse' : 'No Direction',
                                        forwardindicationvoltage: parseFloat(pointmachine_1A_data[2]).toFixed(alert_voldec_values),
                                        reverseindicationvoltage: parseFloat(pointmachine_1A_data[3]).toFixed(alert_voldec_values),
                                        forwardvoltage: parseFloat(pointmachine_1A_data[4]).toFixed(alert_voldec_values),
                                        reversevoltage: parseFloat(pointmachine_1A_data[5]).toFixed(alert_voldec_values),
                                        forwardcurrentavg: parseFloat(pointmachine_1A_data[6]).toFixed(alert_curdec_values),
                                        forwardcurrentpeak: parseFloat(pointmachine_1A_data[7]).toFixed(alert_curdec_values),
                                        reversecurrentavg: parseFloat(pointmachine_1A_data[8]).toFixed(alert_curdec_values),
                                        reversecurrentpeak: parseFloat(pointmachine_1A_data[9]).toFixed(alert_curdec_values),
                                        vibrationx: parseFloat(pointmachine_1A_data[10]).toFixed(alert_curdec_values),
                                        vibrationy: parseFloat(pointmachine_1A_data[11]).toFixed(alert_curdec_values),
                                        vibrationz: parseFloat(pointmachine_1A_data[12]).toFixed(alert_curdec_values),
                                        forwardtime: parseFloat(pointmachine_1A_data[13]).toFixed(alert_timdec_values),
                                        reversetime: parseFloat(pointmachine_1A_data[14]).toFixed(alert_timdec_values),
                                        log: parseInt(A1_log),
                                        createddate: current_datetime
                                    }

                                    //logs.info('PM_1A', point_data)

                                    let transaction = await db.transaction({ autocommit: false });
                                    try {
                                        const p1A_data_insert = await PointmachineAdata.create(
                                            point_data
                                            ,
                                            { transaction: transaction }
                                        );
                                        await transaction.commit();
                                        await insert_Apointnotification(point_data)
                                        logs.info("Point Machine 1A data inserted");
                                        //console.log("Point Machine 1A data inserted");

                                    }
                                    catch (ex) {
                                        await transaction.rollback();
                                        logs.error('mqtt error stationdata/PM_1A_inside ' + ex);
                                        //console.log('mqtt error stationdata/PM_1A_inside ' + ex);
                                    }
                                }
                            }
                        }
                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/PM_1A_outside ' + ex);
                        //console.log('mqtt error stationdata/PM_1A_outside ' + ex);
                    }
                }
            });
        });

        // Active - Point Machine 1B
        client.subscribe('stationdata/PM_1B', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/PM_1B') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/PM_1B', moment().format("YYYY-MM-DD HH:mm:ss"))
                        //console.log('stationdata/PM_1B', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss")
                        var pointmachine_1B_data = packet.payload.toString().split(',');
                        logs.info('stationdata/PM_1B', pointmachine_1B_data)

                        var allzero = pointmachine_1B_data.slice(2, 15).every(x => x === '0')

                        let pointmachineid = parseInt(pointmachine_1B_data[0]).toString(16).split("")[0]
                        let pointmachineterminal = String.fromCharCode(parseInt((parseInt(pointmachine_1B_data[0]).toString(16).split("")[1] + parseInt(pointmachine_1B_data[0]).toString(16).split("")[2]), 16))

                        const register_pointmachineid = await RegisteredPointMachine.findOne({ where: { id: pointmachineid, isdele: false } })

                        var logvalues = parseInt(pointmachine_1B_data[1], 10).toString(2).padStart(4, '0');

                        // var B1_run = logvalues[logvalues.length - 1] == 1 ? logvalues[logvalues.length - 1] : logvalues[logvalues.length - 2] == 1 ? logvalues[logvalues.length - 2] : 0
                        // var B1_log = logvalues[logvalues.length - 3] == 1 ? logvalues[logvalues.length - 3] : logvalues[logvalues.length - 3] == 1 ? logvalues[logvalues.length - 4] : 0                        

                        var B1_log = parseInt(pointmachine_1B_data[1]);

                        if (register_pointmachineid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_pointmachineid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Point Machine" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                var alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${asserts.assertname}@POINT_MACHINE_PERCENTAGE_DIFFERENCE`)
                                var final_result = false;
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await pointmachine_compare_B(pointmachine_1B_data.slice(2, 15), pointmachineid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_POINT_MACHINE_OPERATION`)
                                var log_result = false;
                                if (alert_name_values.isactive === true) {
                                    if (B1_log) {
                                        log_result = true
                                    }
                                }
                                else {
                                    log_result = true
                                }

                                final_result = compare_result && log_result == true ? true
                                    : compare_result == false && log_result == true ? true
                                        : false

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_timdec_values = parseFloat(process.env.TIME_DECIMAL_POINT)
                                let alert_pointalive_values = await get_alerts(`${station_id}@${pointmachineid}@${asserts.assertname}@SET_POINT_MACHINE_ALIVE`)

                                var index = pointmachineAlive.findIndex(obj => { return obj.key === pointmachineid; });
                                if (index !== -1) {
                                    pointmachineAlive[index].value = moment()
                                    pointmachineAlive[index].alive_limit = moment().add(parseInt(alert_pointalive_values.value), 'seconds')
                                    pointmachineAlive[index].message = await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit)
                                }
                                else {
                                    pointmachineAlive.push({
                                        key: pointmachineid, value: moment(), alive_limit: moment().add(parseInt(alert_pointalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit), mode: alert_pointalive_values.mode, id: alert_pointalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_pointmachineid.pointmachinename
                                    });
                                }

                                var pointB_direction = 0
                                if (parseFloat(pointmachine_1B_data[2]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`)) && parseFloat(pointmachine_1B_data[2]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_B_VOLTAGE`))) {
                                    pointB_direction = 1
                                }
                                else if (parseFloat(pointmachine_1B_data[3]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`)) && parseFloat(pointmachine_1B_data[3]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_B_VOLTAGE`))) {
                                    pointB_direction = 2
                                }
                                if (pointB_direction == 0) {
                                    if (parseFloat(pointmachine_data[15]).toFixed(alert_voldec_values) < parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`)) && parseFloat(pointmachine_data[16]).toFixed(alert_voldec_values) < parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`))) {
                                        if ((parseFloat(pointmachine_data[19]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_OPERATING_B_CURRENT_AVG`))) && (parseFloat(pointmachine_data[19]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_OPERATING_B_CURRENT_AVG`)))) {
                                            pointB_direction = 1
                                        }
                                        else {
                                            if ((parseFloat(pointmachine_data[21]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_OPERATING_B_CURRENT_AVG`))) && (parseFloat(pointmachine_data[21]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_OPERATING_B_CURRENT_AVG`)))) {
                                                pointB_direction = 2
                                            }
                                        }
                                    }
                                }
                                var index = pointmachineBNoDirectionAlive.findIndex(obj => { return obj.key === pointmachineid; });
                                if (pointB_direction == 0) {
                                    if (index == -1) {
                                        pointmachineBNoDirectionAlive.push({
                                            key: pointmachineid, value: moment(),
                                            message: await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit), mode: alert_pointalive_values.mode, id: alert_pointalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_pointmachineid.pointmachinename
                                        });
                                    }
                                    else {
                                        var pointBs = pointmachineBNoDirectionAlive[index]
                                        var pointBsec = parseInt(moment().diff(pointBs.value, 'seconds'))
                                        var pointBnosec = parseInt(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@SET_NO_DIRECTION_ALIVE`))

                                        if (pointBsec > pointBnosec) {
                                            if ((lodash.differenceBy(pointsBalive, pointBs).length === 0 && pointBs.length === 0) || lodash.differenceBy(pointBs, pointBs).length > 0) {
                                                pointsBalive = { ...pointBs }
                                                pointmachinealive_notification([pointBs])
                                            }
                                        }
                                    }
                                }
                                else {
                                    if (index !== -1) {
                                        pointmachineBNoDirectionAlive.splice(index, 1)
                                        pointsBalive = {}
                                    }
                                }

                                if (final_result == true) {
                                    var cylcle_count = 1;
                                    if (pointB_direction === 1) {
                                        const cycle_index = pointmachineBdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Normal` });
                                        if (cycle_index !== -1) {
                                            cylcle_count = pointmachineBdatas[cycle_index].value + 1
                                            pointmachineBdatas[cycle_index].value = pointmachineBdatas[cycle_index].value + 1
                                        }
                                        else {
                                            var normal_count = await PointmachineBdata.findOne({
                                                order: [["id", "DESC"]],
                                                where: { pointmachineid: pointmachineid, direction: 'Normal' }
                                            })
                                            if (normal_count != null) {
                                                cylcle_count = normal_count.cyclecount + 1
                                            }
                                            pointmachineBdatas.push({ key: `${pointmachineid}@Normal`, value: cylcle_count });
                                        }
                                    }
                                    else if (pointB_direction === 2) {
                                        const cycle_index = pointmachineBdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Reverse` });
                                        if (cycle_index !== -1) {
                                            cylcle_count = pointmachineBdatas[cycle_index].value + 1
                                            pointmachineBdatas[cycle_index].value = pointmachineBdatas[cycle_index].value + 1
                                        }
                                        else {
                                            var normal_count = await PointmachineBdata.findOne({
                                                order: [["id", "DESC"]],
                                                where: { pointmachineid: pointmachineid, direction: 'Reverse' }
                                            })
                                            if (normal_count != null) {
                                                cylcle_count = normal_count.cyclecount + 1
                                            }
                                            pointmachineBdatas.push({ key: `${pointmachineid}@Reverse`, value: cylcle_count });
                                        }
                                    }

                                    let point_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        pointmachineid: parseInt(pointmachineid),
                                        pointmachinename: register_pointmachineid.pointmachinename,
                                        cyclecount: cylcle_count,
                                        pointmachineterminal: pointmachineterminal,
                                        direction: pointB_direction == 1 ? 'Normal' : pointB_direction == 2 ? 'Reverse' : 'No Direction',
                                        forwardindicationvoltage: parseFloat(pointmachine_1B_data[2]).toFixed(alert_voldec_values),
                                        reverseindicationvoltage: parseFloat(pointmachine_1B_data[3]).toFixed(alert_voldec_values),
                                        forwardvoltage: parseFloat(pointmachine_1B_data[4]).toFixed(alert_voldec_values),
                                        reversevoltage: parseFloat(pointmachine_1B_data[5]).toFixed(alert_voldec_values),
                                        forwardcurrentavg: parseFloat(pointmachine_1B_data[6]).toFixed(alert_curdec_values),
                                        forwardcurrentpeak: parseFloat(pointmachine_1B_data[7]).toFixed(alert_curdec_values),
                                        reversecurrentavg: parseFloat(pointmachine_1B_data[8]).toFixed(alert_curdec_values),
                                        reversecurrentpeak: parseFloat(pointmachine_1B_data[9]).toFixed(alert_curdec_values),
                                        vibrationx: parseFloat(pointmachine_1B_data[10]).toFixed(alert_curdec_values),
                                        vibrationy: parseFloat(pointmachine_1B_data[11]).toFixed(alert_curdec_values),
                                        vibrationz: parseFloat(pointmachine_1B_data[12]).toFixed(alert_curdec_values),
                                        forwardtime: parseFloat(pointmachine_1B_data[13]).toFixed(alert_timdec_values),
                                        reversetime: parseFloat(pointmachine_1B_data[14]).toFixed(alert_timdec_values),
                                        log: parseInt(B1_log),
                                        createddate: current_datetime
                                    }
                                    //logs.info('PM_1B', B_point_data)

                                    let transaction = await db.transaction({ autocommit: false });
                                    try {
                                        const p1B_data_insert = await PointmachineBdata.create(
                                            point_data
                                            ,
                                            { transaction: transaction }
                                        )
                                        await transaction.commit();

                                        logs.info("Point Machine 1B data inserted");
                                        //console.log("Point Machine 1B data inserted");                
                                        await insert_Bpointnotification(point_data);
                                    }
                                    catch (ex) {
                                        await transaction.rollback();
                                        logs.error('mqtt error stationdata/PM_1B_inside ' + ex);
                                        //console.log('mqtt error stationdata/PM_1B_inside ' + ex);
                                    }
                                }
                            }
                        }
                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/PM_1B_outside ' + ex);
                        //console.log('mqtt error stationdata/PM_1B_outside ' + ex);
                    }
                }
            });
        });

        // Active - Point Machine 2A
        client.subscribe('stationdata/PM_2A', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/PM_2A') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/PM_2A', moment().format("YYYY-MM-DD HH:mm:ss"))
                        //console.log('stationdata/PM_2A', moment().format("YYYY-MM-DD HH:mm:ss")
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss")
                        var pointmachine_2A_data = packet.payload.toString().split(',');
                        logs.info('stationdata/PM_2A', pointmachine_2A_data)

                        var allzero = pointmachine_2A_data.slice(2, 15).every(x => x === '0')

                        let pointmachineid = parseInt(pointmachine_2A_data[0]).toString(16).split("")[0]
                        let pointmachineterminal = String.fromCharCode(parseInt((parseInt(pointmachine_2A_data[0]).toString(16).split("")[1] + parseInt(pointmachine_2A_data[0]).toString(16).split("")[2]), 16))

                        const register_pointmachineid = await RegisteredPointMachine.findOne({ where: { id: pointmachineid, isdele: false } })

                        // var logvalues = parseInt(pointmachine_2A_data[1], 10).toString(2).padStart(4, '0');

                        // var A1_run = logvalues[logvalues.length - 1] == 1 ? logvalues[logvalues.length - 1] : logvalues[logvalues.length - 2] == 1 ? logvalues[logvalues.length - 2] : 0
                        // var A1_log = logvalues[logvalues.length - 3] == 1 ? logvalues[logvalues.length - 3] : logvalues[logvalues.length - 4] == 1 ? logvalues[logvalues.length - 4] : 0

                        var A1_log = parseInt(pointmachine_2A_data[1]);

                        if (register_pointmachineid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_pointmachineid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Point Machine" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                var alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${asserts.assertname}@POINT_MACHINE_PERCENTAGE_DIFFERENCE`)
                                var final_result = false;
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await pointmachine_compare_A(pointmachine_2A_data.slice(2, 15), pointmachineid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_POINT_MACHINE_OPERATION`)
                                var log_result = false;
                                if (alert_name_values.isactive === true) {
                                    if (A1_log) {
                                        log_result = true
                                    }
                                }
                                else {
                                    log_result = true
                                }

                                final_result = compare_result && log_result == true ? true
                                    : compare_result == false && log_result == true ? true
                                        : false

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_timdec_values = parseFloat(process.env.TIME_DECIMAL_POINT)
                                let alert_pointalive_values = await get_alerts(`${station_id}@${pointmachineid}@${asserts.assertname}@SET_POINT_MACHINE_ALIVE`)

                                var index = pointmachineAlive.findIndex(obj => { return obj.key === pointmachineid; });
                                if (index !== -1) {
                                    pointmachineAlive[index].value = moment()
                                    pointmachineAlive[index].alive_limit = moment().add(parseInt(alert_pointalive_values.value), 'seconds')
                                    pointmachineAlive[index].message = await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit)
                                }
                                else {
                                    pointmachineAlive.push({
                                        key: pointmachineid, value: moment(), alive_limit: moment().add(parseInt(alert_pointalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit), mode: alert_pointalive_values.mode, id: alert_pointalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_pointmachineid.pointmachinename
                                    });
                                }

                                var pointA_direction = 0
                                if (parseFloat(pointmachine_2A_data[2]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_A_VOLTAGE`)) && parseFloat(pointmachine_2A_data[2]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_A_VOLTAGE`))) {
                                    pointA_direction = 1
                                }
                                else if (parseFloat(pointmachine_2A_data[3]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_A_VOLTAGE`)) && parseFloat(pointmachine_2A_data[3]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_A_VOLTAGE`))) {
                                    pointA_direction = 2
                                }
                                if (pointA_direction == 0) {
                                    if (parseFloat(pointmachine_2A_data[2]).toFixed(alert_voldec_values) < parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_A_VOLTAGE`)) && parseFloat(pointmachine_2A_data[3]).toFixed(alert_voldec_values) < parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`))) {
                                        if ((parseFloat(pointmachine_2A_data[6]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_OPERATING_A_CURRENT_AVG`))) && (parseFloat(pointmachine_2A_data[6]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_OPERATING_B_CURRENT_AVG`)))) {
                                            pointA_direction = 1
                                        }
                                        else {
                                            if ((parseFloat(pointmachine_2A_data[8]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_OPERATING_A_CURRENT_AVG`))) && (parseFloat(pointmachine_2A_data[8]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_OPERATING_B_CURRENT_AVG`)))) {
                                                pointA_direction = 2
                                            }
                                        }
                                    }
                                }
                                var index = pointmachineANoDirectionAlive.findIndex(obj => { return obj.key === pointmachineid; });
                                if (pointA_direction == 0) {
                                    if (index == -1) {
                                        pointmachineANoDirectionAlive.push({
                                            key: pointmachineid, value: moment(),
                                            message: await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit), mode: alert_pointalive_values.mode, id: alert_pointalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_pointmachineid.pointmachinename
                                        });
                                    }
                                    else {
                                        var pointAs = pointmachineANoDirectionAlive[index]
                                        var pointAsec = parseInt(moment().diff(pointAs.value, 'seconds'))
                                        var pointAnosec = parseInt(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@SET_NO_DIRECTION_ALIVE`))
                                        if (pointAsec > pointAnosec) {
                                            if ((lodash.isEqual(pointsAalive, pointAs) === false && pointsAalive == {}) || lodash.isEqual(pointsAalive, pointAs) === false) {
                                                pointsAalive = { ...pointAs }
                                                pointmachinealive_notification([pointAs])
                                            }
                                        }
                                    }
                                }
                                else {
                                    if (index !== -1) {
                                        pointmachineANoDirectionAlive.splice(index, 1)
                                        pointsAalive = {}
                                    }
                                }

                                if (final_result == true) {
                                    var cylcle_count = 1;
                                    if (pointA_direction === 1) {
                                        const cycle_index = pointmachineAdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Normal` });
                                        if (cycle_index !== -1) {
                                            cylcle_count = pointmachineAdatas[cycle_index].value + 1
                                            pointmachineAdatas[cycle_index].value = pointmachineAdatas[cycle_index].value + 1
                                        }
                                        else {
                                            var normal_count = [await PointmachineAdata.findOne({
                                                where: { pointmachineid: pointmachineid, direction: 'Normal' }
                                            })]
                                            normal_count = normal_count[0] !== null ? normal_count : []
                                            if (normal_count.length > 0) {
                                                cylcle_count = normal_count[0].cyclecount + 1
                                            }
                                            pointmachineAdatas.push({ key: `${pointmachineid}@Normal`, value: cylcle_count });
                                        }
                                    }
                                    else if (pointA_direction === 2) {
                                        const cycle_index = pointmachineAdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Reverse` });
                                        if (cycle_index !== -1) {
                                            cylcle_count = pointmachineAdatas[cycle_index].value + 1
                                            pointmachineAdatas[cycle_index].value = pointmachineAdatas[cycle_index].value + 1
                                        }
                                        else {
                                            var normal_count = [await PointmachineAdata.findOne({
                                                order: [["id", "DESC"]],
                                                where: { pointmachineid: pointmachineid, direction: 'Reverse' }
                                            })]
                                            normal_count = normal_count[0] !== null ? normal_count : []
                                            if (normal_count.length > 0) {
                                                cylcle_count = normal_count[0].cyclecount + 1
                                            }
                                            pointmachineAdatas.push({ key: `${pointmachineid}@Reverse`, value: cylcle_count });
                                        }
                                    }

                                    let point_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        pointmachineid: parseInt(pointmachineid),
                                        pointmachinename: register_pointmachineid.pointmachinename,
                                        cyclecount: cylcle_count,
                                        pointmachineterminal: pointmachineterminal,
                                        direction: pointA_direction == 1 ? 'Normal' : pointA_direction == 2 ? 'Reverse' : 'No Direction',
                                        forwardindicationvoltage: parseFloat(pointmachine_2A_data[2]).toFixed(alert_voldec_values),
                                        reverseindicationvoltage: parseFloat(pointmachine_2A_data[3]).toFixed(alert_voldec_values),
                                        forwardvoltage: parseFloat(pointmachine_2A_data[4]).toFixed(alert_voldec_values),
                                        reversevoltage: parseFloat(pointmachine_2A_data[5]).toFixed(alert_voldec_values),
                                        forwardcurrentavg: parseFloat(pointmachine_2A_data[6]).toFixed(alert_curdec_values),
                                        forwardcurrentpeak: parseFloat(pointmachine_2A_data[7]).toFixed(alert_curdec_values),
                                        reversecurrentavg: parseFloat(pointmachine_2A_data[8]).toFixed(alert_curdec_values),
                                        reversecurrentpeak: parseFloat(pointmachine_2A_data[9]).toFixed(alert_curdec_values),
                                        vibrationx: parseFloat(pointmachine_2A_data[10]).toFixed(alert_curdec_values),
                                        vibrationy: parseFloat(pointmachine_2A_data[11]).toFixed(alert_curdec_values),
                                        vibrationz: parseFloat(pointmachine_2A_data[12]).toFixed(alert_curdec_values),
                                        forwardtime: parseFloat(pointmachine_2A_data[13]).toFixed(alert_timdec_values),
                                        reversetime: parseFloat(pointmachine_2A_data[14]).toFixed(alert_timdec_values),
                                        log: parseInt(A1_log),
                                        createddate: current_datetime
                                    }

                                    //logs.info('PM_2A', point_data)

                                    let transaction = await db.transaction({ autocommit: false });
                                    try {
                                        const p2A_data_insert = await PointmachineAdata.create(
                                            point_data
                                            ,
                                            { transaction: transaction }
                                        );
                                        await transaction.commit();
                                        await insert_Apointnotification(point_data)
                                        logs.info("Point Machine 2A data inserted");
                                        //console.log("Point Machine 2A data inserted");

                                    }
                                    catch (ex) {
                                        await transaction.rollback();
                                        logs.error('mqtt error stationdata/PM_2A_inside ' + ex);
                                        //console.log('mqtt error stationdata/PM_2A_inside ' + ex);
                                    }
                                }
                            }
                        }
                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/PM_2A_outside ' + ex);
                        //console.log('mqtt error stationdata/PM_2A_outside ' + ex);
                    }
                }
            });
        });

        // Active - Point Machine 1C
        client.subscribe('stationdata/PM_1C', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/PM_1C') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/PM_1C', moment().format("YYYY-MM-DD HH:mm:ss"))
                        //console.log('stationdata/PM_1C', moment().format("YYYY-MM-DD HH:mm:ss")
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss")
                        var pointmachine_data = packet.payload.toString().split(',');
                        logs.info('stationdata/PM_1C', pointmachine_data)

                        var allzero = pointmachine_data.slice(2, pointmachine_data.length).every(x => x === '0')

                        let pointmachineid = parseInt(pointmachine_data[0]).toString(16).split("")[0]
                        let pointmachineterminal = String.fromCharCode(parseInt((parseInt(pointmachine_data[0]).toString(16).split("")[1] + parseInt(pointmachine_data[0]).toString(16).split("")[2]), 16))

                        const register_pointmachineid = await RegisteredPointMachine.findOne({ where: { id: pointmachineid, isdele: false } })

                        var logvalues = parseInt(pointmachine_data[1], 10).toString(2).padStart(4, '0');

                        var A1_run = logvalues[logvalues.length - 1]
                        var B1_run = logvalues[logvalues.length - 2]
                        var A1_log = logvalues[logvalues.length - 3]
                        var B1_log = logvalues[logvalues.length - 4]

                        if (register_pointmachineid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_pointmachineid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Point Machine" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                var alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${asserts.assertname}@POINT_MACHINE_PERCENTAGE_DIFFERENCE`)
                                var final_result = false;
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await pointmachine_compare_AB(pointmachine_data.slice(2, pointmachine_data.length), pointmachineid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_POINT_MACHINE_OPERATION`)
                                var log_result = false;
                                if (alert_name_values.isactive === true) {
                                    log_result = await pointmachine_logdifference_AB(A1_log, B1_log, pointmachineid, parseFloat(alert_name_values.value))
                                }
                                else {
                                    log_result = true
                                }

                                final_result = compare_result && log_result == true ? true
                                    : compare_result == false && log_result == true ? true
                                        : false

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_timdec_values = parseFloat(process.env.TIME_DECIMAL_POINT)
                                let alert_pointalive_values = await get_alerts(`${station_id}@${pointmachineid}@${asserts.assertname}@SET_POINT_MACHINE_ALIVE`)

                                var index = pointmachineAlive.findIndex(obj => { return obj.key === pointmachineid; });
                                if (index !== -1) {
                                    pointmachineAlive[index].value = moment()
                                    pointmachineAlive[index].alive_limit = moment().add(parseInt(alert_pointalive_values.value), 'seconds')
                                    pointmachineAlive[index].message = await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit)
                                }
                                else {
                                    pointmachineAlive.push({
                                        key: pointmachineid, value: moment(), alive_limit: moment().add(parseInt(alert_pointalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit), mode: alert_pointalive_values.mode, id: alert_pointalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_pointmachineid.pointmachinename
                                    });
                                }

                                var pointA_direction = 0
                                if (parseFloat(pointmachine_data[2]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_A_VOLTAGE`)) && parseFloat(pointmachine_data[2]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_A_VOLTAGE`))) {
                                    pointA_direction = 1
                                }
                                else if (parseFloat(pointmachine_data[3]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_A_VOLTAGE`)) && parseFloat(pointmachine_data[3]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_A_VOLTAGE`))) {
                                    pointA_direction = 2
                                }
                                if (pointA_direction == 0) {
                                    if (parseFloat(pointmachine_data[2]).toFixed(alert_voldec_values) < parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_A_VOLTAGE`)) && parseFloat(pointmachine_data[3]).toFixed(alert_voldec_values) < parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`))) {
                                        if ((parseFloat(pointmachine_data[6]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_OPERATING_A_CURRENT_AVG`))) && (parseFloat(pointmachine_data[6]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_OPERATING_B_CURRENT_AVG`)))) {
                                            pointA_direction = 1
                                        }
                                        else {
                                            if ((parseFloat(pointmachine_data[8]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_OPERATING_A_CURRENT_AVG`))) && (parseFloat(pointmachine_data[8]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_OPERATING_B_CURRENT_AVG`)))) {
                                                pointA_direction = 2
                                            }
                                        }
                                    }
                                }
                                var index = pointmachineANoDirectionAlive.findIndex(obj => { return obj.key === pointmachineid; });
                                if (pointA_direction == 0) {
                                    if (index == -1) {
                                        pointmachineANoDirectionAlive.push({
                                            key: pointmachineid, value: moment(),
                                            message: await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit), mode: alert_pointalive_values.mode, id: alert_pointalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_pointmachineid.pointmachinename
                                        });
                                    }
                                    else {
                                        var pointAs = pointmachineANoDirectionAlive[index]
                                        var pointAsec = parseInt(moment().diff(pointAs.value, 'seconds'))
                                        var pointAnosec = parseInt(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@SET_NO_DIRECTION_ALIVE`))
                                        if (pointAsec > pointAnosec) {
                                            if ((lodash.isEqual(pointsAalive, pointAs) === false && pointsAalive == {}) || lodash.isEqual(pointsAalive, pointAs) === false) {
                                                pointsAalive = { ...pointAs }
                                                pointmachinealive_notification([pointAs])
                                            }
                                        }
                                    }
                                }
                                else {
                                    if (index !== -1) {
                                        pointmachineANoDirectionAlive.splice(index, 1)
                                        pointsAalive = {}
                                    }
                                }

                                var pointB_direction = 0
                                if (parseFloat(pointmachine_data[15]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`)) && parseFloat(pointmachine_data[15]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_B_VOLTAGE`))) {
                                    pointB_direction = 1
                                }
                                else if (parseFloat(pointmachine_data[16]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`)) && parseFloat(pointmachine_data[16]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_B_VOLTAGE`))) {
                                    pointB_direction = 2
                                }
                                if (pointB_direction == 0) {
                                    if (parseFloat(pointmachine_data[15]).toFixed(alert_voldec_values) < parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`)) && parseFloat(pointmachine_data[16]).toFixed(alert_voldec_values) < parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`))) {
                                        if ((parseFloat(pointmachine_data[19]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_OPERATING_B_CURRENT_AVG`))) && (parseFloat(pointmachine_data[19]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_OPERATING_B_CURRENT_AVG`)))) {
                                            pointB_direction = 1
                                        }
                                        else {
                                            if ((parseFloat(pointmachine_data[21]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_OPERATING_B_CURRENT_AVG`))) && (parseFloat(pointmachine_data[21]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_OPERATING_B_CURRENT_AVG`)))) {
                                                pointB_direction = 2
                                            }
                                        }
                                    }
                                }
                                var index = pointmachineBNoDirectionAlive.findIndex(obj => { return obj.key === pointmachineid; });
                                if (pointB_direction == 0) {
                                    if (index == -1) {
                                        pointmachineBNoDirectionAlive.push({
                                            key: pointmachineid, value: moment(),
                                            message: await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit), mode: alert_pointalive_values.mode, id: alert_pointalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_pointmachineid.pointmachinename
                                        });
                                    }
                                    else {
                                        var pointBs = pointmachineBNoDirectionAlive[index]
                                        var pointBsec = parseInt(moment().diff(pointBs.value, 'seconds'))
                                        var pointBnosec = parseInt(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@SET_NO_DIRECTION_ALIVE`))

                                        if (pointBsec > pointBnosec) {
                                            if ((lodash.differenceBy(pointsBalive, pointBs).length === 0 && pointBs.length === 0) || lodash.differenceBy(pointBs, pointBs).length > 0) {
                                                pointsBalive = { ...pointBs }
                                                pointmachinealive_notification([pointBs])
                                            }
                                        }
                                    }
                                }
                                else {
                                    if (index !== -1) {
                                        pointmachineBNoDirectionAlive.splice(index, 1)
                                        pointsBalive = {}
                                    }
                                }

                                if (final_result == true) {
                                    var cylcle_count = 1;
                                    if (pointA_direction === 1) {
                                        const cycle_index = pointmachineAdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Normal` });
                                        if (cycle_index !== -1) {
                                            cylcle_count = pointmachineAdatas[cycle_index].value + 1
                                            pointmachineAdatas[cycle_index].value = pointmachineAdatas[cycle_index].value + 1
                                        }
                                        else {
                                            var normal_count = [await PointmachineAdata.findOne({
                                                where: { pointmachineid: pointmachineid, direction: 'Normal' }
                                            })]
                                            normal_count = normal_count[0] !== null ? normal_count : []
                                            if (normal_count.length > 0) {
                                                cylcle_count = normal_count[0].cyclecount + 1
                                            }
                                            pointmachineAdatas.push({ key: `${pointmachineid}@Normal`, value: cylcle_count });
                                        }
                                    }
                                    else if (pointA_direction === 2) {
                                        const cycle_index = pointmachineAdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Reverse` });
                                        if (cycle_index !== -1) {
                                            cylcle_count = pointmachineAdatas[cycle_index].value + 1
                                            pointmachineAdatas[cycle_index].value = pointmachineAdatas[cycle_index].value + 1
                                        }
                                        else {
                                            var normal_count = [await PointmachineAdata.findOne({
                                                order: [["id", "DESC"]],
                                                where: { pointmachineid: pointmachineid, direction: 'Reverse' }
                                            })]
                                            normal_count = normal_count[0] !== null ? normal_count : []
                                            if (normal_count.length > 0) {
                                                cylcle_count = normal_count[0].cyclecount + 1
                                            }
                                            pointmachineAdatas.push({ key: `${pointmachineid}@Reverse`, value: cylcle_count });
                                        }
                                    }

                                    let A_point_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        pointmachineid: parseInt(pointmachineid),
                                        pointmachinename: register_pointmachineid.pointmachinename,
                                        cyclecount: cylcle_count,
                                        pointmachineterminal: pointmachineterminal,
                                        direction: pointA_direction == 1 ? 'Normal' : pointA_direction == 2 ? 'Reverse' : 'No Direction',
                                        forwardindicationvoltage: parseFloat(pointmachine_data[2]).toFixed(alert_voldec_values),
                                        reverseindicationvoltage: parseFloat(pointmachine_data[3]).toFixed(alert_voldec_values),
                                        forwardvoltage: parseFloat(pointmachine_data[4]).toFixed(alert_voldec_values),
                                        reversevoltage: parseFloat(pointmachine_data[5]).toFixed(alert_voldec_values),
                                        forwardcurrentavg: parseFloat(pointmachine_data[6]).toFixed(alert_curdec_values),
                                        forwardcurrentpeak: parseFloat(pointmachine_data[7]).toFixed(alert_curdec_values),
                                        reversecurrentavg: parseFloat(pointmachine_data[8]).toFixed(alert_curdec_values),
                                        reversecurrentpeak: parseFloat(pointmachine_data[9]).toFixed(alert_curdec_values),
                                        vibrationx: parseFloat(pointmachine_data[10]).toFixed(alert_curdec_values),
                                        vibrationy: parseFloat(pointmachine_data[11]).toFixed(alert_curdec_values),
                                        vibrationz: parseFloat(pointmachine_data[12]).toFixed(alert_curdec_values),
                                        forwardtime: parseFloat(pointmachine_data[13]).toFixed(alert_timdec_values),
                                        reversetime: parseFloat(pointmachine_data[14]).toFixed(alert_timdec_values),
                                        log: parseInt(A1_log),
                                        createddate: current_datetime
                                    }
                                    //logs.info('PM_1AB', A_point_data)                     

                                    var cylcle_count = 1;
                                    if (pointB_direction === 1) {
                                        const cycle_index = pointmachineBdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Normal` });
                                        if (cycle_index !== -1) {
                                            cylcle_count = pointmachineBdatas[cycle_index].value + 1
                                            pointmachineBdatas[cycle_index].value = pointmachineBdatas[cycle_index].value + 1
                                        }
                                        else {
                                            var normal_count = await PointmachineBdata.findOne({
                                                order: [["id", "DESC"]],
                                                where: { pointmachineid: pointmachineid, direction: 'Normal' }
                                            })
                                            if (normal_count != null) {
                                                cylcle_count = normal_count.cyclecount + 1
                                            }
                                            pointmachineBdatas.push({ key: `${pointmachineid}@Normal`, value: cylcle_count });
                                        }
                                    }
                                    else if (pointB_direction === 2) {
                                        const cycle_index = pointmachineBdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Reverse` });
                                        if (cycle_index !== -1) {
                                            cylcle_count = pointmachineBdatas[cycle_index].value + 1
                                            pointmachineBdatas[cycle_index].value = pointmachineBdatas[cycle_index].value + 1
                                        }
                                        else {
                                            var normal_count = await PointmachineBdata.findOne({
                                                order: [["id", "DESC"]],
                                                where: { pointmachineid: pointmachineid, direction: 'Reverse' }
                                            })
                                            if (normal_count != null) {
                                                cylcle_count = normal_count.cyclecount + 1
                                            }
                                            pointmachineBdatas.push({ key: `${pointmachineid}@Reverse`, value: cylcle_count });
                                        }
                                    }

                                    let B_point_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        pointmachineid: parseInt(pointmachineid),
                                        pointmachinename: register_pointmachineid.pointmachinename,
                                        cyclecount: cylcle_count,
                                        pointmachineterminal: pointmachineterminal,
                                        direction: pointB_direction == 1 ? 'Normal' : pointB_direction == 2 ? 'Reverse' : 'No Direction',
                                        forwardindicationvoltage: parseFloat(pointmachine_data[15]).toFixed(alert_voldec_values),
                                        reverseindicationvoltage: parseFloat(pointmachine_data[16]).toFixed(alert_voldec_values),
                                        forwardvoltage: parseFloat(pointmachine_data[17]).toFixed(alert_voldec_values),
                                        reversevoltage: parseFloat(pointmachine_data[18]).toFixed(alert_voldec_values),
                                        forwardcurrentavg: parseFloat(pointmachine_data[19]).toFixed(alert_curdec_values),
                                        forwardcurrentpeak: parseFloat(pointmachine_data[20]).toFixed(alert_curdec_values),
                                        reversecurrentavg: parseFloat(pointmachine_data[21]).toFixed(alert_curdec_values),
                                        reversecurrentpeak: parseFloat(pointmachine_data[22]).toFixed(alert_curdec_values),
                                        vibrationx: parseFloat(pointmachine_data[23]).toFixed(alert_curdec_values),
                                        vibrationy: parseFloat(pointmachine_data[24]).toFixed(alert_curdec_values),
                                        vibrationz: parseFloat(pointmachine_data[25]).toFixed(alert_curdec_values),
                                        forwardtime: parseFloat(pointmachine_data[26]).toFixed(alert_timdec_values),
                                        reversetime: parseFloat(pointmachine_data[27]).toFixed(alert_timdec_values),
                                        log: parseInt(B1_log),
                                        createddate: current_datetime

                                    }
                                    //logs.info('PM_1B', B_point_data)

                                    let transaction = await db.transaction({ autocommit: false });
                                    try {

                                        const p1A_data_insert = await PointmachineAdata.create(
                                            A_point_data
                                            ,
                                            { transaction: transaction }
                                        )

                                        const p1B_data_insert = await PointmachineBdata.create(
                                            B_point_data
                                            ,
                                            { transaction: transaction }
                                        )
                                        await transaction.commit();

                                        logs.info("Point Machine 1C data inserted");
                                        //console.log("Point Machine 1C data inserted");                
                                        await insert_pointmachineC(A_point_data, B_point_data);
                                    }
                                    catch (ex) {
                                        await transaction.rollback();
                                        logs.error('mqtt error stationdata/PM_1C_inside ' + ex);
                                        //console.log('mqtt error stationdata/PM_1C_inside ' + ex);
                                    }
                                }
                            }
                        }
                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/PM_1C_outside ' + ex);
                        //console.log('mqtt error stationdata/PM_1C_outside ' + ex);
                    }
                }
            });
        });

        // Active - Track Circuit Feeder
        client.subscribe('stationdata/TS_1F', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/TS_1F') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/TS_1F', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/TS_1F', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var TS_1F_data = packet.payload.toString().split(',');
                        logs.info('stationdata/TS_1F', TS_1F_data)

                        var allzero = TS_1F_data.slice(1, 11).every(x => x === '0')

                        let trackcircuitid = parseInt(TS_1F_data[0]).toString(16).split("")[0];
                        let trackterminal = String.fromCharCode(parseInt((parseInt(TS_1F_data[0]).toString(16).split("")[1] + parseInt(TS_1F_data[0]).toString(16).split("")[2]), 16))

                        const register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                if (index !== -1) {
                                    trackcircuitAlive[index].value = moment()
                                    trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                    trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                }
                                else {
                                    trackcircuitAlive.push({
                                        key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await trackcircuit_compare_Feeder(TS_1F_data.slice(1, 11), trackcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let track_count = 1;
                                    const cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (cycle_index !== -1) {
                                        track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                        trackcircuitFeederdatas[cycle_index].value = track_count
                                    }
                                    else {
                                        if (trackcircuitWithoutArray === true) {
                                            var FeederDatas = [await TrackCircuitData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: trackcircuitid },
                                                raw: true
                                            })];
                                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                            if (FeederDatas.length > 0) {
                                                track_count = FeederDatas[0].feed_count + 1
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                            }
                                            else {
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                        else {
                                            var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: parseInt(trackcircuitid) },
                                                raw: true
                                            })];
                                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                            if (FeederDatas.length > 0) {
                                                track_count = FeederDatas[0].count + 1
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                            }
                                            else {
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                    }

                                    let track_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: asserts.id,
                                        assertname: asserts.assertname,
                                        trackcircuitid: parseInt(trackcircuitid),
                                        trackcircuitterminal: trackterminal,
                                        trackname: register_trackid.trackname,
                                        count: track_count,
                                        feed_voltage: parseFloat(TS_1F_data[1]).toFixed(alert_voldec_values),
                                        feed_current: parseFloat(TS_1F_data[2]).toFixed(alert_curdec_values),
                                        choke_voltage: parseFloat(TS_1F_data[3]).toFixed(alert_voldec_values),
                                        battery_charger_dc_current: parseFloat(TS_1F_data[4]).toFixed(alert_curdec_values),
                                        battery_charger_dc_voltage: parseFloat(TS_1F_data[5]).toFixed(alert_voldec_values),
                                        battery_charger_ac_voltage: parseFloat(TS_1F_data[6]).toFixed(alert_voldec_values),
                                        battery_charger_ac_current: parseFloat(TS_1F_data[7]).toFixed(alert_curdec_values),
                                        relay_voltage: parseFloat(TS_1F_data[8]).toFixed(alert_voldec_values),
                                        relay_current: parseFloat(TS_1F_data[9]).toFixed(alert_curdec_values),
                                        trv: parseFloat(TS_1F_data[10]).toFixed(alert_voldec_values),
                                        createddate: current_datetime
                                    }
                                    //logs.info('TS_1F', track_data)
                                    if (cycle_index != -1) {
                                        trackcircuitFeederdatas[cycle_index].data = track_data
                                    }
                                    else {
                                        trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                    }

                                    if (trackcircuitWithoutArray === true) {
                                        insert_feedertrack_array(track_data);
                                    }
                                    else {
                                        let transaction = await db.transaction({ autocommit: false });
                                        try {
                                            const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                track_data,
                                                { transaction: transaction },
                                                { returning: true }
                                            );
                                            await transaction.commit();
                                            insert_feedertrack_array(track_data);
                                            logs.info("Track feeder data inserted");
                                            //console.log("Track feeder data inserted");
                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/TS_1F ' + ex);
                                            //console.log('mqtt error stationdata/TS_1F ' + ex);
                                        }
                                    }
                                }
                            }
                        }

                        var allzero = TS_1F_data.slice(12, TS_1F_data.length).every(x => x === '0')

                        let signalcircuitid = parseInt(TS_1F_data[11]).toString(16).split("")[0];
                        let signalterminal = String.fromCharCode(parseInt((parseInt(TS_1F_data[11]).toString(16).split("")[1] + parseInt(TS_1F_data[11]).toString(16).split("")[2]), 16))

                        const register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                        if (register_signalid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                            const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_signalalive_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)

                                var index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });
                                if (index !== -1) {
                                    signalcircuitAlive[index].value = moment()
                                    signalcircuitAlive[index].alive_limit = moment().add(parseInt(alert_signalalive_values.value), 'seconds')
                                    signalcircuitAlive[index].message = await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit)
                                }
                                else {
                                    signalcircuitAlive.push({
                                        key: signalcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_signalalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit), mode: alert_signalalive_values.mode, id: alert_signalalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_signalid.signalname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SIGNAL_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await signalcircuit_compare(TS_1F_data.slice(12, TS_1F_data.length), signalcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let signal_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        signalcircuitid: parseInt(signalcircuitid),
                                        signalname: register_signalid.signalname,
                                        terminal: signalterminal,
                                        aspecttypeid: register_signalid.aspecttypeid,
                                        description: signalaspects.description,
                                        greenvoltage: parseFloat(TS_1F_data[12]).toFixed(alert_voldec_values),
                                        greencurrent: parseFloat(TS_1F_data[13]).toFixed(alert_curdec_values),
                                        redvoltage: parseFloat(TS_1F_data[14]).toFixed(alert_voldec_values),
                                        redcurrent: parseFloat(TS_1F_data[15]).toFixed(alert_curdec_values),
                                        yellowvoltage: parseFloat(TS_1F_data[16]).toFixed(alert_voldec_values),
                                        yellowcurrent: parseFloat(TS_1F_data[17]).toFixed(alert_curdec_values),
                                        lightyellowvoltage: parseFloat(TS_1F_data[18]).toFixed(alert_voldec_values),
                                        lightyellowcurrent: parseFloat(TS_1F_data[19]).toFixed(alert_curdec_values),
                                        createddate: current_datetime
                                    }

                                    await insert_signalcircuit(signal_data)

                                    //logs.info('TS_1F', signal_data)        
                                }

                            }
                        }

                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/TS_1F ' + ex);
                        //console.log('mqtt error stationdata/TS_1F ' + ex);
                    }
                }
            });
        });

        // Active - Track Circuit Relay & Signal
        client.subscribe('stationdata/TS_1R', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/TS_1R') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/TS_1R', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/TS_1R', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var TS_1R_data = packet.payload.toString().split(',');
                        logs.info('stationdata/TS_1R', TS_1R_data)

                        var allzero = TS_1R_data.slice(1, 11).every(x => x === '0')

                        let trackcircuitid = parseInt(TS_1R_data[0]).toString(16).split("")[0];
                        let trackterminal = String.fromCharCode(parseInt((parseInt(TS_1R_data[0]).toString(16).split("")[1] + parseInt(TS_1R_data[0]).toString(16).split("")[2]), 16))

                        const register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                if (index !== -1) {
                                    trackcircuitAlive[index].value = moment()
                                    trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                    trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                }
                                else {
                                    trackcircuitAlive.push({
                                        key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await trackcircuit_compare_Relay(TS_1R_data.slice(1, 11), trackcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let track_count = 1;
                                    const cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (cycle_index !== -1) {
                                        track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                        trackcircuitRelaydatas[cycle_index].value = track_count
                                    }
                                    else {
                                        if (trackcircuitWithoutArray === true) {
                                            var RelayDatas = [await TrackCircuitData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: trackcircuitid },
                                                raw: true
                                            })];
                                            RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                            if (RelayDatas.length > 0) {
                                                track_count = RelayDatas[0].count + 1
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                            }
                                            else {
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                        else {
                                            var RelayDatas = [await TrackCircuitRelayData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: parseInt(trackcircuitid) },
                                                raw: true
                                            })];
                                            RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                            if (RelayDatas.length > 0) {
                                                track_count = RelayDatas[0].count + 1
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                            }
                                            else {
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                    }

                                    let track_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        trackcircuitid: parseInt(trackcircuitid),
                                        trackcircuitterminal: trackterminal,
                                        trackname: register_trackid.trackname,
                                        count: track_count,
                                        feed_voltage: parseFloat(TS_1R_data[1]).toFixed(alert_voldec_values),
                                        feed_current: parseFloat(TS_1R_data[2]).toFixed(alert_curdec_values),
                                        choke_voltage: parseFloat(TS_1R_data[3]).toFixed(alert_voldec_values),
                                        battery_charger_dc_current: parseFloat(TS_1R_data[4]).toFixed(alert_curdec_values),
                                        battery_charger_dc_voltage: parseFloat(TS_1R_data[5]).toFixed(alert_voldec_values),
                                        battery_charger_ac_voltage: parseFloat(TS_1R_data[6]).toFixed(alert_voldec_values),
                                        battery_charger_ac_current: parseFloat(TS_1R_data[7]).toFixed(alert_curdec_values),
                                        relay_voltage: parseFloat(TS_1R_data[8]).toFixed(alert_voldec_values),
                                        relay_current: parseFloat(TS_1R_data[9]).toFixed(alert_curdec_values),
                                        trv: parseFloat(TS_1R_data[10]).toFixed(alert_voldec_values),
                                        createddate: current_datetime
                                    }
                                    //logs.info('TS_1R', track_data)
                                    if (cycle_index !== -1) {
                                        trackcircuitRelaydatas[cycle_index].data = track_data
                                    }
                                    else {
                                        trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                    }

                                    if (trackcircuitWithoutArray === true) {
                                        insert_relaytrack_array(track_data);
                                    }
                                    else {
                                        let transaction = await db.transaction({ autocommit: false });
                                        try {
                                            const tc_f_data_insert = await TrackCircuitRelayData.create(
                                                track_data,
                                                { transaction: transaction },
                                                { returning: true }
                                            );

                                            await transaction.commit();
                                            insert_relaytrack_array(track_data);
                                            logs.info("Track relay data inserted");
                                            //console.log("Track relay data inserted");
                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/TS_1R ' + ex);
                                            //console.log('mqtt error stationdata/TS_1R ' + ex);
                                        }
                                    }
                                }
                            }
                        }

                        var allzero = TS_1R_data.slice(12, TS_1R_data.length).every(x => x === '0')

                        let signalcircuitid = parseInt(TS_1R_data[11]).toString(16).split("")[0];
                        let signalterminal = String.fromCharCode(parseInt((parseInt(TS_1R_data[11]).toString(16).split("")[1] + parseInt(TS_1R_data[11]).toString(16).split("")[2]), 16))

                        const register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                        if (register_signalid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                            const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_signalalive_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)

                                var index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });
                                if (index !== -1) {
                                    signalcircuitAlive[index].value = moment()
                                    signalcircuitAlive[index].alive_limit = moment().add(parseInt(alert_signalalive_values.value), 'seconds')
                                    signalcircuitAlive[index].message = await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit)
                                }
                                else {
                                    signalcircuitAlive.push({
                                        key: signalcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_signalalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit), mode: alert_signalalive_values.mode, id: alert_signalalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_signalid.signalname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SIGNAL_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await signalcircuit_compare(TS_1R_data.slice(12, TS_1R_data.length), signalcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let signal_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        signalcircuitid: parseInt(signalcircuitid),
                                        signalname: register_signalid.signalname,
                                        terminal: signalterminal,
                                        aspecttypeid: register_signalid.aspecttypeid,
                                        description: signalaspects.description,
                                        greenvoltage: parseFloat(TS_1R_data[12]).toFixed(alert_voldec_values),
                                        greencurrent: parseFloat(TS_1R_data[13]).toFixed(alert_curdec_values),
                                        redvoltage: parseFloat(TS_1R_data[14]).toFixed(alert_voldec_values),
                                        redcurrent: parseFloat(TS_1R_data[15]).toFixed(alert_curdec_values),
                                        yellowvoltage: parseFloat(TS_1R_data[16]).toFixed(alert_voldec_values),
                                        yellowcurrent: parseFloat(TS_1R_data[17]).toFixed(alert_curdec_values),
                                        lightyellowvoltage: parseFloat(TS_1R_data[18]).toFixed(alert_voldec_values),
                                        lightyellowcurrent: parseFloat(TS_1R_data[19]).toFixed(alert_curdec_values),
                                        createddate: current_datetime
                                    }
                                    await insert_signalcircuit(signal_data)

                                    //logs.info('TS_1R', signal_data)    
                                }
                            }
                        }
                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/TS_1R ' + ex);
                        //console.log('mqtt error stationdata/TS_1R ' + ex);
                    }
                }
            });
        });

        // Active - Track Circuit Feeder
        client.subscribe('stationdata/TS_2F', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/TS_2F') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/TS_2F', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/TS_2F', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var TS_1F_data = packet.payload.toString().split(',');
                        logs.info('stationdata/TS_2F', TS_1F_data)

                        var allzero = TS_1F_data.slice(1, 11).every(x => x === '0')

                        let trackcircuitid = parseInt(TS_1F_data[0]).toString(16).split("")[0];
                        let trackterminal = String.fromCharCode(parseInt((parseInt(TS_1F_data[0]).toString(16).split("")[1] + parseInt(TS_1F_data[0]).toString(16).split("")[2]), 16))

                        const register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                if (index !== -1) {
                                    trackcircuitAlive[index].value = moment()
                                    trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                    trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                }
                                else {
                                    trackcircuitAlive.push({
                                        key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await trackcircuit_compare_Feeder(TS_1F_data.slice(1, 11), trackcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let track_count = 1;
                                    const cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (cycle_index !== -1) {
                                        track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                        trackcircuitFeederdatas[cycle_index].value = track_count
                                    }
                                    else {
                                        if (trackcircuitWithoutArray === true) {
                                            var FeederDatas = [await TrackCircuitData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: trackcircuitid },
                                                raw: true
                                            })];
                                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                            if (FeederDatas.length > 0) {
                                                track_count = FeederDatas[0].feed_count + 1
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                            }
                                            else {
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                        else {
                                            var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: parseInt(trackcircuitid) },
                                                raw: true
                                            })];
                                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                            if (FeederDatas.length > 0) {
                                                track_count = FeederDatas[0].count + 1
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                            }
                                            else {
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                    }

                                    let track_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: asserts.id,
                                        assertname: asserts.assertname,
                                        trackcircuitid: parseInt(trackcircuitid),
                                        trackcircuitterminal: trackterminal,
                                        trackname: register_trackid.trackname,
                                        count: track_count,
                                        feed_voltage: parseFloat(TS_1F_data[1]).toFixed(alert_voldec_values),
                                        feed_current: parseFloat(TS_1F_data[2]).toFixed(alert_curdec_values),
                                        choke_voltage: parseFloat(TS_1F_data[3]).toFixed(alert_voldec_values),
                                        battery_charger_dc_current: parseFloat(TS_1F_data[4]).toFixed(alert_curdec_values),
                                        battery_charger_dc_voltage: parseFloat(TS_1F_data[5]).toFixed(alert_voldec_values),
                                        battery_charger_ac_voltage: parseFloat(TS_1F_data[6]).toFixed(alert_voldec_values),
                                        battery_charger_ac_current: parseFloat(TS_1F_data[7]).toFixed(alert_curdec_values),
                                        relay_voltage: parseFloat(TS_1F_data[8]).toFixed(alert_voldec_values),
                                        relay_current: parseFloat(TS_1F_data[9]).toFixed(alert_curdec_values),
                                        trv: parseFloat(TS_1F_data[10]).toFixed(alert_voldec_values),
                                        createddate: current_datetime
                                    }
                                    //logs.info('TS_1F', track_data)
                                    if (cycle_index != -1) {
                                        trackcircuitFeederdatas[cycle_index].data = track_data
                                    }
                                    else {
                                        trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                    }

                                    if (trackcircuitWithoutArray === true) {
                                        insert_feedertrack_array(track_data);
                                    }
                                    else {
                                        let transaction = await db.transaction({ autocommit: false });
                                        try {
                                            const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                track_data,
                                                { transaction: transaction },
                                                { returning: true }
                                            );
                                            await transaction.commit();
                                            insert_feedertrack_array(track_data);
                                            logs.info("Track feeder data inserted");
                                            //console.log("Track feeder data inserted");
                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/TS_1F ' + ex);
                                            //console.log('mqtt error stationdata/TS_1F ' + ex);
                                        }
                                    }
                                }
                            }
                        }

                        var allzero = TS_1F_data.slice(12, TS_1F_data.length).every(x => x === '0')

                        let signalcircuitid = parseInt(TS_1F_data[11]).toString(16).split("")[0];
                        let signalterminal = String.fromCharCode(parseInt((parseInt(TS_1F_data[11]).toString(16).split("")[1] + parseInt(TS_1F_data[11]).toString(16).split("")[2]), 16))

                        const register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                        if (register_signalid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                            const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_signalalive_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)

                                var index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });
                                if (index !== -1) {
                                    signalcircuitAlive[index].value = moment()
                                    signalcircuitAlive[index].alive_limit = moment().add(parseInt(alert_signalalive_values.value), 'seconds')
                                    signalcircuitAlive[index].message = await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit)
                                }
                                else {
                                    signalcircuitAlive.push({
                                        key: signalcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_signalalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit), mode: alert_signalalive_values.mode, id: alert_signalalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_signalid.signalname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SIGNAL_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await signalcircuit_compare(TS_1F_data.slice(12, TS_1F_data.length), signalcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let signal_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        signalcircuitid: parseInt(signalcircuitid),
                                        signalname: register_signalid.signalname,
                                        terminal: signalterminal,
                                        aspecttypeid: register_signalid.aspecttypeid,
                                        description: signalaspects.description,
                                        greenvoltage: parseFloat(TS_1F_data[12]).toFixed(alert_voldec_values),
                                        greencurrent: parseFloat(TS_1F_data[13]).toFixed(alert_curdec_values),
                                        redvoltage: parseFloat(TS_1F_data[14]).toFixed(alert_voldec_values),
                                        redcurrent: parseFloat(TS_1F_data[15]).toFixed(alert_curdec_values),
                                        yellowvoltage: parseFloat(TS_1F_data[16]).toFixed(alert_voldec_values),
                                        yellowcurrent: parseFloat(TS_1F_data[17]).toFixed(alert_curdec_values),
                                        lightyellowvoltage: parseFloat(TS_1F_data[18]).toFixed(alert_voldec_values),
                                        lightyellowcurrent: parseFloat(TS_1F_data[19]).toFixed(alert_curdec_values),
                                        createddate: current_datetime
                                    }

                                    await insert_signalcircuit(signal_data)

                                    //logs.info('TS_1F', signal_data)        
                                }

                            }
                        }

                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/TS_2F ' + ex);
                        //console.log('mqtt error stationdata/TS_2F ' + ex);
                    }
                }
            });
        });


        // Active- Relay
        client.subscribe('stationdata/iocard', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/iocard') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/iocard', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/iocard', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var C1_data = packet.payload.toString().split(',');
                        logs.info('stationdata/iocard', C1_data)

                        //Relay
                        var allzero = C1_data.slice(1, C1_data.length).every(x => x === '0')

                        var stationid = parseInt(parseInt(C1_data[0]).toString(16).split("")[0], 16);
                        var terminal = String.fromCharCode(parseInt((parseInt(C1_data[0]).toString(16).split("")[1] + parseInt(C1_data[0]).toString(16).split("")[2]), 16))
                        var get_relay_details = await RegisteredRelay.findAll({
                            attributes: [['id', 'relayid'], 'relayname', 'stationid', 'assertsid', 'assertid', 'wordlocation', 'bitlocation'],
                            where: { stationid: stationid, isdele: false },
                            order: [['wordlocation'], ['bitlocation']],
                            raw: true
                        })

                        if (relaydatas.findIndex(obj => { return obj.stationid == stationid }) == -1) {
                            RegisteredRelay.hasMany(RelayData, { foreignKey: 'relayid' });
                            RelayData.belongsTo(RegisteredRelay, { foreignKey: 'relayid' });

                            var datas =
                                await RelayData.findAll({
                                    attributes: [
                                        [Sequelize.col('RegisteredRelay.id'), 'id'],
                                        [Sequelize.col('RegisteredRelay.relayname'), 'relayname'],
                                        [Sequelize.col('RegisteredRelay.assertsid'), 'assertsid'],
                                        [Sequelize.col('RegisteredRelay.assertid'), 'assertid'],
                                        [Sequelize.col('RegisteredRelay.stationid'), 'stationid'],
                                        ['id', 'relaydataid'],
                                        'value',
                                        'createddate',
                                        'isdele',
                                    ],
                                    include: [
                                        {
                                            model: RegisteredRelay,
                                            attributes: [],
                                            where: {
                                                isdele: false,
                                                stationid: stationid,
                                            },
                                        },
                                    ],
                                    where: {
                                        isdele: false,
                                        id: {
                                            [Op.in]: (await RelayData.findAll({
                                                attributes: [
                                                    [Sequelize.fn('max', Sequelize.col('RelayData.id')), 'id'],
                                                ],
                                                group: ['RegisteredRelay.id'],
                                                include: [
                                                    {
                                                        model: RegisteredRelay,
                                                        attributes: [],
                                                        where: {
                                                            isdele: false,
                                                            stationid: stationid
                                                        },
                                                    },
                                                ],
                                                where: {
                                                    isdele: false,
                                                },
                                                raw: true,
                                            })).map(data => data.id)
                                        },
                                    },
                                    order: [
                                        [Sequelize.col('RegisteredRelay.assertsid'), 'ASC'],
                                        ['value', 'DESC'],
                                        [Sequelize.col('RegisteredRelay.relayname'), 'ASC'],
                                    ],
                                    group: [
                                        'RelayData.id',
                                        'RegisteredRelay.id',
                                        'RegisteredRelay.relayname',
                                    ],
                                    raw: true,
                                });

                            const removeDuplicates = (array) => {
                                const idCount = new Map();
                                const indexes = [];

                                array.forEach((item, index) => {
                                    const { id } = item;
                                    if (idCount.has(id)) {
                                        indexes.push(index);
                                    } else {
                                        idCount.set(id, true);
                                    }
                                });

                                indexes.reverse().forEach(index => {
                                    array.splice(index, 1);
                                });

                                return array;
                            }

                            relaydatas = relaydatas.concat(removeDuplicates(datas));
                        }

                        var relay_data = [];
                        if (get_relay_details.length > 0 && allzero == false) {
                            var decimal_datas = C1_data.slice(1, C1_data.length)
                            for (var i = 0; i < decimal_datas.length; i++) {
                                const binaryString = parseInt(decimal_datas[i]).toString(2).padStart(16, '0').match(/.{1,8}/g);
                                var byte_binarystring1 = binaryString[0].split('').reverse()
                                for (var j = 0; j < byte_binarystring1.length; j++) {
                                    var index = get_relay_details.findIndex(obj => { return obj.wordlocation === parseInt(i == 0 ? i : i * 2) && obj.bitlocation === parseInt(j) })
                                    if (index != -1) {
                                        var dataindex = relaydatas.findIndex(obj => { return obj.id === parseInt(get_relay_details[index].relayid) })
                                        if (dataindex != -1 && relaydatas[dataindex].value != parseInt(byte_binarystring1[j])) {
                                            var relayindex = relay_data.findIndex(obj => { return obj.id === parseInt(get_relay_details[index].relayid) })
                                            if (relayindex != -1) {
                                                relay_data[relayindex].relayid = get_relay_details[index].relayid,
                                                    relay_data[relayindex].relayname = get_relay_details[index].relayname,
                                                    relay_data[relayindex].stationid = get_relay_details[index].stationid,
                                                    relay_data[relayindex].assertsid = get_relay_details[index].assertsid,
                                                    relay_data[relayindex].assertid = get_relay_details[index].assertid,
                                                    relay_data[relayindex].wordlocation = get_relay_details[index].wordlocation,
                                                    relay_data[relayindex].bitlocation = get_relay_details[index].bitlocation,
                                                    relay_data[relayindex].value = parseInt(byte_binarystring1[j]);
                                                    relay_data[relayindex].createddate = current_datetime
                                            }
                                            else {
                                                relay_data.push({
                                                    relayid: get_relay_details[index].relayid,
                                                    relayname: get_relay_details[index].relayname,
                                                    stationid: get_relay_details[index].stationid,
                                                    assertsid: get_relay_details[index].assertsid,
                                                    assertid: get_relay_details[index].assertid,
                                                    wordlocation: get_relay_details[index].wordlocation,
                                                    bitlocation: get_relay_details[index].bitlocation,
                                                    value: parseInt(byte_binarystring1[j]),
                                                    createddate: current_datetime,
                                                })
                                            }
                                            relaydatas[dataindex].value = parseInt(byte_binarystring1[j])

                                        }
                                        else if (dataindex == -1) {
                                            relay_data.push({
                                                relayid: get_relay_details[index].relayid,
                                                relayname: get_relay_details[index].relayname,
                                                stationid: get_relay_details[index].stationid,
                                                assertsid: get_relay_details[index].assertsid,
                                                assertid: get_relay_details[index].assertid,
                                                wordlocation: get_relay_details[index].wordlocation,
                                                bitlocation: get_relay_details[index].bitlocation,
                                                value: parseInt(byte_binarystring1[j]),
                                                createddate: current_datetime,
                                            })
                                            relaydatas.push({
                                                id: get_relay_details[index].relayid,
                                                relayname: get_relay_details[index].relayname,
                                                stationid: get_relay_details[index].stationid,
                                                assertsid: get_relay_details[index].assertsid,
                                                assertid: get_relay_details[index].assertid,
                                                wordlocation: get_relay_details[index].wordlocation,
                                                bitlocation: get_relay_details[index].bitlocation,
                                                value: parseInt(byte_binarystring1[j]),
                                                createddate: current_datetime,
                                            })
                                        }
                                    }
                                }

                                var byte_binarystring2 = binaryString[1].split('').reverse()
                                for (var j = 0; j < byte_binarystring2.length; j++) {
                                    var index = get_relay_details.findIndex(obj => { return obj.wordlocation === parseInt((i * 2 + 1)) && obj.bitlocation === parseInt(j) })
                                    if (index != -1) {
                                        var dataindex = relaydatas.findIndex(obj => { return obj.id === parseInt(get_relay_details[index].relayid) })
                                        if (dataindex != -1 && relaydatas[dataindex].value != parseInt(byte_binarystring2[j])) {
                                            var relayindex = relay_data.findIndex(obj => { return obj.id === parseInt(get_relay_details[index].relayid) })
                                            if (relayindex != -1) {
                                                relay_data[relayindex].relayid = get_relay_details[index].relayid,
                                                    relay_data[relayindex].relayname = get_relay_details[index].relayname,
                                                    relay_data[relayindex].stationid = get_relay_details[index].stationid,
                                                    relay_data[relayindex].assertsid = get_relay_details[index].assertsid,
                                                    relay_data[relayindex].assertid = get_relay_details[index].assertid,
                                                    relay_data[relayindex].wordlocation = get_relay_details[index].wordlocation,
                                                    relay_data[relayindex].bitlocation = get_relay_details[index].bitlocation,
                                                    relay_data[relayindex].value = parseInt(byte_binarystring2[j]);
                                                relay_data[relayindex].createddate = current_datetime
                                            }
                                            else {
                                                relay_data.push({
                                                    relayid: get_relay_details[index].relayid,
                                                    relayname: get_relay_details[index].relayname,
                                                    stationid: get_relay_details[index].stationid,
                                                    assertsid: get_relay_details[index].assertsid,
                                                    assertid: get_relay_details[index].assertid,
                                                    wordlocation: get_relay_details[index].wordlocation,
                                                    bitlocation: get_relay_details[index].bitlocation,
                                                    value: parseInt(byte_binarystring2[j]),
                                                    createddate: current_datetime,
                                                })
                                            }
                                            relaydatas[dataindex].value = parseInt(byte_binarystring2[j])

                                        }
                                        else if (dataindex == -1) {
                                            relay_data.push({
                                                relayid: get_relay_details[index].relayid,
                                                relayname: get_relay_details[index].relayname,
                                                stationid: get_relay_details[index].stationid,
                                                assertsid: get_relay_details[index].assertsid,
                                                assertid: get_relay_details[index].assertid,
                                                wordlocation: get_relay_details[index].wordlocation,
                                                bitlocation: get_relay_details[index].bitlocation,
                                                value: parseInt(byte_binarystring2[j]),
                                                createddate: current_datetime,
                                            })
                                            relaydatas.push({
                                                id: get_relay_details[index].relayid,
                                                relayname: get_relay_details[index].relayname,
                                                stationid: get_relay_details[index].stationid,
                                                assertsid: get_relay_details[index].assertsid,
                                                assertid: get_relay_details[index].assertid,
                                                wordlocation: get_relay_details[index].wordlocation,
                                                bitlocation: get_relay_details[index].bitlocation,
                                                value: parseInt(byte_binarystring2[j]),
                                                createddate: current_datetime,
                                            })
                                        }
                                    }
                                }
                            }
                            if (relay_data.length > 0) {
                                let transaction = await db.transaction({ autocommit: false });
                                try {
                                    await RelayData.bulkCreate(relay_data, { transaction: transaction })
                                    await transaction.commit();
                                    logs.info("Relay Data inserted");

                                    let alert_data = {}
                                    let alert_logs = []
                                    let alert_modeid = 0

                                    let socket_data = {
                                        data_logs: JSON.stringify(relay_data),
                                        alertmodeid: alert_logs.length > 0 ? alert_modeid : null,
                                        alerts: alert_logs
                                    }
                                    //logs.info('lcgatedata',socket_data )
                                    Socket.emit("relaydata", socket_data)
                                    //socketcloud.emit("LCGates", socket_data)
                                }
                                catch (ex) {
                                    await transaction.rollback();
                                    logs.error('mqtt error stationdata/iocard ' + ex);
                                    //console.log('mqtt error stationdata/iocard ' + ex);
                                }
                            }
                        }
                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/iocard ' + ex);
                        //console.log('mqtt error stationdata/iocard ' + ex);
                    }
                }
            });
        });

        // Active- Ips
        client.subscribe('stationdata/IPS', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/IPS') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/IPS', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/IPS', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var ipsdata = packet.payload.toString().split(',');
                        logs.info('stationdata/IPS', ipsdata)

                        var allzero = ipsdata.slice(1, ipsdata.length).every(x => x === '0')

                        var ipsid = parseInt(parseInt(ipsdata[0]).toString(16).split("")[0], 16).toString();
                        var ipsterminal1 = String.fromCharCode(parseInt((parseInt(ipsdata[0]).toString(16).split("")[1] + parseInt(ipsdata[0]).toString(16).split("")[2]), 16))
                        var ipsid2 = parseInt(parseInt(ipsdata[31]).toString(16).split("")[0], 16).toString();
                        var ipsterminal2 = String.fromCharCode(parseInt((parseInt(ipsdata[31]).toString(16).split("")[1] + parseInt(ipsdata[31]).toString(16).split("")[2]), 16))
                        var ipsterminal = ipsterminal1 + ipsterminal2

                        var register_ipsid = await RegisteredIPS.findOne({ attributes: [['id', 'ipsid'], 'stationid', 'ipsname'], where: { id: ipsid, isdele: false }, raw: true })
                        if (register_ipsid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_ipsid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "IPS" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_ipsalive_values = await get_alerts(`${station_id}@${ipsid}@${asserts.assertname}@SET_IPS_ALIVE`)

                                var index = ipsAlive.findIndex(obj => { return obj.key === ipsid; });
                                if (index !== -1) {
                                    ipsAlive[index].value = moment()
                                    ipsAlive[index].alive_limit = moment().add(parseInt(alert_ipsalive_values.value), 'seconds')
                                    ipsAlive[index].message = await combine_mes_val_unit(alert_ipsalive_values.message, alert_ipsalive_values.value, alert_ipsalive_values.unit)
                                }
                                else {
                                    ipsAlive.push({
                                        key: ipsid, value: moment(), alive_limit: moment().add(parseInt(alert_ipsalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_ipsalive_values.message, alert_ipsalive_values.value, alert_ipsalive_values.unit), mode: alert_ipsalive_values.mode, id: alert_ipsalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_ipsid.ipsname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${ipsid}@${asserts.assertname}@IPS_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await ips_compare(ipsdata.slice(1, ipsdata.length), ipsid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result == true) {
                                 
                                    let ips_data = {
                                        ipsid: register_ipsid.ipsid,
                                        ips_terminal: ipsterminal,
                                        track_voltage_cbf: parseFloat(ipsdata[1]).toFixed(alert_voldec_values),
                                        track_voltage_mtp: parseFloat(ipsdata[2]).toFixed(alert_voldec_values),
                                        signal_voltage_cbf: parseFloat(ipsdata[3]).toFixed(alert_voldec_values),
                                        signal_voltage_mtp: parseFloat(ipsdata[4]).toFixed(alert_voldec_values),
                                        b110_vdc: parseFloat(ipsdata[5]).toFixed(alert_voldec_values),
                                        ext_relay_voltage_cbf: parseFloat(ipsdata[6]).toFixed(alert_voldec_values),
                                        ext_relay_voltage_mtp: parseFloat(ipsdata[7]).toFixed(alert_voldec_values),
                                        block_voltage_cbf: parseFloat(ipsdata[8]).toFixed(alert_voldec_values),
                                        block_voltage_mtp: parseFloat(ipsdata[9]).toFixed(alert_voldec_values),
                                        block_line_bat_voltage_cbf: parseFloat(ipsdata[10]).toFixed(alert_voldec_values),
                                        block_line_bat_voltage_mtp: parseFloat(ipsdata[11]).toFixed(alert_voldec_values),
                                        axle_counter_voltage_cbf: parseFloat(ipsdata[12]).toFixed(alert_voldec_values),
                                        axle_counter_voltage_mtp: parseFloat(ipsdata[13]).toFixed(alert_voldec_values),
                                        lvr_vdc: parseFloat(ipsdata[14]).toFixed(alert_voldec_values),
                                        axle_counter_voltage_cbf_1: parseFloat(ipsdata[15]).toFixed(alert_curdec_values),
                                        track_current_cbf: parseFloat(ipsdata[16]).toFixed(alert_curdec_values),
                                        track_current_mtp: parseFloat(ipsdata[17]).toFixed(alert_curdec_values),
                                        signal_current_cbf: parseFloat(ipsdata[18]).toFixed(alert_curdec_values),
                                        signal_current_mtp: parseFloat(ipsdata[19]).toFixed(alert_curdec_values),
                                        b110_idc: parseFloat(ipsdata[20]).toFixed(alert_voldec_values),
                                        ext_relay_current_cbf: parseFloat(ipsdata[21]).toFixed(alert_curdec_values),
                                        ext_relay_current_mtp: parseFloat(ipsdata[22]).toFixed(alert_curdec_values),
                                        block_current_cbf: parseFloat(ipsdata[23]).toFixed(alert_curdec_values),
                                        block_current_mtp: parseFloat(ipsdata[24]).toFixed(alert_curdec_values),
                                        block_line_bat_current_cbf: parseFloat(ipsdata[25]).toFixed(alert_curdec_values),
                                        block_line_bat_current_mtp: parseFloat(ipsdata[26]).toFixed(alert_curdec_values),
                                        axle_counter_current_cbf: parseFloat(ipsdata[27]).toFixed(alert_curdec_values),
                                        axle_counter_current_mtp: parseFloat(ipsdata[28]).toFixed(alert_curdec_values),
                                        lvr_idc: parseFloat(ipsdata[29]).toFixed(alert_curdec_values),
                                        axle_counter_current_cbf_1: parseFloat(ipsdata[30]).toFixed(alert_curdec_values),
                                        internal_relay_signal_voltage_cbf_oc: parseFloat(ipsdata[32]).toFixed(alert_voldec_values),
                                        internal_relay_signal_voltage_cbf_ic: parseFloat(ipsdata[33]).toFixed(alert_voldec_values),
                                        internal_relay_signal_voltage_mtp_oc: parseFloat(ipsdata[34]).toFixed(alert_voldec_values),
                                        internal_relay_signal_voltage_mtp_ic: parseFloat(ipsdata[35]).toFixed(alert_voldec_values),
                                        point_machine_voltage_ic: parseFloat(ipsdata[36]).toFixed(alert_voldec_values),
                                        point_machine_voltage_cbf_oc: parseFloat(ipsdata[37]).toFixed(alert_voldec_values),                                     
                                        point_machine_voltage_mtp_oc: parseFloat(ipsdata[38]).toFixed(alert_voldec_values),                                      
                                        internal_relay_signal_current_cbf_oc: parseFloat(ipsdata[39]).toFixed(alert_curdec_values),
                                        internal_relay_signal_current_cbf_ic: parseFloat(ipsdata[40]).toFixed(alert_curdec_values),
                                        internal_relay_signal_current_mtp_ic: parseFloat(ipsdata[41]).toFixed(alert_curdec_values),
                                        internal_relay_signal_current_mtp_oc: parseFloat(ipsdata[42]).toFixed(alert_curdec_values),
                                        point_machine_current_ic: parseFloat(ipsdata[43]).toFixed(alert_curdec_values),
                                        point_machine_current_cbf_oc: parseFloat(ipsdata[44]).toFixed(alert_curdec_values),
                                        point_machine_current_mtp_oc: parseFloat(ipsdata[45]).toFixed(alert_curdec_values),
                                        local_main_power_voltage_ic: parseFloat(ipsdata[46]).toFixed(alert_voldec_values),
                                        local_main_power_voltage_oc: parseFloat(ipsdata[47]).toFixed(alert_voldec_values),
                                        load_current_ic: parseFloat(ipsdata[48]).toFixed(alert_curdec_values),
                                        load_current_oc: parseFloat(ipsdata[49]).toFixed(alert_curdec_values),                                                                              
                                        createddate: current_datetime
                                    }

                                    let transaction = await db.transaction({ autocommit: false });
                                    try {
                                        await IPSData.create(ips_data, { transaction: transaction })
                                        await transaction.commit();
                                        logs.info("IPS Data inserted");

                                        let alert_data = {}
                                        let alert_logs = []
                                        let alert_modeid = 0

                                        let socket_data = {
                                            data_logs: ips_data,
                                            alertmodeid: alert_logs.length > 0 ? alert_modeid : null,
                                            alerts: alert_logs
                                        }
                                        //logs.info('ipsdata',socket_data )
                                        Socket.emit("ipsdata", socket_data)
                                        //socketcloud.emit("IPS", socket_data)
                                    }
                                    catch (ex) {
                                        await transaction.rollback();
                                        logs.error('mqtt error stationdata/IPS ' + ex);
                                        //console.log('mqtt error stationdata/IPS ' + ex);
                                    }
                                }
                            }
                        }
                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/IPS ' + ex);
                        //console.log('mqtt error stationdata/IPS ' + ex);
                    }
                }
            });
        });

        // Active - Axle Counter
        client.subscribe('stationdata/axlecounter', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/axlecounter') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/axlecounter', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/axlecounter', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var C1_data = packet.payload.toString().split(',');
                        logs.info('stationdata/axlecounter', C1_data)

                        let axlecounterid = parseInt(C1_data[0])
                        var get_axlecounter_details = await RegisteredAxleCounter.findAll({
                            attributes: [['id', 'axlecounterid']],
                            where: { id: axlecounterid, isdele: false },
                            raw: true
                        })

                        if (get_axlecounter_details.length > 0) {

                            let axlecounter_data = {
                                axlecounterid: get_axlecounter_details[0].axlecounterid,
                                vpr1: C1_data[1],
                                vpr2: C1_data[2],
                                ppr1: C1_data[3],
                                reset: C1_data[4],
                                dcconverter1: C1_data[5],
                                dcconverter2: C1_data[6],
                                createddate: current_datetime
                            }

                            let transaction = await db.transaction({ autocommit: false });
                            try {
                                await AxleCounterData.create(axlecounter_data, { transaction: transaction })
                                await transaction.commit();
                                logs.info("Axle Counter Data inserted");
                            }
                            catch (ex) {
                                await transaction.rollback();
                                logs.error('mqtt error stationdata/axlecounter ' + ex);
                                //console.log('mqtt error stationdata/axlecounter ' + ex);
                            }
                        }
                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/axlecounter ' + ex);
                        //console.log('mqtt error stationdata/axlecounter ' + ex);
                    }
                }
            });
        });

        // Active - LCGate
        client.subscribe('stationdata/lcgate', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/lcgate') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/lcgate', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/lcgate', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var C1_data = packet.payload.toString().split(',');
                        logs.info('stationdata/lcgate', C1_data)

                        let lcgateid = parseInt(C1_data[0])
                        var get_lcgate_details = await RegisteredLCGate.findAll({
                            attributes: [['id', 'lcgateid']],
                            where: { id: lcgateid, isdele: false },
                            raw: true
                        })

                        if (get_lcgate_details.length > 0) {

                            let lcgate_data = {
                                lcgateid: get_lcgate_details[0].lcgateid,
                                lcpr: C1_data[1],
                                lcar: C1_data[2],
                                createddate: current_datetime
                            }

                            let transaction = await db.transaction({ autocommit: false });
                            try {
                                await LCGateData.create(lcgate_data, { transaction: transaction })
                                await transaction.commit();
                                logs.info("LC Gate Data inserted");
                            }
                            catch (ex) {
                                await transaction.rollback();
                                logs.error('mqtt error stationdata/lcgate ' + ex);
                                //console.log('mqtt error stationdata/lcgate ' + ex);
                            }
                        }
                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/lcgate ' + ex);
                        //console.log('mqtt error stationdata/lcgate ' + ex);
                    }
                }
            });
        });

        // Active - EI/Battery
        client.subscribe('stationdata/EI_Battery', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/EI_Battery') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/EI_Battery', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/EI_Battery', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var ei_batery_data = packet.payload.toString().split(',');
                        logs.info('stationdata/EI_Battery', ei_batery_data)

                        var allzero = ei_batery_data.slice(1, ei_batery_data.length).every(x => x === '0')

                        let eibatteryid = parseInt(parseInt(ei_batery_data[0]).toString(16).split("")[0], 16).toString();

                        var register_batteryid = await RegisteredBattery.findOne({ attributes: [['id', 'batteryid'], 'type', 'stationid', 'batteryname'], where: { id: eibatteryid, isdele: false, type: 'EI' }, raw: true })
                        if (register_batteryid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_batteryid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Battery" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_eibatteryalive_values = await get_alerts(`${station_id}@${eibatteryid}@${asserts.assertname}@SET_BATTERY_ALIVE`)

                                var index = eibatteryAlive.findIndex(obj => { return obj.key === eibatteryid; });
                                if (index !== -1) {
                                    eibatteryAlive[index].value = moment()
                                    eibatteryAlive[index].alive_limit = moment().add(parseInt(alert_eibatteryalive_values.value), 'seconds')
                                    eibatteryAlive[index].message = await combine_mes_val_unit(alert_eibatteryalive_values.message, alert_eibatteryalive_values.value, alert_eibatteryalive_values.unit)
                                }
                                else {
                                    eibatteryAlive.push({
                                        key: eibatteryid, value: moment(), alive_limit: moment().add(parseInt(alert_eibatteryalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_eibatteryalive_values.message, alert_eibatteryalive_values.value, alert_eibatteryalive_values.unit), mode: alert_eibatteryalive_values.mode, id: alert_eibatteryalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_batteryid.batteryname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${eibatteryid}@${asserts.assertname}@BATTERY_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await eibattery_compare(ei_batery_data.slice(1, ei_batery_data.length), eibatteryid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result == true) {
                                    var battery_json = {}
                                    var battery_cells = ei_batery_data.slice(1, 56)
                                    for (let i = 0; i < battery_cells.length; i++) {
                                        battery_json[i + 1] = battery_cells[i]
                                    }

                                    var spare_json = {}
                                    var spare_cells = ei_batery_data.slice(57, 62)
                                    for (let i = 0; i < spare_cells.length; i++) {
                                        spare_json[i + 1] = spare_cells[i]
                                    }
                                    register_batteryid.battery_cells = battery_json
                                    register_batteryid.spare_cells = spare_json
                                    register_batteryid.charging_current = Math.sign(parseFloat(ei_batery_data[56]).toFixed(alert_curdec_values)) == 1 ? parseFloat(ei_batery_data[56]).toFixed(alert_curdec_values) : 0
                                    register_batteryid.discharging_current = Math.sign(parseFloat(ei_batery_data[56]).toFixed(alert_curdec_values)) == -1 ? parseFloat(ei_batery_data[56]).toFixed(alert_curdec_values) : 0
                                    register_batteryid.bank_voltage = (battery_cells.map(i => parseFloat(i))).reduce((a, b) => a + b).toFixed(alert_voldec_values)
                                    register_batteryid.spare_charging_current = Math.sign(parseFloat(ei_batery_data[62]).toFixed(alert_curdec_values)) == 1 ? parseFloat(ei_batery_data[62]).toFixed(alert_curdec_values) : 0
                                    register_batteryid.spare_discharging_current = Math.sign(parseFloat(ei_batery_data[62]).toFixed(alert_curdec_values)) == -1 ? parseFloat(ei_batery_data[62]).toFixed(alert_curdec_values) : 0
                                    register_batteryid.spare_bank_voltage = (spare_cells.map(i => parseFloat(i))).reduce((a, b) => a + b).toFixed(alert_voldec_values)
                                    register_batteryid.createddate = current_datetime

                                    let transaction = await db.transaction({ autocommit: false });
                                    try {
                                        await BatteryData.create(register_batteryid, { transaction: transaction })
                                        await transaction.commit();
                                        logs.info("Battery Data inserted");

                                        let alert_data = {}
                                        let alert_logs = []
                                        let alert_modeid = 0

                                        let socket_data = {
                                            data_logs: register_batteryid,
                                            alertmodeid: alert_logs.length > 0 ? alert_modeid : null,
                                            alerts: alert_logs
                                        }
                                        //logs.info('batterydata',socket_data )
                                        Socket.emit("batterydata", socket_data)
                                        //socketcloud.emit("Batteries", socket_data)
                                    }
                                    catch (ex) {
                                        await transaction.rollback();
                                        logs.error('mqtt error stationdata/EI_Battery ' + ex);
                                        //console.log('mqtt error stationdata/EI_Battery ' + ex);
                                    }
                                }
                            }
                        }
                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/EI_Battery ' + ex);
                        //console.log('mqtt error stationdata/EI_Battery ' + ex);
                    }
                }
            });
        });

        // Active - IPS/Battery
        client.subscribe('stationdata/IPS_Battery', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/IPS_Battery') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/IPS_Battery', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/IPS_Battery', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var ips_batery_data = packet.payload.toString().split(',');
                        logs.info('stationdata/IPS_Battery', ips_batery_data)

                        var allzero = ips_batery_data.slice(1, ips_batery_data.length).every(x => x === '0')

                        let ipsbatteryid = parseInt(parseInt(ips_batery_data[0]).toString(16).split("")[0], 16).toString();

                        var register_batteryid = await RegisteredBattery.findOne({ attributes: [['id', 'batteryid'], 'type', 'stationid', 'batteryname'], where: { id: ipsbatteryid, isdele: false, type: 'IPS' }, raw: true })
                        if (register_batteryid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_batteryid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Battery" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_ipsbatteryalive_values = await get_alerts(`${station_id}@${ipsbatteryid}@${asserts.assertname}@SET_BATTERY_ALIVE`)

                                var index = ipsbatteryAlive.findIndex(obj => { return obj.key === ipsbatteryid; });
                                if (index !== -1) {
                                    ipsbatteryAlive[index].value = moment()
                                    ipsbatteryAlive[index].alive_limit = moment().add(parseInt(alert_ipsbatteryalive_values.value), 'seconds')
                                    ipsbatteryAlive[index].message = await combine_mes_val_unit(alert_ipsbatteryalive_values.message, alert_ipsbatteryalive_values.value, alert_ipsbatteryalive_values.unit)
                                }
                                else {
                                    ipsbatteryAlive.push({
                                        key: ipsbatteryid, value: moment(), alive_limit: moment().add(parseInt(alert_ipsbatteryalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_ipsbatteryalive_values.message, alert_ipsbatteryalive_values.value, alert_ipsbatteryalive_values.unit), mode: alert_ipsbatteryalive_values.mode, id: alert_ipsbatteryalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_batteryid.batteryname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${ipsbatteryid}@${asserts.assertname}@BATTERY_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await ipsbattery_compare(ips_batery_data.slice(1, ips_batery_data.length), ipsbatteryid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    var battery_json = {}
                                    var battery_cells = ips_batery_data.slice(1, 56)
                                    for (let i = 0; i < battery_cells.length; i++) {
                                        battery_json[i + 1] = battery_cells[i]
                                    }

                                    var spare_json = {}
                                    var spare_cells = ips_batery_data.slice(57, 62)
                                    for (let i = 0; i < spare_cells.length; i++) {
                                        spare_json[i + 1] = spare_cells[i]
                                    }
                                    
                                    register_batteryid.battery_cells = battery_json
                                    register_batteryid.spare_cells = spare_json
                                    register_batteryid.charging_current = Math.sign(parseFloat(ips_batery_data[56]).toFixed(alert_curdec_values)) == 1 ? parseFloat(ips_batery_data[56]).toFixed(alert_curdec_values) : 0
                                    register_batteryid.discharging_current = Math.sign(parseFloat(ips_batery_data[56]).toFixed(alert_curdec_values)) == -1 ? parseFloat(ips_batery_data[56]).toFixed(alert_curdec_values) : 0
                                    register_batteryid.bank_voltage = (battery_cells.map(i => parseFloat(i))).reduce((a, b) => a + b).toFixed(alert_voldec_values)
                                    register_batteryid.spare_charging_current = Math.sign(parseFloat(ips_batery_data[62]).toFixed(alert_curdec_values)) == 1 ? parseFloat(ips_batery_data[62]).toFixed(alert_curdec_values) : 0
                                    register_batteryid.spare_discharging_current = Math.sign(parseFloat(ips_batery_data[62]).toFixed(alert_curdec_values)) == -1 ? parseFloat(ips_batery_data[62]).toFixed(alert_curdec_values) : 0
                                    register_batteryid.spare_bank_voltage = (spare_cells.map(i => parseFloat(i))).reduce((a, b) => a + b).toFixed(alert_voldec_values)
                                    register_batteryid.createddate = current_datetime

                                    let transaction = await db.transaction({ autocommit: false });
                                    try {
                                        await BatteryData.create(register_batteryid, { transaction: transaction })
                                        await transaction.commit();
                                        logs.info("Battery Data inserted");


                                        let alert_data = {}
                                        let alert_logs = []
                                        let alert_modeid = 0

                                        let socket_data = {
                                            data_logs: register_batteryid,
                                            alertmodeid: alert_logs.length > 0 ? alert_modeid : null,
                                            alerts: alert_logs
                                        }
                                        //logs.info('batterydata',socket_data )
                                        Socket.emit("batterydata", socket_data)
                                        //socketcloud.emit("Batteries", socket_data)
                                    }
                                    catch (ex) {
                                        await transaction.rollback();
                                        logs.error('mqtt error stationdata/IPS_Battery ' + ex);
                                        //console.log('mqtt error stationdata/IPS_Battery ' + ex);
                                    }
                                }
                            }
                        }
                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/IPS_Battery ' + ex);
                        //console.log('mqtt error stationdata/IPS_Battery ' + ex);
                    }
                }
            });
        });

        // Active - Cluster 3
        client.subscribe('stationdata/c3', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/c3') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/C3', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/C3', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var C3_data = packet.payload.toString().split(',');

                        //L1,L2,L2A,l3,L3A,Axle Counter,L4
                        var allzero = C3_data.slice(2, 12).every(x => x === '0')

                        var track_relay = ""
                        var trackcircuitid = parseInt(C3_data[1]).toString(16).split("")[0];
                        var trackterminal = String.fromCharCode(parseInt((parseInt(C3_data[1]).toString(16).split("")[1] + parseInt(C3_data[1]).toString(16).split("")[2]), 16))

                        var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null && allzero == true) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                if (index !== -1) {
                                    trackcircuitAlive[index].value = moment()
                                    trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                    trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                }
                                else {
                                    trackcircuitAlive.push({
                                        key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await trackcircuit_compare_Relay(C3_data.slice(2, 12), trackcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let track_count = 1;
                                    const cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (cycle_index !== -1) {
                                        track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                        trackcircuitRelaydatas[cycle_index].value = track_count
                                    }
                                    else {
                                        if (trackcircuitWithoutArray === true) {
                                            var RelayDatas = [await TrackCircuitData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: trackcircuitid },
                                                raw: true
                                            })];
                                            RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                            if (RelayDatas.length > 0) {
                                                track_count = RelayDatas[0].count + 1
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                            }
                                            else {
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                        else {
                                            var RelayDatas = [await TrackCircuitRelayData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: parseInt(trackcircuitid) },
                                                raw: true
                                            })];
                                            RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                            if (RelayDatas.length > 0) {
                                                track_count = RelayDatas[0].count + 1
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                            }
                                            else {
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                    }

                                    let track_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        trackcircuitid: parseInt(trackcircuitid),
                                        trackcircuitterminal: trackterminal,
                                        trackname: register_trackid.trackname,
                                        count: track_count,
                                        feed_voltage: parseFloat(C3_data[2]).toFixed(alert_voldec_values),
                                        feed_current: parseFloat(C3_data[3]).toFixed(alert_curdec_values),
                                        choke_voltage: parseFloat(C3_data[4]).toFixed(alert_voldec_values),
                                        battery_charger_dc_current: parseFloat(C3_data[5]).toFixed(alert_curdec_values),
                                        battery_charger_dc_voltage: parseFloat(C3_data[6]).toFixed(alert_voldec_values),
                                        battery_charger_ac_voltage: parseFloat(C3_data[7]).toFixed(alert_voldec_values),
                                        battery_charger_ac_current: parseFloat(C3_data[8]).toFixed(alert_curdec_values),
                                        relay_voltage: parseFloat(C3_data[9]).toFixed(alert_voldec_values),
                                        relay_current: parseFloat(C3_data[10]).toFixed(alert_curdec_values),
                                        trv: parseFloat(C3_data[11]).toFixed(alert_voldec_values),
                                        createddate: current_datetime
                                    }
                                    //logs.info('TS_1R', track_data)
                                    if (cycle_index !== -1) {
                                        trackcircuitRelaydatas[cycle_index].data = track_data
                                    }
                                    else {
                                        trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                    }

                                    if (trackcircuitWithoutArray === true) {
                                        insert_relaytrack_array(track_data);
                                    }
                                    else {
                                        let transaction = await db.transaction({ autocommit: false });
                                        try {
                                            const tc_f_data_insert = await TrackCircuitRelayData.create(
                                                track_data,
                                                { transaction: transaction },
                                                { returning: true }
                                            );

                                            await transaction.commit();
                                            track_relay = track_data
                                            //insert_relaytrack_array(track_data);
                                            logs.info("Track relay data inserted");
                                            //console.log("Track relay data inserted");
                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/TS_1R ' + ex);
                                            //console.log('mqtt error stationdata/TS_1R ' + ex);
                                        }
                                    }
                                }
                            }
                        }

                        var track_feeder = ""
                        var allzero = C3_data.slice(38, 48).every(x => x === '0')

                        var trackcircuitid = parseInt(C3_data[37]).toString(16).split("")[0];
                        var trackterminal = String.fromCharCode(parseInt((parseInt(C3_data[37]).toString(16).split("")[1] + parseInt(C3_data[37]).toString(16).split("")[2]), 16))

                        var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null && allzero == true) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                if (index !== -1) {
                                    trackcircuitAlive[index].value = moment()
                                    trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                    trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                }
                                else {
                                    trackcircuitAlive.push({
                                        key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await trackcircuit_compare_Feeder(C3_data.slice(38, 48), trackcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let track_count = 1;
                                    const cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (cycle_index !== -1) {
                                        track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                        trackcircuitFeederdatas[cycle_index].value = track_count
                                    }
                                    else {
                                        if (trackcircuitWithoutArray === true) {
                                            var FeederDatas = [await TrackCircuitData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: trackcircuitid },
                                                raw: true
                                            })];
                                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                            if (FeederDatas.length > 0) {
                                                track_count = FeederDatas[0].feed_count + 1
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                            }
                                            else {
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                        else {
                                            var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: parseInt(trackcircuitid) },
                                                raw: true
                                            })];
                                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                            if (FeederDatas.length > 0) {
                                                track_count = FeederDatas[0].count + 1
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                            }
                                            else {
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                    }

                                    let track_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: asserts.id,
                                        assertname: asserts.assertname,
                                        trackcircuitid: parseInt(trackcircuitid),
                                        trackcircuitterminal: trackterminal,
                                        trackname: register_trackid.trackname,
                                        count: track_count,
                                        feed_voltage: parseFloat(C3_data[38]).toFixed(alert_voldec_values),
                                        feed_current: parseFloat(C3_data[39]).toFixed(alert_curdec_values),
                                        choke_voltage: parseFloat(C3_data[40]).toFixed(alert_voldec_values),
                                        battery_charger_dc_current: parseFloat(C3_data[41]).toFixed(alert_curdec_values),
                                        battery_charger_dc_voltage: parseFloat(C3_data[42]).toFixed(alert_voldec_values),
                                        battery_charger_ac_voltage: parseFloat(C3_data[43]).toFixed(alert_voldec_values),
                                        battery_charger_ac_current: parseFloat(C3_data[44]).toFixed(alert_curdec_values),
                                        relay_voltage: parseFloat(C3_data[45]).toFixed(alert_voldec_values),
                                        relay_current: parseFloat(C3_data[46]).toFixed(alert_curdec_values),
                                        trv: parseFloat(C3_data[47]).toFixed(alert_voldec_values),
                                        createddate: current_datetime
                                    }
                                    //logs.info('TS_1F', track_data)

                                    if (cycle_index != -1) {
                                        trackcircuitFeederdatas[cycle_index].data = track_data
                                    }
                                    else {
                                        trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                    }

                                    if (trackcircuitWithoutArray === true) {
                                        insert_feedertrack_array(track_data);
                                    }
                                    else {
                                        let transaction = await db.transaction({ autocommit: false });
                                        try {
                                            const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                track_data,
                                                { transaction: transaction },
                                                { returning: true }
                                            );
                                            await transaction.commit();
                                            track_feeder = track_data
                                            //insert_feedertrack_array(track_data);
                                            logs.info("Track feeder data inserted");
                                            //console.log("Track feeder data inserted");
                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/TS_1F ' + ex);
                                            //console.log('mqtt error stationdata/TS_1F ' + ex);
                                        }
                                    }
                                }
                            }
                        }

                        track_feeder != "" || track_relay != "" ? insert_feederrelaytrack_both(track_feeder, track_relay) : ""

                        var allzero = C3_data.slice(50, 60).every(x => x === '0')

                        var track_feeder = ""
                        var trackcircuitid = parseInt(C3_data[49]).toString(16).split("")[0];
                        var trackterminal = String.fromCharCode(parseInt((parseInt(C3_data[49]).toString(16).split("")[1] + parseInt(C3_data[49]).toString(16).split("")[2]), 16))

                        var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null && allzero == true) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                if (index !== -1) {
                                    trackcircuitAlive[index].value = moment()
                                    trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                    trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                }
                                else {
                                    trackcircuitAlive.push({
                                        key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await trackcircuit_compare_Feeder(C3_data.slice(50, 60), trackcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let track_count = 1;
                                    const cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (cycle_index !== -1) {
                                        track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                        trackcircuitFeederdatas[cycle_index].value = track_count
                                    }
                                    else {
                                        if (trackcircuitWithoutArray === true) {
                                            var FeederDatas = [await TrackCircuitData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: trackcircuitid },
                                                raw: true
                                            })];
                                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                            if (FeederDatas.length > 0) {
                                                track_count = FeederDatas[0].feed_count + 1
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                            }
                                            else {
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                        else {
                                            var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: parseInt(trackcircuitid) },
                                                raw: true
                                            })];
                                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                            if (FeederDatas.length > 0) {
                                                track_count = FeederDatas[0].count + 1
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                            }
                                            else {
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                    }

                                    let track_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: asserts.id,
                                        assertname: asserts.assertname,
                                        trackcircuitid: parseInt(trackcircuitid),
                                        trackcircuitterminal: trackterminal,
                                        trackname: register_trackid.trackname,
                                        count: track_count,
                                        feed_voltage: parseFloat(C3_data[50]).toFixed(alert_voldec_values),
                                        feed_current: parseFloat(C3_data[51]).toFixed(alert_curdec_values),
                                        choke_voltage: parseFloat(C3_data[52]).toFixed(alert_voldec_values),
                                        battery_charger_dc_current: parseFloat(C3_data[53]).toFixed(alert_curdec_values),
                                        battery_charger_dc_voltage: parseFloat(C3_data[54]).toFixed(alert_voldec_values),
                                        battery_charger_ac_voltage: parseFloat(C3_data[55]).toFixed(alert_voldec_values),
                                        battery_charger_ac_current: parseFloat(C3_data[56]).toFixed(alert_curdec_values),
                                        relay_voltage: parseFloat(C3_data[57]).toFixed(alert_voldec_values),
                                        relay_current: parseFloat(C3_data[58]).toFixed(alert_curdec_values),
                                        trv: parseFloat(C3_data[59]).toFixed(alert_voldec_values),
                                        createddate: current_datetime
                                    }
                                    //logs.info('TS_1F', track_data)

                                    if (cycle_index != -1) {
                                        trackcircuitFeederdatas[cycle_index].data = track_data
                                    }
                                    else {
                                        trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                    }

                                    if (trackcircuitWithoutArray === true) {
                                        insert_feedertrack_array(track_data);
                                    }
                                    else {
                                        let transaction = await db.transaction({ autocommit: false });
                                        try {
                                            const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                track_data,
                                                { transaction: transaction },
                                                { returning: true }
                                            );
                                            await transaction.commit();
                                            track_feeder = track_data
                                            //insert_feedertrack_array(track_data);
                                            logs.info("Track feeder data inserted");
                                            //console.log("Track feeder data inserted");
                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/TS_1F ' + ex);
                                            //console.log('mqtt error stationdata/TS_1F ' + ex);
                                        }
                                    }
                                }
                            }
                        }

                        var track_relay = ""
                        var allzero = C3_data.slice(74, 84).every(x => x === '0')

                        var trackcircuitid = parseInt(C3_data[73]).toString(16).split("")[0];
                        var trackterminal = String.fromCharCode(parseInt((parseInt(C3_data[73]).toString(16).split("")[1] + parseInt(C3_data[73]).toString(16).split("")[2]), 16))

                        var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null && allzero == true) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                if (index !== -1) {
                                    trackcircuitAlive[index].value = moment()
                                    trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                    trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                }
                                else {
                                    trackcircuitAlive.push({
                                        key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await trackcircuit_compare_Relay(C3_data.slice(74, 84), trackcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let track_count = 1;
                                    const cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (cycle_index !== -1) {
                                        track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                        trackcircuitRelaydatas[cycle_index].value = track_count
                                    }
                                    else {
                                        if (trackcircuitWithoutArray === true) {
                                            var RelayDatas = [await TrackCircuitData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: trackcircuitid },
                                                raw: true
                                            })];
                                            RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                            if (RelayDatas.length > 0) {
                                                track_count = RelayDatas[0].count + 1
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                            }
                                            else {
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                        else {
                                            var RelayDatas = [await TrackCircuitRelayData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: parseInt(trackcircuitid) },
                                                raw: true
                                            })];
                                            RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                            if (RelayDatas.length > 0) {
                                                track_count = RelayDatas[0].count + 1
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                            }
                                            else {
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                    }

                                    let track_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        trackcircuitid: parseInt(trackcircuitid),
                                        trackcircuitterminal: trackterminal,
                                        trackname: register_trackid.trackname,
                                        count: track_count,
                                        feed_voltage: parseFloat(C3_data[74]).toFixed(alert_voldec_values),
                                        feed_current: parseFloat(C3_data[75]).toFixed(alert_curdec_values),
                                        choke_voltage: parseFloat(C3_data[76]).toFixed(alert_voldec_values),
                                        battery_charger_dc_current: parseFloat(C3_data[77]).toFixed(alert_curdec_values),
                                        battery_charger_dc_voltage: parseFloat(C3_data[78]).toFixed(alert_voldec_values),
                                        battery_charger_ac_voltage: parseFloat(C3_data[79]).toFixed(alert_voldec_values),
                                        battery_charger_ac_current: parseFloat(C3_data[80]).toFixed(alert_curdec_values),
                                        relay_voltage: parseFloat(C3_data[81]).toFixed(alert_voldec_values),
                                        relay_current: parseFloat(C3_data[82]).toFixed(alert_curdec_values),
                                        trv: parseFloat(C3_data[83]).toFixed(alert_voldec_values),
                                        createddate: current_datetime
                                    }
                                    //logs.info('TS_1R', track_data)
                                    if (cycle_index !== -1) {
                                        trackcircuitRelaydatas[cycle_index].data = track_data
                                    }
                                    else {
                                        trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                    }

                                    if (trackcircuitWithoutArray === true) {
                                        insert_relaytrack_array(track_data);
                                    }
                                    else {
                                        let transaction = await db.transaction({ autocommit: false });
                                        try {
                                            const tc_f_data_insert = await TrackCircuitRelayData.create(
                                                track_data,
                                                { transaction: transaction },
                                                { returning: true }
                                            );

                                            await transaction.commit();
                                            track_relay = track_data
                                            //insert_relaytrack_array(track_data);
                                            logs.info("Track relay data inserted");
                                            //console.log("Track relay data inserted");
                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/TS_1R ' + ex);
                                            //console.log('mqtt error stationdata/TS_1R ' + ex);
                                        }
                                    }
                                }
                            }
                        }

                        track_feeder != "" || track_relay != "" ? insert_feederrelaytrack_both(track_feeder, track_relay) : ""

                        var allzero = C3_data.slice(62, 72).every(x => x === '0')

                        var trackcircuitid = parseInt(C3_data[61]).toString(16).split("")[0];
                        var trackterminal = String.fromCharCode(parseInt((parseInt(C3_data[61]).toString(16).split("")[1] + parseInt(C3_data[61]).toString(16).split("")[2]), 16))

                        var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null && allzero == true) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                if (index !== -1) {
                                    trackcircuitAlive[index].value = moment()
                                    trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                    trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                }
                                else {
                                    trackcircuitAlive.push({
                                        key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await trackcircuit_compare_Feeder(C3_data.slice(62, 72), trackcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let track_count = 1;
                                    const cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (cycle_index !== -1) {
                                        track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                        trackcircuitFeederdatas[cycle_index].value = track_count
                                    }
                                    else {
                                        if (trackcircuitWithoutArray === true) {
                                            var FeederDatas = [await TrackCircuitData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: trackcircuitid },
                                                raw: true
                                            })];
                                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                            if (FeederDatas.length > 0) {
                                                track_count = FeederDatas[0].feed_count + 1
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                            }
                                            else {
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                        else {
                                            var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: parseInt(trackcircuitid) },
                                                raw: true
                                            })];
                                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                            if (FeederDatas.length > 0) {
                                                track_count = FeederDatas[0].count + 1
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                            }
                                            else {
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                    }

                                    let track_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: asserts.id,
                                        assertname: asserts.assertname,
                                        trackcircuitid: parseInt(trackcircuitid),
                                        trackcircuitterminal: trackterminal,
                                        trackname: register_trackid.trackname,
                                        count: track_count,
                                        feed_voltage: parseFloat(C3_data[62]).toFixed(alert_voldec_values),
                                        feed_current: parseFloat(C3_data[63]).toFixed(alert_curdec_values),
                                        choke_voltage: parseFloat(C3_data[64]).toFixed(alert_voldec_values),
                                        battery_charger_dc_current: parseFloat(C3_data[65]).toFixed(alert_curdec_values),
                                        battery_charger_dc_voltage: parseFloat(C3_data[66]).toFixed(alert_voldec_values),
                                        battery_charger_ac_voltage: parseFloat(C3_data[67]).toFixed(alert_voldec_values),
                                        battery_charger_ac_current: parseFloat(C3_data[68]).toFixed(alert_curdec_values),
                                        relay_voltage: parseFloat(C3_data[69]).toFixed(alert_voldec_values),
                                        relay_current: parseFloat(C3_data[70]).toFixed(alert_curdec_values),
                                        trv: parseFloat(C3_data[71]).toFixed(alert_voldec_values),
                                        createddate: current_datetime
                                    }
                                    //logs.info('TS_1F', track_data)
                                    if (cycle_index != -1) {
                                        trackcircuitFeederdatas[cycle_index].data = track_data
                                    }
                                    else {
                                        trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                    }

                                    if (trackcircuitWithoutArray === true) {
                                        insert_feedertrack_array(track_data);
                                    }
                                    else {
                                        let transaction = await db.transaction({ autocommit: false });
                                        try {
                                            const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                track_data,
                                                { transaction: transaction },
                                                { returning: true }
                                            );
                                            await transaction.commit();
                                            insert_feedertrack_array(track_data);
                                            logs.info("Track feeder data inserted");
                                            //console.log("Track feeder data inserted");
                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/TS_1F ' + ex);
                                            //console.log('mqtt error stationdata/TS_1F ' + ex);
                                        }
                                    }
                                }
                            }
                        }

                        var allzero = C3_data.slice(14, 22).every(x => x === '0')

                        var signalcircuitid = parseInt(parseInt(C3_data[13]).toString(16).split("")[0], 16);
                        var signalterminal = String.fromCharCode(parseInt((parseInt(C3_data[13]).toString(16).split("")[1] + parseInt(C3_data[13]).toString(16).split("")[2]), 16))

                        var register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                        if (register_signalid != null && allzero == true) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                            const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_signalalive_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)

                                var index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });
                                if (index !== -1) {
                                    signalcircuitAlive[index].value = moment()
                                    signalcircuitAlive[index].alive_limit = moment().add(parseInt(alert_signalalive_values.value), 'seconds')
                                    signalcircuitAlive[index].message = await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit)
                                }
                                else {
                                    signalcircuitAlive.push({
                                        key: signalcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_signalalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit), mode: alert_signalalive_values.mode, id: alert_signalalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_signalid.signalname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SIGNAL_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await signalcircuit_compare(C3_data.slice(14, 22), signalcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let signal_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        signalcircuitid: parseInt(signalcircuitid),
                                        signalname: register_signalid.signalname,
                                        terminal: signalterminal,
                                        aspecttypeid: register_signalid.aspecttypeid,
                                        description: signalaspects.description,
                                        greenvoltage: parseFloat(C3_data[14]).toFixed(alert_voldec_values),
                                        greencurrent: parseFloat(C3_data[15]).toFixed(alert_curdec_values),
                                        redvoltage: parseFloat(C3_data[16]).toFixed(alert_voldec_values),
                                        redcurrent: parseFloat(C3_data[17]).toFixed(alert_curdec_values),
                                        yellowvoltage: parseFloat(C3_data[18]).toFixed(alert_voldec_values),
                                        yellowcurrent: parseFloat(C3_data[19]).toFixed(alert_curdec_values),
                                        lightyellowvoltage: parseFloat(C3_data[20]).toFixed(alert_voldec_values),
                                        lightyellowcurrent: parseFloat(C3_data[21]).toFixed(alert_curdec_values),
                                        createddate: current_datetime
                                    }

                                    await insert_signalcircuit(signal_data)

                                    //logs.info('TS_1F', signal_data)        
                                }

                            }
                        }

                        var allzero = C3_data.slice(24, 36).every(x => x === '0')

                        var signalcircuitid = parseInt(parseInt(C3_data[23]).toString(16).split("")[0], 16);
                        var signalterminal = String.fromCharCode(parseInt((parseInt(C3_data[23]).toString(16).split("")[1] + parseInt(C3_data[23]).toString(16).split("")[2]), 16))

                        var register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                        if (register_signalid != null && allzero == true) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                            const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_signalalive_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)

                                var index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });
                                if (index !== -1) {
                                    signalcircuitAlive[index].value = moment()
                                    signalcircuitAlive[index].alive_limit = moment().add(parseInt(alert_signalalive_values.value), 'seconds')
                                    signalcircuitAlive[index].message = await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit)
                                }
                                else {
                                    signalcircuitAlive.push({
                                        key: signalcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_signalalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit), mode: alert_signalalive_values.mode, id: alert_signalalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_signalid.signalname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SIGNAL_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await signalcircuit_compare(C3_data.slice(24, 36), signalcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let signal_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        signalcircuitid: parseInt(signalcircuitid),
                                        signalname: register_signalid.signalname,
                                        terminal: signalterminal,
                                        aspecttypeid: register_signalid.aspecttypeid,
                                        description: signalaspects.description,
                                        greenvoltage: parseFloat(C3_data[14]).toFixed(alert_voldec_values),
                                        greencurrent: parseFloat(C3_data[15]).toFixed(alert_curdec_values),
                                        redvoltage: parseFloat(C3_data[16]).toFixed(alert_voldec_values),
                                        redcurrent: parseFloat(C3_data[17]).toFixed(alert_curdec_values),
                                        yellowvoltage: parseFloat(C3_data[18]).toFixed(alert_voldec_values),
                                        yellowcurrent: parseFloat(C3_data[19]).toFixed(alert_curdec_values),
                                        lightyellowvoltage: parseFloat(C3_data[20]).toFixed(alert_voldec_values),
                                        lightyellowcurrent: parseFloat(C3_data[21]).toFixed(alert_curdec_values),
                                        createddate: current_datetime
                                    }

                                    await insert_signalcircuit(signal_data)

                                    //logs.info('TS_1F', signal_data)        
                                }

                            }
                        }

                        var allzero = C3_data.slice(86, 94).every(x => x === '0')

                        var signalcircuitid = parseInt(parseInt(C3_data[85]).toString(16).split("")[0], 16);
                        var signalterminal = String.fromCharCode(parseInt((parseInt(C3_data[85]).toString(16).split("")[1] + parseInt(C3_data[85]).toString(16).split("")[2]), 16))

                        var register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                        if (register_signalid != null && allzero == true) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                            const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_signalalive_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)

                                var index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });
                                if (index !== -1) {
                                    signalcircuitAlive[index].value = moment()
                                    signalcircuitAlive[index].alive_limit = moment().add(parseInt(alert_signalalive_values.value), 'seconds')
                                    signalcircuitAlive[index].message = await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit)
                                }
                                else {
                                    signalcircuitAlive.push({
                                        key: signalcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_signalalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit), mode: alert_signalalive_values.mode, id: alert_signalalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_signalid.signalname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SIGNAL_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await signalcircuit_compare(C3_data.slice(86, 94), signalcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let signal_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        signalcircuitid: parseInt(signalcircuitid),
                                        signalname: register_signalid.signalname,
                                        terminal: signalterminal,
                                        aspecttypeid: register_signalid.aspecttypeid,
                                        description: signalaspects.description,
                                        greenvoltage: parseFloat(C3_data[86]).toFixed(alert_voldec_values),
                                        greencurrent: parseFloat(C3_data[87]).toFixed(alert_curdec_values),
                                        redvoltage: parseFloat(C3_data[88]).toFixed(alert_voldec_values),
                                        redcurrent: parseFloat(C3_data[89]).toFixed(alert_curdec_values),
                                        yellowvoltage: parseFloat(C3_data[90]).toFixed(alert_voldec_values),
                                        yellowcurrent: parseFloat(C3_data[91]).toFixed(alert_curdec_values),
                                        lightyellowvoltage: parseFloat(C3_data[92]).toFixed(alert_voldec_values),
                                        lightyellowcurrent: parseFloat(C3_data[93]).toFixed(alert_curdec_values),
                                        createddate: current_datetime
                                    }

                                    await insert_signalcircuit(signal_data)

                                    //logs.info('TS_1F', signal_data)        
                                }

                            }
                        }






                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/C6 ' + ex);
                        //console.log('mqtt error stationdata/C6 ' + ex);
                    }
                }
            });
        });

        // Active - Cluster 5
        client.subscribe('stationdata/C5', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/C5') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/C5', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/C5', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var C5_data = packet.payload.toString().split(',');
                        logs.info('stationdata/C5', C5_data)

                        //L5,L7,L7A
                        var allzero = C5_data.slice(14, 24).every(x => x === '0')

                        var track_feeder = ""
                        var trackcircuitid = parseInt(C5_data[13]).toString(16).split("")[0];
                        var trackterminal = String.fromCharCode(parseInt((parseInt(C5_data[13]).toString(16).split("")[1] + parseInt(C5_data[13]).toString(16).split("")[2]), 16))

                        var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                if (index !== -1) {
                                    trackcircuitAlive[index].value = moment()
                                    trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                    trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                }
                                else {
                                    trackcircuitAlive.push({
                                        key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await trackcircuit_compare_Feeder(C5_data.slice(14, 24), trackcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let track_count = 1;
                                    const cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (cycle_index !== -1) {
                                        track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                        trackcircuitFeederdatas[cycle_index].value = track_count
                                    }
                                    else {
                                        if (trackcircuitWithoutArray === true) {
                                            var FeederDatas = [await TrackCircuitData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: trackcircuitid },
                                                raw: true
                                            })];
                                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                            if (FeederDatas.length > 0) {
                                                track_count = FeederDatas[0].feed_count + 1
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                            }
                                            else {
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                        else {
                                            var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: parseInt(trackcircuitid) },
                                                raw: true
                                            })];
                                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                            if (FeederDatas.length > 0) {
                                                track_count = FeederDatas[0].count + 1
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                            }
                                            else {
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                    }

                                    let track_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: asserts.id,
                                        assertname: asserts.assertname,
                                        trackcircuitid: parseInt(trackcircuitid),
                                        trackcircuitterminal: trackterminal,
                                        trackname: register_trackid.trackname,
                                        count: track_count,
                                        feed_voltage: parseFloat(C5_data[14]).toFixed(alert_voldec_values),
                                        feed_current: parseFloat(C5_data[15]).toFixed(alert_curdec_values),
                                        choke_voltage: parseFloat(C5_data[16]).toFixed(alert_voldec_values),
                                        battery_charger_dc_current: parseFloat(C5_data[17]).toFixed(alert_curdec_values),
                                        battery_charger_dc_voltage: parseFloat(C5_data[18]).toFixed(alert_voldec_values),
                                        battery_charger_ac_voltage: parseFloat(C5_data[19]).toFixed(alert_voldec_values),
                                        battery_charger_ac_current: parseFloat(C5_data[20]).toFixed(alert_curdec_values),
                                        relay_voltage: parseFloat(C5_data[21]).toFixed(alert_voldec_values),
                                        relay_current: parseFloat(C5_data[22]).toFixed(alert_curdec_values),
                                        trv: parseFloat(C5_data[23]).toFixed(alert_voldec_values),
                                        createddate: current_datetime
                                    }
                                    //logs.info('TS_1F', track_data)

                                    if (cycle_index != -1) {
                                        trackcircuitFeederdatas[cycle_index].data = track_data
                                    }
                                    else {
                                        trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                    }

                                    if (trackcircuitWithoutArray === true) {
                                        insert_feedertrack_array(track_data);
                                    }
                                    else {
                                        let transaction = await db.transaction({ autocommit: false });
                                        try {
                                            const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                track_data,
                                                { transaction: transaction },
                                                { returning: true }
                                            );
                                            await transaction.commit();
                                            track_feeder = track_data
                                            //insert_feedertrack_array(track_data);
                                            logs.info("Track feeder data inserted");
                                            //console.log("Track feeder data inserted");
                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/TS_1F ' + ex);
                                            //console.log('mqtt error stationdata/TS_1F ' + ex);
                                        }
                                    }
                                }
                            }
                        }

                        var track_relay = ""
                        var allzero = C5_data.slice(48, 58).every(x => x === '0')

                        var trackcircuitid = parseInt(C5_data[47]).toString(16).split("")[0];
                        var trackterminal = String.fromCharCode(parseInt((parseInt(C5_data[47]).toString(16).split("")[1] + parseInt(C5_data[47]).toString(16).split("")[2]), 16))

                        var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                if (index !== -1) {
                                    trackcircuitAlive[index].value = moment()
                                    trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                    trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                }
                                else {
                                    trackcircuitAlive.push({
                                        key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await trackcircuit_compare_Relay(C5_data.slice(48, 58), trackcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let track_count = 1;
                                    const cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (cycle_index !== -1) {
                                        track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                        trackcircuitRelaydatas[cycle_index].value = track_count
                                    }
                                    else {
                                        if (trackcircuitWithoutArray === true) {
                                            var RelayDatas = [await TrackCircuitData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: trackcircuitid },
                                                raw: true
                                            })];
                                            RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                            if (RelayDatas.length > 0) {
                                                track_count = RelayDatas[0].count + 1
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                            }
                                            else {
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                        else {
                                            var RelayDatas = [await TrackCircuitRelayData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: parseInt(trackcircuitid) },
                                                raw: true
                                            })];
                                            RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                            if (RelayDatas.length > 0) {
                                                track_count = RelayDatas[0].count + 1
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                            }
                                            else {
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                    }

                                    let track_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        trackcircuitid: parseInt(trackcircuitid),
                                        trackcircuitterminal: trackterminal,
                                        trackname: register_trackid.trackname,
                                        count: track_count,
                                        feed_voltage: parseFloat(C5_data[48]).toFixed(alert_voldec_values),
                                        feed_current: parseFloat(C5_data[49]).toFixed(alert_curdec_values),
                                        choke_voltage: parseFloat(C5_data[50]).toFixed(alert_voldec_values),
                                        battery_charger_dc_current: parseFloat(C5_data[51]).toFixed(alert_curdec_values),
                                        battery_charger_dc_voltage: parseFloat(C5_data[52]).toFixed(alert_voldec_values),
                                        battery_charger_ac_voltage: parseFloat(C5_data[53]).toFixed(alert_voldec_values),
                                        battery_charger_ac_current: parseFloat(C5_data[54]).toFixed(alert_curdec_values),
                                        relay_voltage: parseFloat(C5_data[55]).toFixed(alert_voldec_values),
                                        relay_current: parseFloat(C5_data[56]).toFixed(alert_curdec_values),
                                        trv: parseFloat(C5_data[57]).toFixed(alert_voldec_values),
                                        createddate: current_datetime
                                    }
                                    //logs.info('TS_1R', track_data)
                                    if (cycle_index !== -1) {
                                        trackcircuitRelaydatas[cycle_index].data = track_data
                                    }
                                    else {
                                        trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                    }

                                    if (trackcircuitWithoutArray === true) {
                                        insert_relaytrack_array(track_data);
                                    }
                                    else {
                                        let transaction = await db.transaction({ autocommit: false });
                                        try {
                                            const tc_f_data_insert = await TrackCircuitRelayData.create(
                                                track_data,
                                                { transaction: transaction },
                                                { returning: true }
                                            );

                                            await transaction.commit();
                                            track_relay = track_data
                                            //insert_relaytrack_array(track_data);
                                            logs.info("Track relay data inserted");
                                            //console.log("Track relay data inserted");
                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/TS_1R ' + ex);
                                            //console.log('mqtt error stationdata/TS_1R ' + ex);
                                        }
                                    }
                                }
                            }
                        }

                        track_feeder != "" || track_relay != "" ? insert_feederrelaytrack_both(track_feeder, track_relay) : ""

                        var track_feeder = ""
                        var allzero = C5_data.slice(26, 36).every(x => x === '0')

                        var trackcircuitid = parseInt(C5_data[25]).toString(16).split("")[0];
                        var trackterminal = String.fromCharCode(parseInt((parseInt(C5_data[25]).toString(16).split("")[1] + parseInt(C5_data[25]).toString(16).split("")[2]), 16))

                        var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                if (index !== -1) {
                                    trackcircuitAlive[index].value = moment()
                                    trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                    trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                }
                                else {
                                    trackcircuitAlive.push({
                                        key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await trackcircuit_compare_Feeder(C5_data.slice(26, 36), trackcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let track_count = 1;
                                    const cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (cycle_index !== -1) {
                                        track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                        trackcircuitFeederdatas[cycle_index].value = track_count
                                    }
                                    else {
                                        if (trackcircuitWithoutArray === true) {
                                            var FeederDatas = [await TrackCircuitData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: trackcircuitid },
                                                raw: true
                                            })];
                                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                            if (FeederDatas.length > 0) {
                                                track_count = FeederDatas[0].feed_count + 1
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                            }
                                            else {
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                        else {
                                            var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: parseInt(trackcircuitid) },
                                                raw: true
                                            })];
                                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                            if (FeederDatas.length > 0) {
                                                track_count = FeederDatas[0].count + 1
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                            }
                                            else {
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                    }

                                    let track_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: asserts.id,
                                        assertname: asserts.assertname,
                                        trackcircuitid: parseInt(trackcircuitid),
                                        trackcircuitterminal: trackterminal,
                                        trackname: register_trackid.trackname,
                                        count: track_count,
                                        feed_voltage: parseFloat(C5_data[26]).toFixed(alert_voldec_values),
                                        feed_current: parseFloat(C5_data[27]).toFixed(alert_curdec_values),
                                        choke_voltage: parseFloat(C5_data[28]).toFixed(alert_voldec_values),
                                        battery_charger_dc_current: parseFloat(C5_data[29]).toFixed(alert_curdec_values),
                                        battery_charger_dc_voltage: parseFloat(C5_data[30]).toFixed(alert_voldec_values),
                                        battery_charger_ac_voltage: parseFloat(C5_data[31]).toFixed(alert_voldec_values),
                                        battery_charger_ac_current: parseFloat(C5_data[32]).toFixed(alert_curdec_values),
                                        relay_voltage: parseFloat(C5_data[33]).toFixed(alert_voldec_values),
                                        relay_current: parseFloat(C5_data[34]).toFixed(alert_curdec_values),
                                        trv: parseFloat(C5_data[35]).toFixed(alert_voldec_values),
                                        createddate: current_datetime
                                    }
                                    //logs.info('TS_1F', track_data)
                                    if (cycle_index != -1) {
                                        trackcircuitFeederdatas[cycle_index].data = track_data
                                    }
                                    else {
                                        trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                    }

                                    if (trackcircuitWithoutArray === true) {
                                        insert_feedertrack_array(track_data);
                                    }
                                    else {
                                        let transaction = await db.transaction({ autocommit: false });
                                        try {
                                            const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                track_data,
                                                { transaction: transaction },
                                                { returning: true }
                                            );
                                            await transaction.commit();
                                            track_feeder = track_data
                                            //insert_feedertrack_array(track_data);
                                            logs.info("Track feeder data inserted");
                                            //console.log("Track feeder data inserted");
                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/TS_1F ' + ex);
                                            //console.log('mqtt error stationdata/TS_1F ' + ex);
                                        }
                                    }
                                }
                            }
                        }

                        var track_relay = ""
                        var allzero = C5_data.slice(72, 82).every(x => x === '0')

                        var trackcircuitid = parseInt(C5_data[71]).toString(16).split("")[0];
                        var trackterminal = String.fromCharCode(parseInt((parseInt(C5_data[71]).toString(16).split("")[1] + parseInt(C5_data[71]).toString(16).split("")[2]), 16))

                        var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                if (index !== -1) {
                                    trackcircuitAlive[index].value = moment()
                                    trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                    trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                }
                                else {
                                    trackcircuitAlive.push({
                                        key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await trackcircuit_compare_Relay(C5_data.slice(72, 82), trackcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let track_count = 1;
                                    const cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (cycle_index !== -1) {
                                        track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                        trackcircuitRelaydatas[cycle_index].value = track_count
                                    }
                                    else {
                                        if (trackcircuitWithoutArray === true) {
                                            var RelayDatas = [await TrackCircuitData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: trackcircuitid },
                                                raw: true
                                            })];
                                            RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                            if (RelayDatas.length > 0) {
                                                track_count = RelayDatas[0].count + 1
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                            }
                                            else {
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                        else {
                                            var RelayDatas = [await TrackCircuitRelayData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: parseInt(trackcircuitid) },
                                                raw: true
                                            })];
                                            RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                            if (RelayDatas.length > 0) {
                                                track_count = RelayDatas[0].count + 1
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                            }
                                            else {
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                    }

                                    let track_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        trackcircuitid: parseInt(trackcircuitid),
                                        trackcircuitterminal: trackterminal,
                                        trackname: register_trackid.trackname,
                                        count: track_count,
                                        feed_voltage: parseFloat(C5_data[72]).toFixed(alert_voldec_values),
                                        feed_current: parseFloat(C5_data[73]).toFixed(alert_curdec_values),
                                        choke_voltage: parseFloat(C5_data[74]).toFixed(alert_voldec_values),
                                        battery_charger_dc_current: parseFloat(C5_data[75]).toFixed(alert_curdec_values),
                                        battery_charger_dc_voltage: parseFloat(C5_data[76]).toFixed(alert_voldec_values),
                                        battery_charger_ac_voltage: parseFloat(C5_data[77]).toFixed(alert_voldec_values),
                                        battery_charger_ac_current: parseFloat(C5_data[78]).toFixed(alert_curdec_values),
                                        relay_voltage: parseFloat(C5_data[79]).toFixed(alert_voldec_values),
                                        relay_current: parseFloat(C5_data[80]).toFixed(alert_curdec_values),
                                        trv: parseFloat(C5_data[81]).toFixed(alert_voldec_values),
                                        createddate: current_datetime
                                    }
                                    //logs.info('TS_1R', track_data)
                                    if (cycle_index !== -1) {
                                        trackcircuitRelaydatas[cycle_index].data = track_data
                                    }
                                    else {
                                        trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                    }

                                    if (trackcircuitWithoutArray === true) {
                                        insert_relaytrack_array(track_data);
                                    }
                                    else {
                                        let transaction = await db.transaction({ autocommit: false });
                                        try {
                                            const tc_f_data_insert = await TrackCircuitRelayData.create(
                                                track_data,
                                                { transaction: transaction },
                                                { returning: true }
                                            );

                                            await transaction.commit();
                                            track_relay = track_data
                                            //insert_relaytrack_array(track_data);
                                            logs.info("Track relay data inserted");
                                            //console.log("Track relay data inserted");
                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/TS_1R ' + ex);
                                            //console.log('mqtt error stationdata/TS_1R ' + ex);
                                        }
                                    }
                                }
                            }
                        }

                        track_feeder != "" || track_relay != "" ? insert_feederrelaytrack_both(track_feeder, track_relay) : ""

                        var allzero = C5_data.slice(2, 12).every(x => x === '0')

                        var trackcircuitid = parseInt(C5_data[1]).toString(16).split("")[0];
                        var trackterminal = String.fromCharCode(parseInt((parseInt(C5_data[1]).toString(16).split("")[1] + parseInt(C5_data[1]).toString(16).split("")[2]), 16))

                        var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                if (index !== -1) {
                                    trackcircuitAlive[index].value = moment()
                                    trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                    trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                }
                                else {
                                    trackcircuitAlive.push({
                                        key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await trackcircuit_compare_Relay(C5_data.slice(2, 12), trackcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let track_count = 1;
                                    const cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (cycle_index !== -1) {
                                        track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                        trackcircuitRelaydatas[cycle_index].value = track_count
                                    }
                                    else {
                                        if (trackcircuitWithoutArray === true) {
                                            var RelayDatas = [await TrackCircuitData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: trackcircuitid },
                                                raw: true
                                            })];
                                            RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                            if (RelayDatas.length > 0) {
                                                track_count = RelayDatas[0].count + 1
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                            }
                                            else {
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                        else {
                                            var RelayDatas = [await TrackCircuitRelayData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: parseInt(trackcircuitid) },
                                                raw: true
                                            })];
                                            RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                            if (RelayDatas.length > 0) {
                                                track_count = RelayDatas[0].count + 1
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                            }
                                            else {
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                    }

                                    let track_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        trackcircuitid: parseInt(trackcircuitid),
                                        trackcircuitterminal: trackterminal,
                                        trackname: register_trackid.trackname,
                                        count: track_count,
                                        feed_voltage: parseFloat(C5_data[2]).toFixed(alert_voldec_values),
                                        feed_current: parseFloat(C5_data[3]).toFixed(alert_curdec_values),
                                        choke_voltage: parseFloat(C5_data[4]).toFixed(alert_voldec_values),
                                        battery_charger_dc_current: parseFloat(C5_data[5]).toFixed(alert_curdec_values),
                                        battery_charger_dc_voltage: parseFloat(C5_data[6]).toFixed(alert_voldec_values),
                                        battery_charger_ac_voltage: parseFloat(C5_data[7]).toFixed(alert_voldec_values),
                                        battery_charger_ac_current: parseFloat(C5_data[8]).toFixed(alert_curdec_values),
                                        relay_voltage: parseFloat(C5_data[9]).toFixed(alert_voldec_values),
                                        relay_current: parseFloat(C5_data[10]).toFixed(alert_curdec_values),
                                        trv: parseFloat(C5_data[11]).toFixed(alert_voldec_values),
                                        createddate: current_datetime
                                    }
                                    //logs.info('TS_1R', track_data)
                                    if (cycle_index !== -1) {
                                        trackcircuitRelaydatas[cycle_index].data = track_data
                                    }
                                    else {
                                        trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                    }

                                    if (trackcircuitWithoutArray === true) {
                                        insert_relaytrack_array(track_data);
                                    }
                                    else {
                                        let transaction = await db.transaction({ autocommit: false });
                                        try {
                                            const tc_f_data_insert = await TrackCircuitRelayData.create(
                                                track_data,
                                                { transaction: transaction },
                                                { returning: true }
                                            );

                                            await transaction.commit();
                                            insert_relaytrack_array(track_data);
                                            logs.info("Track relay data inserted");
                                            //console.log("Track relay data inserted");
                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/TS_1R ' + ex);
                                            //console.log('mqtt error stationdata/TS_1R ' + ex);
                                        }
                                    }
                                }
                            }
                        }

                        var allzero = C5_data.slice(60, 70).every(x => x === '0')

                        var trackcircuitid = parseInt(C5_data[59]).toString(16).split("")[0];
                        var trackterminal = String.fromCharCode(parseInt((parseInt(C5_data[59]).toString(16).split("")[1] + parseInt(C5_data[59]).toString(16).split("")[2]), 16))

                        var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                if (index !== -1) {
                                    trackcircuitAlive[index].value = moment()
                                    trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                    trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                }
                                else {
                                    trackcircuitAlive.push({
                                        key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await trackcircuit_compare_Feeder(C5_data.slice(60, 70), trackcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let track_count = 1;
                                    const cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (cycle_index !== -1) {
                                        track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                        trackcircuitFeederdatas[cycle_index].value = track_count
                                    }
                                    else {
                                        if (trackcircuitWithoutArray === true) {
                                            var FeederDatas = [await TrackCircuitData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: trackcircuitid },
                                                raw: true
                                            })];
                                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                            if (FeederDatas.length > 0) {
                                                track_count = FeederDatas[0].feed_count + 1
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                            }
                                            else {
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                        else {
                                            var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: parseInt(trackcircuitid) },
                                                raw: true
                                            })];
                                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                            if (FeederDatas.length > 0) {
                                                track_count = FeederDatas[0].count + 1
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                            }
                                            else {
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                    }

                                    let track_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: asserts.id,
                                        assertname: asserts.assertname,
                                        trackcircuitid: parseInt(trackcircuitid),
                                        trackcircuitterminal: trackterminal,
                                        trackname: register_trackid.trackname,
                                        count: track_count,
                                        feed_voltage: parseFloat(C5_data[60]).toFixed(alert_voldec_values),
                                        feed_current: parseFloat(C5_data[61]).toFixed(alert_curdec_values),
                                        choke_voltage: parseFloat(C5_data[62]).toFixed(alert_voldec_values),
                                        battery_charger_dc_current: parseFloat(C5_data[63]).toFixed(alert_curdec_values),
                                        battery_charger_dc_voltage: parseFloat(C5_data[64]).toFixed(alert_voldec_values),
                                        battery_charger_ac_voltage: parseFloat(C5_data[65]).toFixed(alert_voldec_values),
                                        battery_charger_ac_current: parseFloat(C5_data[66]).toFixed(alert_curdec_values),
                                        relay_voltage: parseFloat(C5_data[67]).toFixed(alert_voldec_values),
                                        relay_current: parseFloat(C5_data[68]).toFixed(alert_curdec_values),
                                        trv: parseFloat(C5_data[69]).toFixed(alert_voldec_values),
                                        createddate: current_datetime
                                    }
                                    //logs.info('TS_1F', track_data)
                                    if (cycle_index != -1) {
                                        trackcircuitFeederdatas[cycle_index].data = track_data
                                    }
                                    else {
                                        trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                    }

                                    if (trackcircuitWithoutArray === true) {
                                        insert_feedertrack_array(track_data);
                                    }
                                    else {
                                        let transaction = await db.transaction({ autocommit: false });
                                        try {
                                            const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                track_data,
                                                { transaction: transaction },
                                                { returning: true }
                                            );
                                            await transaction.commit();
                                            insert_feedertrack_array(track_data);
                                            logs.info("Track feeder data inserted");
                                            //console.log("Track feeder data inserted");
                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/TS_1F ' + ex);
                                            //console.log('mqtt error stationdata/TS_1F ' + ex);
                                        }
                                    }
                                }
                            }
                        }

                        var allzero = C5_data.slice(94, 104).every(x => x === '0')

                        var trackcircuitid = parseInt(C5_data[93]).toString(16).split("")[0];
                        var trackterminal = String.fromCharCode(parseInt((parseInt(C5_data[93]).toString(16).split("")[1] + parseInt(C5_data[93]).toString(16).split("")[2]), 16))

                        var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                if (index !== -1) {
                                    trackcircuitAlive[index].value = moment()
                                    trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                    trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                }
                                else {
                                    trackcircuitAlive.push({
                                        key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await trackcircuit_compare_Relay(C5_data.slice(94, 104), trackcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let track_count = 1;
                                    const cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (cycle_index !== -1) {
                                        track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                        trackcircuitRelaydatas[cycle_index].value = track_count
                                    }
                                    else {
                                        if (trackcircuitWithoutArray === true) {
                                            var RelayDatas = [await TrackCircuitData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: trackcircuitid },
                                                raw: true
                                            })];
                                            RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                            if (RelayDatas.length > 0) {
                                                track_count = RelayDatas[0].count + 1
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                            }
                                            else {
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                        else {
                                            var RelayDatas = [await TrackCircuitRelayData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: parseInt(trackcircuitid) },
                                                raw: true
                                            })];
                                            RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                            if (RelayDatas.length > 0) {
                                                track_count = RelayDatas[0].count + 1
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                            }
                                            else {
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                    }

                                    let track_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        trackcircuitid: parseInt(trackcircuitid),
                                        trackcircuitterminal: trackterminal,
                                        trackname: register_trackid.trackname,
                                        count: track_count,
                                        feed_voltage: parseFloat(C5_data[94]).toFixed(alert_voldec_values),
                                        feed_current: parseFloat(C5_data[95]).toFixed(alert_curdec_values),
                                        choke_voltage: parseFloat(C5_data[96]).toFixed(alert_voldec_values),
                                        battery_charger_dc_current: parseFloat(C5_data[97]).toFixed(alert_curdec_values),
                                        battery_charger_dc_voltage: parseFloat(C5_data[98]).toFixed(alert_voldec_values),
                                        battery_charger_ac_voltage: parseFloat(C5_data[99]).toFixed(alert_voldec_values),
                                        battery_charger_ac_current: parseFloat(C5_data[100]).toFixed(alert_curdec_values),
                                        relay_voltage: parseFloat(C5_data[101]).toFixed(alert_voldec_values),
                                        relay_current: parseFloat(C5_data[102]).toFixed(alert_curdec_values),
                                        trv: parseFloat(C5_data[103]).toFixed(alert_voldec_values),
                                        createddate: current_datetime
                                    }
                                    //logs.info('TS_1R', track_data)
                                    if (cycle_index !== -1) {
                                        trackcircuitRelaydatas[cycle_index].data = track_data
                                    }
                                    else {
                                        trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                    }

                                    if (trackcircuitWithoutArray === true) {
                                        insert_relaytrack_array(track_data);
                                    }
                                    else {
                                        let transaction = await db.transaction({ autocommit: false });
                                        try {
                                            const tc_f_data_insert = await TrackCircuitRelayData.create(
                                                track_data,
                                                { transaction: transaction },
                                                { returning: true }
                                            );

                                            await transaction.commit();
                                            insert_relaytrack_array(track_data);
                                            logs.info("Track relay data inserted");
                                            //console.log("Track relay data inserted");
                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/TS_1R ' + ex);
                                            //console.log('mqtt error stationdata/TS_1R ' + ex);
                                        }
                                    }
                                }
                            }
                        }

                        var allzero = C5_data.slice(38, 46).every(x => x === '0')

                        var signalcircuitid = parseInt(parseInt(C5_data[37]).toString(16).split("")[0], 16);
                        var signalterminal = String.fromCharCode(parseInt((parseInt(C5_data[37]).toString(16).split("")[1] + parseInt(C5_data[37]).toString(16).split("")[2]), 16))

                        var register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                        if (register_signalid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                            const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_signalalive_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)

                                var index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });
                                if (index !== -1) {
                                    signalcircuitAlive[index].value = moment()
                                    signalcircuitAlive[index].alive_limit = moment().add(parseInt(alert_signalalive_values.value), 'seconds')
                                    signalcircuitAlive[index].message = await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit)
                                }
                                else {
                                    signalcircuitAlive.push({
                                        key: signalcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_signalalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit), mode: alert_signalalive_values.mode, id: alert_signalalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_signalid.signalname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SIGNAL_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await signalcircuit_compare(C5_data.slice(38, 46), signalcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let signal_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        signalcircuitid: parseInt(signalcircuitid),
                                        signalname: register_signalid.signalname,
                                        terminal: signalterminal,
                                        aspecttypeid: register_signalid.aspecttypeid,
                                        description: signalaspects.description,
                                        greenvoltage: parseFloat(C5_data[38]).toFixed(alert_voldec_values),
                                        greencurrent: parseFloat(C5_data[39]).toFixed(alert_curdec_values),
                                        redvoltage: parseFloat(C5_data[40]).toFixed(alert_voldec_values),
                                        redcurrent: parseFloat(C5_data[41]).toFixed(alert_curdec_values),
                                        yellowvoltage: parseFloat(C5_data[42]).toFixed(alert_voldec_values),
                                        yellowcurrent: parseFloat(C5_data[43]).toFixed(alert_curdec_values),
                                        lightyellowvoltage: parseFloat(C5_data[44]).toFixed(alert_voldec_values),
                                        lightyellowcurrent: parseFloat(C5_data[45]).toFixed(alert_curdec_values),
                                        createddate: current_datetime
                                    }

                                    await insert_signalcircuit(signal_data)

                                    //logs.info('TS_1F', signal_data)        
                                }

                            }
                        }

                        var allzero = C5_data.slice(84, 92).every(x => x === '0')

                        var signalcircuitid = parseInt(parseInt(C5_data[83]).toString(16).split("")[0], 16);
                        var signalterminal = String.fromCharCode(parseInt((parseInt(C5_data[83]).toString(16).split("")[1] + parseInt(C5_data[83]).toString(16).split("")[2]), 16))

                        var register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                        if (register_signalid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                            const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_signalalive_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)

                                var index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });
                                if (index !== -1) {
                                    signalcircuitAlive[index].value = moment()
                                    signalcircuitAlive[index].alive_limit = moment().add(parseInt(alert_signalalive_values.value), 'seconds')
                                    signalcircuitAlive[index].message = await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit)
                                }
                                else {
                                    signalcircuitAlive.push({
                                        key: signalcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_signalalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit), mode: alert_signalalive_values.mode, id: alert_signalalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_signalid.signalname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SIGNAL_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await signalcircuit_compare(C5_data.slice(84, 92), signalcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let signal_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        signalcircuitid: parseInt(signalcircuitid),
                                        signalname: register_signalid.signalname,
                                        terminal: signalterminal,
                                        aspecttypeid: register_signalid.aspecttypeid,
                                        description: signalaspects.description,
                                        greenvoltage: parseFloat(C5_data[84]).toFixed(alert_voldec_values),
                                        greencurrent: parseFloat(C5_data[85]).toFixed(alert_curdec_values),
                                        redvoltage: parseFloat(C5_data[86]).toFixed(alert_voldec_values),
                                        redcurrent: parseFloat(C5_data[87]).toFixed(alert_curdec_values),
                                        yellowvoltage: parseFloat(C5_data[88]).toFixed(alert_voldec_values),
                                        yellowcurrent: parseFloat(C5_data[89]).toFixed(alert_curdec_values),
                                        lightyellowvoltage: parseFloat(C5_data[90]).toFixed(alert_voldec_values),
                                        lightyellowcurrent: parseFloat(C5_data[91]).toFixed(alert_curdec_values),
                                        createddate: current_datetime
                                    }

                                    await insert_signalcircuit(signal_data)

                                    //logs.info('TS_1F', signal_data)        
                                }

                            }
                        }

                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/C5 ' + ex);
                        //console.log('mqtt error stationdata/C5 ' + ex);
                    }
                }
            });
        });

        // Active - Cluster 6
        client.subscribe('stationdata/C6', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/C6') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/C6', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/C6', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var C6_data = packet.payload.toString().split(',');
                        logs.info('stationdata/C6', C6_data)

                        //L8,L8A,L10A
                        var track_feeder = ""
                        var allzero = C6_data.slice(70, 80).every(x => x === '0')

                        var trackcircuitid = parseInt(C6_data[69]).toString(16).split("")[0];
                        var trackterminal = String.fromCharCode(parseInt((parseInt(C6_data[69]).toString(16).split("")[1] + parseInt(C6_data[69]).toString(16).split("")[2]), 16))

                        var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                if (index !== -1) {
                                    trackcircuitAlive[index].value = moment()
                                    trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                    trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                }
                                else {
                                    trackcircuitAlive.push({
                                        key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await trackcircuit_compare_Feeder(C6_data.slice(70, 80), trackcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let track_count = 1;
                                    const cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (cycle_index !== -1) {
                                        track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                        trackcircuitFeederdatas[cycle_index].value = track_count
                                    }
                                    else {
                                        if (trackcircuitWithoutArray === true) {
                                            var FeederDatas = [await TrackCircuitData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: trackcircuitid },
                                                raw: true
                                            })];
                                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                            if (FeederDatas.length > 0) {
                                                track_count = FeederDatas[0].feed_count + 1
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                            }
                                            else {
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                        else {
                                            var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: parseInt(trackcircuitid) },
                                                raw: true
                                            })];
                                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                            if (FeederDatas.length > 0) {
                                                track_count = FeederDatas[0].count + 1
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                            }
                                            else {
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                    }

                                    let track_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: asserts.id,
                                        assertname: asserts.assertname,
                                        trackcircuitid: parseInt(trackcircuitid),
                                        trackcircuitterminal: trackterminal,
                                        trackname: register_trackid.trackname,
                                        count: track_count,
                                        feed_voltage: parseFloat(C6_data[70]).toFixed(alert_voldec_values),
                                        feed_current: parseFloat(C6_data[71]).toFixed(alert_curdec_values),
                                        choke_voltage: parseFloat(C6_data[72]).toFixed(alert_voldec_values),
                                        battery_charger_dc_current: parseFloat(C6_data[73]).toFixed(alert_curdec_values),
                                        battery_charger_dc_voltage: parseFloat(C6_data[74]).toFixed(alert_voldec_values),
                                        battery_charger_ac_voltage: parseFloat(C6_data[75]).toFixed(alert_voldec_values),
                                        battery_charger_ac_current: parseFloat(C6_data[76]).toFixed(alert_curdec_values),
                                        relay_voltage: parseFloat(C6_data[77]).toFixed(alert_voldec_values),
                                        relay_current: parseFloat(C6_data[78]).toFixed(alert_curdec_values),
                                        trv: parseFloat(C6_data[79]).toFixed(alert_voldec_values),
                                        createddate: current_datetime
                                    }
                                    //logs.info('TS_1F', track_data)
                                    if (cycle_index != -1) {
                                        trackcircuitFeederdatas[cycle_index].data = track_data
                                    }
                                    else {
                                        trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                    }

                                    if (trackcircuitWithoutArray === true) {
                                        insert_feedertrack_array(track_data);
                                    }
                                    else {
                                        let transaction = await db.transaction({ autocommit: false });
                                        try {
                                            const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                track_data,
                                                { transaction: transaction },
                                                { returning: true }
                                            );
                                            await transaction.commit();
                                            track_feeder = track_data
                                            //insert_feedertrack_array(track_data);
                                            logs.info("Track feeder data inserted");
                                            //console.log("Track feeder data inserted");
                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/TS_1F ' + ex);
                                            //console.log('mqtt error stationdata/TS_1F ' + ex);
                                        }
                                    }
                                }
                            }
                        }

                        var track_relay = ""
                        var allzero = C6_data.slice(46, 56).every(x => x === '0')

                        var trackcircuitid = parseInt(C6_data[45]).toString(16).split("")[0];
                        var trackterminal = String.fromCharCode(parseInt((parseInt(C6_data[45]).toString(16).split("")[1] + parseInt(C6_data[45]).toString(16).split("")[2]), 16))

                        var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                if (index !== -1) {
                                    trackcircuitAlive[index].value = moment()
                                    trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                    trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                }
                                else {
                                    trackcircuitAlive.push({
                                        key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await trackcircuit_compare_Relay(C6_data.slice(46, 56), trackcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let track_count = 1;
                                    const cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (cycle_index !== -1) {
                                        track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                        trackcircuitRelaydatas[cycle_index].value = track_count
                                    }
                                    else {
                                        if (trackcircuitWithoutArray === true) {
                                            var RelayDatas = [await TrackCircuitData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: trackcircuitid },
                                                raw: true
                                            })];
                                            RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                            if (RelayDatas.length > 0) {
                                                track_count = RelayDatas[0].count + 1
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                            }
                                            else {
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                        else {
                                            var RelayDatas = [await TrackCircuitRelayData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: parseInt(trackcircuitid) },
                                                raw: true
                                            })];
                                            RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                            if (RelayDatas.length > 0) {
                                                track_count = RelayDatas[0].count + 1
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                            }
                                            else {
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                    }

                                    let track_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        trackcircuitid: parseInt(trackcircuitid),
                                        trackcircuitterminal: trackterminal,
                                        trackname: register_trackid.trackname,
                                        count: track_count,
                                        feed_voltage: parseFloat(C6_data[46]).toFixed(alert_voldec_values),
                                        feed_current: parseFloat(C6_data[47]).toFixed(alert_curdec_values),
                                        choke_voltage: parseFloat(C6_data[48]).toFixed(alert_voldec_values),
                                        battery_charger_dc_current: parseFloat(C6_data[49]).toFixed(alert_curdec_values),
                                        battery_charger_dc_voltage: parseFloat(C6_data[50]).toFixed(alert_voldec_values),
                                        battery_charger_ac_voltage: parseFloat(C6_data[51]).toFixed(alert_voldec_values),
                                        battery_charger_ac_current: parseFloat(C6_data[52]).toFixed(alert_curdec_values),
                                        relay_voltage: parseFloat(C6_data[53]).toFixed(alert_voldec_values),
                                        relay_current: parseFloat(C6_data[54]).toFixed(alert_curdec_values),
                                        trv: parseFloat(C6_data[55]).toFixed(alert_voldec_values),
                                        createddate: current_datetime
                                    }
                                    //logs.info('TS_1R', track_data)
                                    if (cycle_index !== -1) {
                                        trackcircuitRelaydatas[cycle_index].data = track_data
                                    }
                                    else {
                                        trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                    }

                                    if (trackcircuitWithoutArray === true) {
                                        insert_relaytrack_array(track_data);
                                    }
                                    else {
                                        let transaction = await db.transaction({ autocommit: false });
                                        try {
                                            const tc_f_data_insert = await TrackCircuitRelayData.create(
                                                track_data,
                                                { transaction: transaction },
                                                { returning: true }
                                            );

                                            await transaction.commit();
                                            track_relay = track_data
                                            //insert_relaytrack_array(track_data);
                                            logs.info("Track relay data inserted");
                                            //console.log("Track relay data inserted");
                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/TS_1R ' + ex);
                                            //console.log('mqtt error stationdata/TS_1R ' + ex);
                                        }
                                    }
                                }
                            }
                        }

                        track_feeder != "" || track_relay != "" ? insert_feederrelaytrack_both(track_feeder, track_relay) : ""

                        var track_feeder = ""
                        var allzero = C6_data.slice(82, 92).every(x => x === '0')

                        var trackcircuitid = parseInt(C6_data[81]).toString(16).split("")[0];
                        var trackterminal = String.fromCharCode(parseInt((parseInt(C6_data[81]).toString(16).split("")[1] + parseInt(C6_data[81]).toString(16).split("")[2]), 16))

                        var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                if (index !== -1) {
                                    trackcircuitAlive[index].value = moment()
                                    trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                    trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                }
                                else {
                                    trackcircuitAlive.push({
                                        key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await trackcircuit_compare_Feeder(C6_data.slice(82, 92), trackcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let track_count = 1;
                                    const cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (cycle_index !== -1) {
                                        track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                        trackcircuitFeederdatas[cycle_index].value = track_count
                                    }
                                    else {
                                        if (trackcircuitWithoutArray === true) {
                                            var FeederDatas = [await TrackCircuitData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: trackcircuitid },
                                                raw: true
                                            })];
                                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                            if (FeederDatas.length > 0) {
                                                track_count = FeederDatas[0].feed_count + 1
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                            }
                                            else {
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                        else {
                                            var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: parseInt(trackcircuitid) },
                                                raw: true
                                            })];
                                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                            if (FeederDatas.length > 0) {
                                                track_count = FeederDatas[0].count + 1
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                            }
                                            else {
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                    }

                                    let track_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: asserts.id,
                                        assertname: asserts.assertname,
                                        trackcircuitid: parseInt(trackcircuitid),
                                        trackcircuitterminal: trackterminal,
                                        trackname: register_trackid.trackname,
                                        count: track_count,
                                        feed_voltage: parseFloat(C6_data[82]).toFixed(alert_voldec_values),
                                        feed_current: parseFloat(C6_data[83]).toFixed(alert_curdec_values),
                                        choke_voltage: parseFloat(C6_data[84]).toFixed(alert_voldec_values),
                                        battery_charger_dc_current: parseFloat(C6_data[85]).toFixed(alert_curdec_values),
                                        battery_charger_dc_voltage: parseFloat(C6_data[86]).toFixed(alert_voldec_values),
                                        battery_charger_ac_voltage: parseFloat(C6_data[87]).toFixed(alert_voldec_values),
                                        battery_charger_ac_current: parseFloat(C6_data[88]).toFixed(alert_curdec_values),
                                        relay_voltage: parseFloat(C6_data[89]).toFixed(alert_voldec_values),
                                        relay_current: parseFloat(C6_data[90]).toFixed(alert_curdec_values),
                                        trv: parseFloat(C6_data[91]).toFixed(alert_voldec_values),
                                        createddate: current_datetime
                                    }
                                    //logs.info('TS_1F', track_data)
                                    if (cycle_index != -1) {
                                        trackcircuitFeederdatas[cycle_index].data = track_data
                                    }
                                    else {
                                        trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                    }

                                    if (trackcircuitWithoutArray === true) {
                                        insert_feedertrack_array(track_data);
                                    }
                                    else {
                                        let transaction = await db.transaction({ autocommit: false });
                                        try {
                                            const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                track_data,
                                                { transaction: transaction },
                                                { returning: true }
                                            );
                                            await transaction.commit();
                                            track_feeder = track_data
                                            //insert_feedertrack_array(track_data);
                                            logs.info("Track feeder data inserted");
                                            //console.log("Track feeder data inserted");
                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/TS_1F ' + ex);
                                            //console.log('mqtt error stationdata/TS_1F ' + ex);
                                        }
                                    }
                                }
                            }
                        }

                        var track_relay = ""
                        var allzero = C6_data.slice(58, 68).every(x => x === '0')

                        var trackcircuitid = parseInt(C6_data[57]).toString(16).split("")[0];
                        var trackterminal = String.fromCharCode(parseInt((parseInt(C6_data[57]).toString(16).split("")[1] + parseInt(C6_data[57]).toString(16).split("")[2]), 16))

                        var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                if (index !== -1) {
                                    trackcircuitAlive[index].value = moment()
                                    trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                    trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                }
                                else {
                                    trackcircuitAlive.push({
                                        key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await trackcircuit_compare_Relay(C6_data.slice(58, 68), trackcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let track_count = 1;
                                    const cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (cycle_index !== -1) {
                                        track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                        trackcircuitRelaydatas[cycle_index].value = track_count
                                    }
                                    else {
                                        if (trackcircuitWithoutArray === true) {
                                            var RelayDatas = [await TrackCircuitData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: trackcircuitid },
                                                raw: true
                                            })];
                                            RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                            if (RelayDatas.length > 0) {
                                                track_count = RelayDatas[0].count + 1
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                            }
                                            else {
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                        else {
                                            var RelayDatas = [await TrackCircuitRelayData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: parseInt(trackcircuitid) },
                                                raw: true
                                            })];
                                            RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                            if (RelayDatas.length > 0) {
                                                track_count = RelayDatas[0].count + 1
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                            }
                                            else {
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                    }

                                    let track_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        trackcircuitid: parseInt(trackcircuitid),
                                        trackcircuitterminal: trackterminal,
                                        trackname: register_trackid.trackname,
                                        count: track_count,
                                        feed_voltage: parseFloat(C6_data[58]).toFixed(alert_voldec_values),
                                        feed_current: parseFloat(C6_data[59]).toFixed(alert_curdec_values),
                                        choke_voltage: parseFloat(C6_data[60]).toFixed(alert_voldec_values),
                                        battery_charger_dc_current: parseFloat(C6_data[61]).toFixed(alert_curdec_values),
                                        battery_charger_dc_voltage: parseFloat(C6_data[62]).toFixed(alert_voldec_values),
                                        battery_charger_ac_voltage: parseFloat(C6_data[63]).toFixed(alert_voldec_values),
                                        battery_charger_ac_current: parseFloat(C6_data[64]).toFixed(alert_curdec_values),
                                        relay_voltage: parseFloat(C6_data[65]).toFixed(alert_voldec_values),
                                        relay_current: parseFloat(C6_data[66]).toFixed(alert_curdec_values),
                                        trv: parseFloat(C6_data[67]).toFixed(alert_voldec_values),
                                        createddate: current_datetime
                                    }
                                    //logs.info('TS_1R', track_data)
                                    if (cycle_index !== -1) {
                                        trackcircuitRelaydatas[cycle_index].data = track_data
                                    }
                                    else {
                                        trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                    }

                                    if (trackcircuitWithoutArray === true) {
                                        insert_relaytrack_array(track_data);
                                    }
                                    else {
                                        let transaction = await db.transaction({ autocommit: false });
                                        try {
                                            const tc_f_data_insert = await TrackCircuitRelayData.create(
                                                track_data,
                                                { transaction: transaction },
                                                { returning: true }
                                            );

                                            await transaction.commit();
                                            track_relay = track_data
                                            //insert_relaytrack_array(track_data);
                                            logs.info("Track relay data inserted");
                                            //console.log("Track relay data inserted");
                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/TS_1R ' + ex);
                                            //console.log('mqtt error stationdata/TS_1R ' + ex);
                                        }
                                    }
                                }
                            }
                        }

                        track_feeder != "" || track_relay != "" ? insert_feederrelaytrack_both(track_feeder, track_relay) : ""

                        var allzero = C6_data.slice(12, 22).every(x => x === '0')

                        var trackcircuitid = parseInt(C6_data[11]).toString(16).split("")[0];
                        var trackterminal = String.fromCharCode(parseInt((parseInt(C6_data[11]).toString(16).split("")[1] + parseInt(C6_data[11]).toString(16).split("")[2]), 16))

                        var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                if (index !== -1) {
                                    trackcircuitAlive[index].value = moment()
                                    trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                    trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                }
                                else {
                                    trackcircuitAlive.push({
                                        key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await trackcircuit_compare_Relay(C6_data.slice(12, 22), trackcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let track_count = 1;
                                    const cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (cycle_index !== -1) {
                                        track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                        trackcircuitRelaydatas[cycle_index].value = track_count
                                    }
                                    else {
                                        if (trackcircuitWithoutArray === true) {
                                            var RelayDatas = [await TrackCircuitData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: trackcircuitid },
                                                raw: true
                                            })];
                                            RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                            if (RelayDatas.length > 0) {
                                                track_count = RelayDatas[0].count + 1
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                            }
                                            else {
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                        else {
                                            var RelayDatas = [await TrackCircuitRelayData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: parseInt(trackcircuitid) },
                                                raw: true
                                            })];
                                            RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                            if (RelayDatas.length > 0) {
                                                track_count = RelayDatas[0].count + 1
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                            }
                                            else {
                                                trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                    }

                                    let track_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        trackcircuitid: parseInt(trackcircuitid),
                                        trackcircuitterminal: trackterminal,
                                        trackname: register_trackid.trackname,
                                        count: track_count,
                                        feed_voltage: parseFloat(C6_data[12]).toFixed(alert_voldec_values),
                                        feed_current: parseFloat(C6_data[13]).toFixed(alert_curdec_values),
                                        choke_voltage: parseFloat(C6_data[14]).toFixed(alert_voldec_values),
                                        battery_charger_dc_current: parseFloat(C6_data[15]).toFixed(alert_curdec_values),
                                        battery_charger_dc_voltage: parseFloat(C6_data[16]).toFixed(alert_voldec_values),
                                        battery_charger_ac_voltage: parseFloat(C6_data[17]).toFixed(alert_voldec_values),
                                        battery_charger_ac_current: parseFloat(C6_data[18]).toFixed(alert_curdec_values),
                                        relay_voltage: parseFloat(C6_data[19]).toFixed(alert_voldec_values),
                                        relay_current: parseFloat(C6_data[20]).toFixed(alert_curdec_values),
                                        trv: parseFloat(C6_data[21]).toFixed(alert_voldec_values),
                                        createddate: current_datetime
                                    }
                                    //logs.info('TS_1R', track_data)
                                    if (cycle_index !== -1) {
                                        trackcircuitRelaydatas[cycle_index].data = track_data
                                    }
                                    else {
                                        trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                    }

                                    if (trackcircuitWithoutArray === true) {
                                        insert_relaytrack_array(track_data);
                                    }
                                    else {
                                        let transaction = await db.transaction({ autocommit: false });
                                        try {
                                            const tc_f_data_insert = await TrackCircuitRelayData.create(
                                                track_data,
                                                { transaction: transaction },
                                                { returning: true }
                                            );

                                            await transaction.commit();
                                            insert_relaytrack_array(track_data);
                                            logs.info("Track relay data inserted");
                                            //console.log("Track relay data inserted");
                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/TS_1R ' + ex);
                                            //console.log('mqtt error stationdata/TS_1R ' + ex);
                                        }
                                    }
                                }
                            }
                        }

                        var allzero = C6_data.slice(24, 34).every(x => x === '0')

                        var trackcircuitid = parseInt(C6_data[23]).toString(16).split("")[0];
                        var trackterminal = String.fromCharCode(parseInt((parseInt(C6_data[23]).toString(16).split("")[1] + parseInt(C6_data[23]).toString(16).split("")[2]), 16))

                        var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                if (index !== -1) {
                                    trackcircuitAlive[index].value = moment()
                                    trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                    trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                }
                                else {
                                    trackcircuitAlive.push({
                                        key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await trackcircuit_compare_Feeder(C6_data.slice(24, 34), trackcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let track_count = 1;
                                    const cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (cycle_index !== -1) {
                                        track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                        trackcircuitFeederdatas[cycle_index].value = track_count
                                    }
                                    else {
                                        if (trackcircuitWithoutArray === true) {
                                            var FeederDatas = [await TrackCircuitData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: trackcircuitid },
                                                raw: true
                                            })];
                                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                            if (FeederDatas.length > 0) {
                                                track_count = FeederDatas[0].feed_count + 1
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                            }
                                            else {
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                        else {
                                            var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                limit: 1,
                                                order: [["id", "DESC"]],
                                                where: { trackcircuitid: parseInt(trackcircuitid) },
                                                raw: true
                                            })];
                                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                            if (FeederDatas.length > 0) {
                                                track_count = FeederDatas[0].count + 1
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                            }
                                            else {
                                                trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                            }
                                        }
                                    }

                                    let track_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: asserts.id,
                                        assertname: asserts.assertname,
                                        trackcircuitid: parseInt(trackcircuitid),
                                        trackcircuitterminal: trackterminal,
                                        trackname: register_trackid.trackname,
                                        count: track_count,
                                        feed_voltage: parseFloat(C6_data[24]).toFixed(alert_voldec_values),
                                        feed_current: parseFloat(C6_data[25]).toFixed(alert_curdec_values),
                                        choke_voltage: parseFloat(C6_data[26]).toFixed(alert_voldec_values),
                                        battery_charger_dc_current: parseFloat(C6_data[27]).toFixed(alert_curdec_values),
                                        battery_charger_dc_voltage: parseFloat(C6_data[28]).toFixed(alert_voldec_values),
                                        battery_charger_ac_voltage: parseFloat(C6_data[29]).toFixed(alert_voldec_values),
                                        battery_charger_ac_current: parseFloat(C6_data[30]).toFixed(alert_curdec_values),
                                        relay_voltage: parseFloat(C6_data[31]).toFixed(alert_voldec_values),
                                        relay_current: parseFloat(C6_data[32]).toFixed(alert_curdec_values),
                                        trv: parseFloat(C6_data[33]).toFixed(alert_voldec_values),
                                        createddate: current_datetime
                                    }
                                    //logs.info('TS_1F', track_data)
                                    if (cycle_index != -1) {
                                        trackcircuitFeederdatas[cycle_index].data = track_data
                                    }
                                    else {
                                        trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                    }

                                    if (trackcircuitWithoutArray === true) {
                                        insert_feedertrack_array(track_data);
                                    }
                                    else {
                                        let transaction = await db.transaction({ autocommit: false });
                                        try {
                                            const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                track_data,
                                                { transaction: transaction },
                                                { returning: true }
                                            );
                                            await transaction.commit();
                                            insert_feedertrack_array(track_data);
                                            logs.info("Track feeder data inserted");
                                            //console.log("Track feeder data inserted");
                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/TS_1F ' + ex);
                                            //console.log('mqtt error stationdata/TS_1F ' + ex);
                                        }
                                    }
                                }
                            }
                        }

                        var allzero = C6_data.slice(2, 10).every(x => x === '0')

                        var signalcircuitid = parseInt(parseInt(C6_data[1]).toString(16).split("")[0], 16);
                        var signalterminal = String.fromCharCode(parseInt((parseInt(C6_data[1]).toString(16).split("")[1] + parseInt(C6_data[1]).toString(16).split("")[2]), 16))

                        var register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                        if (register_signalid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                            const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_signalalive_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)

                                var index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });
                                if (index !== -1) {
                                    signalcircuitAlive[index].value = moment()
                                    signalcircuitAlive[index].alive_limit = moment().add(parseInt(alert_signalalive_values.value), 'seconds')
                                    signalcircuitAlive[index].message = await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit)
                                }
                                else {
                                    signalcircuitAlive.push({
                                        key: signalcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_signalalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit), mode: alert_signalalive_values.mode, id: alert_signalalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_signalid.signalname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SIGNAL_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await signalcircuit_compare(C6_data.slice(2, 10), signalcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let signal_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        signalcircuitid: parseInt(signalcircuitid),
                                        signalname: register_signalid.signalname,
                                        terminal: signalterminal,
                                        aspecttypeid: register_signalid.aspecttypeid,
                                        description: signalaspects.description,
                                        greenvoltage: parseFloat(C6_data[2]).toFixed(alert_voldec_values),
                                        greencurrent: parseFloat(C6_data[3]).toFixed(alert_curdec_values),
                                        redvoltage: parseFloat(C6_data[4]).toFixed(alert_voldec_values),
                                        redcurrent: parseFloat(C6_data[5]).toFixed(alert_curdec_values),
                                        yellowvoltage: parseFloat(C6_data[6]).toFixed(alert_voldec_values),
                                        yellowcurrent: parseFloat(C6_data[7]).toFixed(alert_curdec_values),
                                        lightyellowvoltage: parseFloat(C6_data[8]).toFixed(alert_voldec_values),
                                        lightyellowcurrent: parseFloat(C6_data[9]).toFixed(alert_curdec_values),
                                        createddate: current_datetime
                                    }

                                    await insert_signalcircuit(signal_data)

                                    //logs.info('TS_1F', signal_data)        
                                }

                            }
                        }

                        var allzero = C6_data.slice(36, 44).every(x => x === '0')

                        var signalcircuitid = parseInt(parseInt(C6_data[35]).toString(16).split("")[0], 16);
                        var signalterminal = String.fromCharCode(parseInt((parseInt(C6_data[35]).toString(16).split("")[1] + parseInt(C6_data[35]).toString(16).split("")[2]), 16))

                        var register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                        if (register_signalid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                            const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_signalalive_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)

                                var index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });
                                if (index !== -1) {
                                    signalcircuitAlive[index].value = moment()
                                    signalcircuitAlive[index].alive_limit = moment().add(parseInt(alert_signalalive_values.value), 'seconds')
                                    signalcircuitAlive[index].message = await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit)
                                }
                                else {
                                    signalcircuitAlive.push({
                                        key: signalcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_signalalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit), mode: alert_signalalive_values.mode, id: alert_signalalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_signalid.signalname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SIGNAL_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await signalcircuit_compare(C6_data.slice(36, 44), signalcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let signal_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        signalcircuitid: parseInt(signalcircuitid),
                                        signalname: register_signalid.signalname,
                                        terminal: signalterminal,
                                        aspecttypeid: register_signalid.aspecttypeid,
                                        description: signalaspects.description,
                                        greenvoltage: parseFloat(C6_data[36]).toFixed(alert_voldec_values),
                                        greencurrent: parseFloat(C6_data[37]).toFixed(alert_curdec_values),
                                        redvoltage: parseFloat(C6_data[38]).toFixed(alert_voldec_values),
                                        redcurrent: parseFloat(C6_data[39]).toFixed(alert_curdec_values),
                                        yellowvoltage: parseFloat(C6_data[40]).toFixed(alert_voldec_values),
                                        yellowcurrent: parseFloat(C6_data[41]).toFixed(alert_curdec_values),
                                        lightyellowvoltage: parseFloat(C6_data[42]).toFixed(alert_voldec_values),
                                        lightyellowcurrent: parseFloat(C6_data[43]).toFixed(alert_curdec_values),
                                        createddate: current_datetime
                                    }

                                    await insert_signalcircuit(signal_data)

                                    //logs.info('TS_1F', signal_data)        
                                }

                            }
                        }

                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/C6 ' + ex);
                        //console.log('mqtt error stationdata/C6 ' + ex);
                    }
                }
            });
        });


        // Active- Cluster 1
        client.subscribe('stationdata/ct1', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/ct1') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/C1', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/C1', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var C1_data = packet.payload.toString().split(',');
                        logs.info('stationdata/C1', C1_data)

                        if (C1_data.length != 1) {

                            //O2TR
                            var allzero = C1_data.slice(2, 12).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C1_data[1]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C1_data[1]).toString(16).split("")[1] + parseInt(C1_data[1]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })
                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Relay(C1_data.slice(2, 12), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                            trackcircuitRelaydatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var RelayDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var RelayDatas = [await TrackCircuitRelayData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C1_data[2]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C1_data[3]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C1_data[4]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C1_data[5]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C1_data[6]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C1_data[7]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C1_data[8]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C1_data[9]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C1_data[10]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C1_data[11]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C1', track_data)
                                        cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitRelaydatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_relaytrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitRelayData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );

                                                await transaction.commit();
                                                insert_relaytrack_array(track_data);
                                                logs.info("Track relay data inserted");
                                                //console.log("Track relay data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C1 ' + ex);
                                                //console.log('mqtt error stationdata/C1 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            //30G
                            var allzero = C1_data.slice(14, 21).every(x => x === '0')

                            var signalcircuitid = parseInt(parseInt(C1_data[13]).toString(16).split("")[0], 16).toString();
                            var signalterminal = String.fromCharCode(parseInt((parseInt(C1_data[13]).toString(16).split("")[1] + parseInt(C1_data[13]).toString(16).split("")[2]), 16))

                            var register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                            if (register_signalid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                                const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_signalalive_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)

                                    var index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });
                                    if (index !== -1) {
                                        signalcircuitAlive[index].value = moment()
                                        signalcircuitAlive[index].alive_limit = moment().add(parseInt(alert_signalalive_values.value), 'seconds')
                                        signalcircuitAlive[index].message = await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit)
                                    }
                                    else {
                                        signalcircuitAlive.push({
                                            key: signalcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_signalalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit), mode: alert_signalalive_values.mode, id: alert_signalalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_signalid.signalname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SIGNAL_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await signalcircuit_compare(C1_data.slice(14, 22), signalcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let signal_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            signalcircuitid: parseInt(signalcircuitid),
                                            signalname: register_signalid.signalname,
                                            terminal: signalterminal,
                                            aspecttypeid: register_signalid.aspecttypeid,
                                            description: signalaspects.description,
                                            greenvoltage: parseFloat(C1_data[14]).toFixed(alert_voldec_values),
                                            greencurrent: parseFloat(C1_data[15]).toFixed(alert_curdec_values),
                                            redvoltage: parseFloat(C1_data[16]).toFixed(alert_voldec_values),
                                            redcurrent: parseFloat(C1_data[17]).toFixed(alert_curdec_values),
                                            yellowvoltage: parseFloat(C1_data[18]).toFixed(alert_voldec_values),
                                            yellowcurrent: parseFloat(C1_data[19]).toFixed(alert_curdec_values),
                                            lightyellowvoltage: parseFloat(C1_data[20]).toFixed(alert_voldec_values),
                                            lightyellowcurrent: parseFloat(C1_data[21]).toFixed(alert_curdec_values),
                                            whitevoltage: 0,
                                            whitecurrent: 0,
                                            createddate: current_datetime
                                        }
                                        await insert_signalcircuit_updated(signal_data)
                                    }
                                }
                            }

                            //01TF
                            var allzero = C1_data.slice(24, 34).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C1_data[23]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C1_data[23]).toString(16).split("")[1] + parseInt(C1_data[23]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Feeder(C1_data.slice(24, 34), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                            trackcircuitFeederdatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var FeederDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].feed_count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: asserts.id,
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C1_data[24]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C1_data[25]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C1_data[26]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C1_data[27]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C1_data[28]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C1_data[29]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C1_data[30]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C1_data[31]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C1_data[32]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C1_data[33]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C1', track_data)
                                        cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitFeederdatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_feedertrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );
                                                await transaction.commit();
                                                insert_feedertrack_array(track_data);
                                                logs.info("Track feeder data inserted");
                                                //console.log("Track feeder data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C1 ' + ex);
                                                //console.log('mqtt error stationdata/C1 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            //50BTR
                            var allzero = C1_data.slice(36, 46).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C1_data[35]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C1_data[35]).toString(16).split("")[1] + parseInt(C1_data[35]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })
                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Relay(C1_data.slice(36, 46), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                            trackcircuitRelaydatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var RelayDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var RelayDatas = [await TrackCircuitRelayData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C1_data[36]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C1_data[37]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C1_data[38]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C1_data[39]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C1_data[40]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C1_data[41]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C1_data[42]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C1_data[43]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C1_data[44]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C1_data[45]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C1', track_data)
                                        cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitRelaydatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_relaytrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitRelayData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );

                                                await transaction.commit();
                                                insert_relaytrack_array(track_data);
                                                logs.info("Track relay data inserted");
                                                //console.log("Track relay data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C1 ' + ex);
                                                //console.log('mqtt error stationdata/C1 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            //31G
                            var allzero = C1_data.slice(48, 56).every(x => x === '0')

                            var signalcircuitid = parseInt(parseInt(C1_data[47]).toString(16).split("")[0], 16).toString();
                            var signalterminal = String.fromCharCode(parseInt((parseInt(C1_data[47]).toString(16).split("")[1] + parseInt(C1_data[47]).toString(16).split("")[2]), 16))

                            var register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                            if (register_signalid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                                const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_signalalive_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)

                                    var index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });
                                    if (index !== -1) {
                                        signalcircuitAlive[index].value = moment()
                                        signalcircuitAlive[index].alive_limit = moment().add(parseInt(alert_signalalive_values.value), 'seconds')
                                        signalcircuitAlive[index].message = await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit)
                                    }
                                    else {
                                        signalcircuitAlive.push({
                                            key: signalcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_signalalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit), mode: alert_signalalive_values.mode, id: alert_signalalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_signalid.signalname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SIGNAL_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await signalcircuit_compare(C1_data.slice(48, 56), signalcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let signal_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            signalcircuitid: parseInt(signalcircuitid),
                                            signalname: register_signalid.signalname,
                                            terminal: signalterminal,
                                            aspecttypeid: register_signalid.aspecttypeid,
                                            description: signalaspects.description,
                                            greenvoltage: parseFloat(C1_data[48]).toFixed(alert_voldec_values),
                                            greencurrent: parseFloat(C1_data[49]).toFixed(alert_curdec_values),
                                            redvoltage: parseFloat(C1_data[50]).toFixed(alert_voldec_values),
                                            redcurrent: parseFloat(C1_data[51]).toFixed(alert_curdec_values),
                                            yellowvoltage: parseFloat(C1_data[52]).toFixed(alert_voldec_values),
                                            yellowcurrent: parseFloat(C1_data[53]).toFixed(alert_curdec_values),
                                            lightyellowvoltage: parseFloat(C1_data[54]).toFixed(alert_voldec_values),
                                            lightyellowcurrent: parseFloat(C1_data[55]).toFixed(alert_curdec_values),
                                            whitevoltage: 0,
                                            whitecurrent: 0,
                                            createddate: current_datetime
                                        }

                                        await insert_signalcircuit_updated(signal_data)

                                        //logs.info('C1', signal_data)        
                                    }

                                }
                            }

                            //50ATR
                            var allzero = C1_data.slice(58, C1_data.length).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C1_data[57]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C1_data[57]).toString(16).split("")[1] + parseInt(C1_data[57]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })
                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Relay(C1_data.slice(58, C1_data.length), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                            trackcircuitRelaydatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var RelayDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var RelayDatas = [await TrackCircuitRelayData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C1_data[58]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C1_data[59]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C1_data[60]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C1_data[61]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C1_data[62]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C1_data[63]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C1_data[64]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C1_data[65]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C1_data[66]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C1_data[67]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C1', track_data)
                                        cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitRelaydatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_relaytrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitRelayData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );

                                                await transaction.commit();
                                                insert_relaytrack_array(track_data);
                                                logs.info("Track relay data inserted");
                                                //console.log("Track relay data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C1 ' + ex);
                                                //console.log('mqtt error stationdata/C1 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/C1 ' + ex);
                        //console.log('mqtt error stationdata/C1 ' + ex);
                    }
                }
            });
        });

        // Active - Cluster 2
        client.subscribe('stationdata/ct2', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/ct2') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/C2', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/C2', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var C2_data = packet.payload.toString().split(',');
                        logs.info('stationdata/C2', C2_data)

                        if (C2_data.length != 1) {

                            //1TF  
                            var allzero = C2_data.slice(2, 12).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C2_data[1]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C2_data[1]).toString(16).split("")[1] + parseInt(C2_data[1]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Feeder(C2_data.slice(2, 12), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                            trackcircuitFeederdatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var FeederDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].feed_count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: asserts.id,
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C2_data[2]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C2_data[3]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C2_data[4]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C2_data[5]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C2_data[6]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C2_data[7]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C2_data[8]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C2_data[9]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C2_data[10]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C2_data[11]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C2', track_data)
                                        cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitFeederdatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_feedertrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );
                                                await transaction.commit();
                                                insert_feedertrack_array(track_data);
                                                logs.info("Track feeder data inserted");
                                                //console.log("Track feeder data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C2 ' + ex);
                                                //console.log('mqtt error stationdata/C2 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            //25TF 
                            var track_feeder = ""
                            var allzero = C2_data.slice(82, 92).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C2_data[81]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C2_data[81]).toString(16).split("")[1] + parseInt(C2_data[81]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Feeder(C2_data.slice(82, 92), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                            trackcircuitFeederdatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var FeederDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].feed_count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: asserts.id,
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C2_data[82]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C2_data[83]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C2_data[84]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C2_data[85]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C2_data[86]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C2_data[87]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C2_data[88]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C2_data[89]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C2_data[90]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C2_data[91]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C2', track_data)
                                        cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitFeederdatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_feedertrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );
                                                await transaction.commit();
                                                track_feeder = track_data
                                                //insert_feedertrack_array(track_data);
                                                logs.info("Track feeder data inserted");
                                                //console.log("Track feeder data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C2 ' + ex);
                                                //console.log('mqtt error stationdata/C2 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            //25TR 
                            var track_relay = ""
                            var allzero = C2_data.slice(14, 24).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C2_data[13]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C2_data[13]).toString(16).split("")[1] + parseInt(C2_data[13]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })
                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Relay(C2_data.slice(14, 24), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                            trackcircuitRelaydatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var RelayDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var RelayDatas = [await TrackCircuitRelayData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C2_data[14]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C2_data[15]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C2_data[16]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C2_data[17]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C2_data[18]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C2_data[19]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C2_data[20]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C2_data[21]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C2_data[22]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C2_data[23]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C2', track_data)
                                        cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitRelaydatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_relaytrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitRelayData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );

                                                await transaction.commit();
                                                track_relay = track_data
                                                //insert_relaytrack_array(track_data);
                                                logs.info("Track relay data inserted");
                                                //console.log("Track relay data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C2 ' + ex);
                                                //console.log('mqtt error stationdata/C2 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            track_feeder != "" || track_relay != "" ? insert_feederrelaytrack_both(track_feeder, track_relay) : ""

                            //C1TF  
                            var track_feeder = ""
                            var allzero = C2_data.slice(70, 80).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C2_data[69]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C2_data[69]).toString(16).split("")[1] + parseInt(C2_data[69]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Feeder(C2_data.slice(70, 80), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                            trackcircuitFeederdatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var FeederDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].feed_count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: asserts.id,
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C2_data[70]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C2_data[71]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C2_data[72]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C2_data[73]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C2_data[74]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C2_data[75]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C2_data[76]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C2_data[77]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C2_data[78]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C2_data[79]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C2', track_data)
                                        cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitFeederdatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_feedertrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );
                                                await transaction.commit();
                                                track_feeder = track_data
                                                //insert_feedertrack_array(track_data);
                                                logs.info("Track feeder data inserted");
                                                //console.log("Track feeder data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C2 ' + ex);
                                                //console.log('mqtt error stationdata/C2 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            //C1TR 
                            var track_relay = ""
                            var allzero = C2_data.slice(46, 56).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C2_data[45]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C2_data[45]).toString(16).split("")[1] + parseInt(C2_data[45]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })
                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Relay(C2_data.slice(46, 56), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                            trackcircuitRelaydatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var RelayDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var RelayDatas = [await TrackCircuitRelayData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C2_data[46]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C2_data[47]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C2_data[48]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C2_data[49]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C2_data[50]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C2_data[51]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C2_data[52]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C2_data[53]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C2_data[54]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C2_data[55]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C2', track_data)
                                        cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitRelaydatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_relaytrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitRelayData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );

                                                await transaction.commit();
                                                track_relay = track_data
                                                //insert_relaytrack_array(track_data);
                                                logs.info("Track relay data inserted");
                                                //console.log("Track relay data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C2 ' + ex);
                                                //console.log('mqtt error stationdata/C2 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            track_feeder != "" || track_relay != "" ? insert_feederrelaytrack_both(track_feeder, track_relay) : ""

                            //25G 
                            var allzero = C2_data.slice(26, 34).every(x => x === '0')

                            var signalcircuitid = parseInt(parseInt(C2_data[25]).toString(16).split("")[0], 16).toString();
                            var signalterminal = String.fromCharCode(parseInt((parseInt(C2_data[25]).toString(16).split("")[1] + parseInt(C2_data[25]).toString(16).split("")[2]), 16))

                            var register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                            if (register_signalid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                                const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_signalalive_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)

                                    var index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });
                                    if (index !== -1) {
                                        signalcircuitAlive[index].value = moment()
                                        signalcircuitAlive[index].alive_limit = moment().add(parseInt(alert_signalalive_values.value), 'seconds')
                                        signalcircuitAlive[index].message = await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit)
                                    }
                                    else {
                                        signalcircuitAlive.push({
                                            key: signalcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_signalalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit), mode: alert_signalalive_values.mode, id: alert_signalalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_signalid.signalname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SIGNAL_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await signalcircuit_compare(C2_data.slice(26, 34), signalcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let signal_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            signalcircuitid: parseInt(signalcircuitid),
                                            signalname: register_signalid.signalname,
                                            terminal: signalterminal,
                                            aspecttypeid: register_signalid.aspecttypeid,
                                            description: signalaspects.description,
                                            greenvoltage: parseFloat(C2_data[26]).toFixed(alert_voldec_values),
                                            greencurrent: parseFloat(C2_data[27]).toFixed(alert_curdec_values),
                                            redvoltage: parseFloat(C2_data[28]).toFixed(alert_voldec_values),
                                            redcurrent: parseFloat(C2_data[29]).toFixed(alert_curdec_values),
                                            yellowvoltage: parseFloat(C2_data[30]).toFixed(alert_voldec_values),
                                            yellowcurrent: parseFloat(C2_data[31]).toFixed(alert_curdec_values),
                                            lightyellowvoltage: parseFloat(C2_data[32]).toFixed(alert_voldec_values),
                                            lightyellowcurrent: parseFloat(C2_data[33]).toFixed(alert_curdec_values),
                                            whitevoltage: 0,
                                            whitecurrent: 0,
                                            createddate: current_datetime
                                        }

                                        await insert_signalcircuit_updated(signal_data)

                                        //logs.info('C2', signal_data)        
                                    }

                                }
                            }

                            //1DG 
                            var allzero = C2_data.slice(36, 44).every(x => x === '0')

                            var signalcircuitid = parseInt(parseInt(C2_data[35]).toString(16).split("")[0], 16).toString();
                            var signalterminal = String.fromCharCode(parseInt((parseInt(C2_data[35]).toString(16).split("")[1] + parseInt(C2_data[35]).toString(16).split("")[2]), 16))

                            var register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                            if (register_signalid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                                const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_signalalive_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)

                                    var index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });
                                    if (index !== -1) {
                                        signalcircuitAlive[index].value = moment()
                                        signalcircuitAlive[index].alive_limit = moment().add(parseInt(alert_signalalive_values.value), 'seconds')
                                        signalcircuitAlive[index].message = await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit)
                                    }
                                    else {
                                        signalcircuitAlive.push({
                                            key: signalcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_signalalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit), mode: alert_signalalive_values.mode, id: alert_signalalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_signalid.signalname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SIGNAL_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await signalcircuit_compare(C2_data.slice(36, 44), signalcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let signal_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            signalcircuitid: parseInt(signalcircuitid),
                                            signalname: register_signalid.signalname,
                                            terminal: signalterminal,
                                            aspecttypeid: register_signalid.aspecttypeid,
                                            description: signalaspects.description,
                                            greenvoltage: parseFloat(C2_data[36]).toFixed(alert_voldec_values),
                                            greencurrent: parseFloat(C2_data[37]).toFixed(alert_curdec_values),
                                            redvoltage: parseFloat(C2_data[38]).toFixed(alert_voldec_values),
                                            redcurrent: parseFloat(C2_data[39]).toFixed(alert_curdec_values),
                                            yellowvoltage: parseFloat(C2_data[40]).toFixed(alert_voldec_values),
                                            yellowcurrent: parseFloat(C2_data[41]).toFixed(alert_curdec_values),
                                            lightyellowvoltage: parseFloat(C2_data[42]).toFixed(alert_voldec_values),
                                            lightyellowcurrent: parseFloat(C2_data[43]).toFixed(alert_curdec_values),
                                            whitevoltage: 0,
                                            whitecurrent: 0,
                                            createddate: current_datetime
                                        }

                                        await insert_signalcircuit_updated(signal_data)

                                        //logs.info('C2', signal_data)        
                                    }

                                }
                            }

                            //1AUG 
                            var allzero = C2_data.slice(58, 68).every(x => x === '0')

                            var signalcircuitid = parseInt(parseInt(C2_data[57]).toString(16).split("")[0], 16).toString();
                            var signalterminal = String.fromCharCode(parseInt((parseInt(C2_data[57]).toString(16).split("")[1] + parseInt(C2_data[57]).toString(16).split("")[2]), 16))

                            var register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                            if (register_signalid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                                const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_signalalive_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)

                                    var index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });
                                    if (index !== -1) {
                                        signalcircuitAlive[index].value = moment()
                                        signalcircuitAlive[index].alive_limit = moment().add(parseInt(alert_signalalive_values.value), 'seconds')
                                        signalcircuitAlive[index].message = await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit)
                                    }
                                    else {
                                        signalcircuitAlive.push({
                                            key: signalcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_signalalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit), mode: alert_signalalive_values.mode, id: alert_signalalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_signalid.signalname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SIGNAL_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await signalcircuit_compare(C2_data.slice(58, 68), signalcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let signal_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            signalcircuitid: parseInt(signalcircuitid),
                                            signalname: register_signalid.signalname,
                                            terminal: signalterminal,
                                            aspecttypeid: register_signalid.aspecttypeid,
                                            description: signalaspects.description,
                                            greenvoltage: parseFloat(C2_data[58]).toFixed(alert_voldec_values),
                                            greencurrent: parseFloat(C2_data[59]).toFixed(alert_curdec_values),
                                            redvoltage: parseFloat(C2_data[60]).toFixed(alert_voldec_values),
                                            redcurrent: parseFloat(C2_data[61]).toFixed(alert_curdec_values),
                                            yellowvoltage: parseFloat(C2_data[62]).toFixed(alert_voldec_values),
                                            yellowcurrent: parseFloat(C2_data[63]).toFixed(alert_curdec_values),
                                            lightyellowvoltage: parseFloat(C2_data[64]).toFixed(alert_voldec_values),
                                            lightyellowcurrent: parseFloat(C2_data[65]).toFixed(alert_curdec_values),
                                            whitevoltage: parseFloat(C2_data[66]).toFixed(alert_voldec_values),
                                            whitecurrent: parseFloat(C2_data[67]).toFixed(alert_curdec_values),
                                            createddate: current_datetime
                                        }

                                        await insert_signalcircuit_updated(signal_data)

                                        //logs.info('C2', signal_data)        
                                    }
                                }
                            }

                            //25HSSDAC 
                            var allzero = C2_data.slice(94, C2_data.length).every(x => x === '0')

                            var axlecounterid = parseInt(parseInt(C2_data[93]).toString(16).split("")[0], 16).toString();
                            var axlecounterterminal = String.fromCharCode(parseInt((parseInt(C2_data[93]).toString(16).split("")[1] + parseInt(C2_data[93]).toString(16).split("")[2]), 16))

                            var register_axleid = await RegisteredAxleCounter.findOne({ attributes: [['id', 'axlecounterid'], 'stationid', 'axlecountername'], where: { id: axlecounterid, isdele: false } })
                            if (register_axleid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_axleid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Axle Counter" } })

                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_axlecounteralive_values = await get_alerts(`${station_id}@${axlecounterid}@${asserts.assertname}@SET_AXLE_COUNTER_ALIVE`)

                                    var index = axlecounterAlive.findIndex(obj => { return obj.key === axlecounterid; });
                                    if (index !== -1) {
                                        axlecounterAlive[index].value = moment()
                                        axlecounterAlive[index].alive_limit = moment().add(parseInt(alert_axlecounteralive_values.value), 'seconds')
                                        axlecounterAlive[index].message = await combine_mes_val_unit(alert_axlecounteralive_values.message, alert_axlecounteralive_values.value, alert_axlecounteralive_values.unit)
                                    }
                                    else {
                                        axlecounterAlive.push({
                                            key: axlecounterid, value: moment(), alive_limit: moment().add(parseInt(alert_axlecounteralive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_axlecounteralive_values.message, alert_axlecounteralive_values.value, alert_axlecounteralive_values.unit), mode: alert_axlecounteralive_values.mode, id: alert_axlecounteralive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_axleid.axlecountername
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${axlecounterid}@${asserts.assertname}@AXLE_COUNTER_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await axlecounter_compare(C2_data.slice(94, C2_data.length), axlecounterid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let axlecounter_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            axlecounterid: axlecounterid,
                                            axlecountername: register_axleid.axlecountername,
                                            dc_converter_voltage_1: parseFloat(C2_data[94]).toFixed(alert_voldec_values),
                                            dc_converter_voltage_2: parseFloat(C2_data[95]).toFixed(alert_voldec_values),
                                            preparatory_relay_voltage_1: parseFloat(C2_data[96]).toFixed(alert_voldec_values),
                                            preparatory_relay_voltage_2: parseFloat(C2_data[97]).toFixed(alert_voldec_values),
                                            vital_relay_voltage_1: parseFloat(C2_data[98]).toFixed(alert_voldec_values),
                                            vital_relay_voltage_2: parseFloat(C2_data[99]).toFixed(alert_voldec_values),
                                            reset_relay_voltage: parseFloat(C2_data[100]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }

                                        await insert_axlecounter(axlecounter_data)
                                    }
                                }
                            }
                        }
                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/C2 ' + ex);
                        //console.log('mqtt error stationdata/C2 ' + ex);
                    }
                }
            });
        });

        // Active - Cluster 3
        client.subscribe('stationdata/ct3', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/ct3') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/C3', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/C3', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var C3_data = packet.payload.toString().split(',');
                        logs.info('stationdata/C3', C3_data)

                        if (C3_data.length != 1) {

                            //50ATF
                            var allzero = C3_data.slice(2, 12).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C3_data[1]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C3_data[1]).toString(16).split("")[1] + parseInt(C3_data[1]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Feeder(C3_data.slice(2, 12), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                            trackcircuitFeederdatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var FeederDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].feed_count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: asserts.id,
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C3_data[2]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C3_data[3]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C3_data[4]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C3_data[5]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C3_data[6]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C3_data[7]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C3_data[8]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C3_data[9]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C3_data[10]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C3_data[11]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C3', track_data)
                                        cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitFeederdatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_feedertrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );
                                                await transaction.commit();
                                                insert_feedertrack_array(track_data);
                                                logs.info("Track feeder data inserted");
                                                //console.log("Track feeder data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C3 ' + ex);
                                                //console.log('mqtt error stationdata/C3 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            //50BTF
                            var allzero = C3_data.slice(14, 24).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C3_data[13]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C3_data[13]).toString(16).split("")[1] + parseInt(C3_data[13]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Feeder(C3_data.slice(14, 24), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                            trackcircuitFeederdatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var FeederDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].feed_count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: asserts.id,
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C3_data[14]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C3_data[15]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C3_data[16]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C3_data[17]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C3_data[18]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C3_data[19]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C3_data[20]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C3_data[21]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C3_data[22]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C3_data[23]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C3', track_data)
                                        cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitFeederdatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_feedertrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );
                                                await transaction.commit();
                                                insert_feedertrack_array(track_data);
                                                logs.info("Track feeder data inserted");
                                                //console.log("Track feeder data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C3 ' + ex);
                                                //console.log('mqtt error stationdata/C3 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            //1TR  
                            var allzero = C3_data.slice(26, 36).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C3_data[25]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C3_data[25]).toString(16).split("")[1] + parseInt(C3_data[25]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })
                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Relay(C3_data.slice(26, 36), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                            trackcircuitRelaydatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var RelayDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var RelayDatas = [await TrackCircuitRelayData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C3_data[26]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C3_data[27]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C3_data[38]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C3_data[29]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C3_data[30]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C3_data[31]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C3_data[32]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C3_data[33]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C3_data[34]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C3_data[35]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C3', track_data)
                                        cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitRelaydatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_relaytrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitRelayData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );

                                                await transaction.commit();
                                                insert_relaytrack_array(track_data);
                                                logs.info("Track relay data inserted");
                                                //console.log("Track relay data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C3 ' + ex);
                                                //console.log('mqtt error stationdata/C3 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            //50ABW
                            var allzero = C3_data.slice(39, C3_data.length).every(x => x === '0')

                            let pointmachineid = parseInt(parseInt(C3_data[37]).toString(16).split("")[0], 16).toString();
                            let pointmachineterminal = String.fromCharCode(parseInt((parseInt(C3_data[37]).toString(16).split("")[1] + parseInt(C3_data[37]).toString(16).split("")[2]), 16))

                            const register_pointmachineid = await RegisteredPointMachine.findOne({ where: { id: pointmachineid, isdele: false } })

                            var logvalues = parseInt(C3_data[38], 10).toString(2).padStart(4, '0');

                            var A1_run = logvalues[logvalues.length - 1]
                            var B1_run = logvalues[logvalues.length - 2]
                            var A1_log = logvalues[logvalues.length - 3]
                            var B1_log = logvalues[logvalues.length - 4]

                            if (register_pointmachineid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_pointmachineid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Point Machine" } })

                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    var alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${asserts.assertname}@POINT_MACHINE_PERCENTAGE_DIFFERENCE`)
                                    var final_result = false;
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await pointmachine_compare_AB(C3_data.slice(39, C3_data.length), pointmachineid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_POINT_MACHINE_OPERATION`)
                                    var log_result = false;
                                    if (alert_name_values.isactive === true) {
                                        log_result = await pointmachine_logdifference_AB(A1_log, B1_log, pointmachineid, parseFloat(alert_name_values.value))
                                    }
                                    else {
                                        log_result = true
                                    }

                                    final_result = compare_result && log_result == true ? true
                                        : compare_result == false && log_result == true ? true
                                            : false

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_timdec_values = parseFloat(process.env.TIME_DECIMAL_POINT)
                                    let alert_pointalive_values = await get_alerts(`${station_id}@${pointmachineid}@${asserts.assertname}@SET_POINT_MACHINE_ALIVE`)

                                    var index = pointmachineAlive.findIndex(obj => { return obj.key === pointmachineid; });
                                    if (index !== -1) {
                                        pointmachineAlive[index].value = moment()
                                        pointmachineAlive[index].alive_limit = moment().add(parseInt(alert_pointalive_values.value), 'seconds')
                                        pointmachineAlive[index].message = await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit)
                                    }
                                    else {
                                        pointmachineAlive.push({
                                            key: pointmachineid, value: moment(), alive_limit: moment().add(parseInt(alert_pointalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit), mode: alert_pointalive_values.mode, id: alert_pointalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_pointmachineid.pointmachinename
                                        });
                                    }

                                    var pointA_direction = 0
                                    if (parseFloat(C3_data[39]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_A_VOLTAGE`)) && parseFloat(C3_data[39]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_A_VOLTAGE`))) {
                                        pointA_direction = 1
                                    }
                                    else if (parseFloat(C3_data[40]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_A_VOLTAGE`)) && parseFloat(C3_data[40]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_A_VOLTAGE`))) {
                                        pointA_direction = 2
                                    }
                                    if (pointA_direction == 0) {
                                        if (parseFloat(C3_data[39]).toFixed(alert_voldec_values) < parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_A_VOLTAGE`)) && parseFloat(C3_data[40]).toFixed(alert_voldec_values) < parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`))) {
                                            if ((parseFloat(C3_data[43]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_OPERATING_A_CURRENT_AVG`))) && (parseFloat(C3_data[43]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_OPERATING_B_CURRENT_AVG`)))) {
                                                pointA_direction = 1
                                            }
                                            else {
                                                if ((parseFloat(C3_data[45]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_OPERATING_A_CURRENT_AVG`))) && (parseFloat(C3_data[45]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_OPERATING_B_CURRENT_AVG`)))) {
                                                    pointA_direction = 2
                                                }
                                            }
                                        }
                                    }
                                    var index = pointmachineANoDirectionAlive.findIndex(obj => { return obj.key === pointmachineid; });
                                    if (pointA_direction == 0) {
                                        if (index == -1) {
                                            pointmachineANoDirectionAlive.push({
                                                key: pointmachineid, value: moment(),
                                                message: await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit), mode: alert_pointalive_values.mode, id: alert_pointalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_pointmachineid.pointmachinename
                                            });
                                        }
                                        else {
                                            var pointAs = pointmachineANoDirectionAlive[index]
                                            var pointAsec = parseInt(moment().diff(pointAs.value, 'seconds'))
                                            var pointAnosec = parseInt(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@SET_NO_DIRECTION_ALIVE`))
                                            if (pointAsec > pointAnosec) {
                                                if ((lodash.isEqual(pointsAalive, pointAs) === false && pointsAalive == {}) || lodash.isEqual(pointsAalive, pointAs) === false) {
                                                    pointsAalive = { ...pointAs }
                                                    pointmachinealive_notification([pointAs])
                                                }
                                            }
                                        }
                                    }
                                    else {
                                        if (index !== -1) {
                                            pointmachineANoDirectionAlive.splice(index, 1)
                                            pointsAalive = {}
                                        }
                                    }

                                    var pointB_direction = 0
                                    if (parseFloat(C3_data[52]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`)) && parseFloat(C3_data[52]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_B_VOLTAGE`))) {
                                        pointB_direction = 1
                                    }
                                    else if (parseFloat(C3_data[53]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`)) && parseFloat(C3_data[53]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_B_VOLTAGE`))) {
                                        pointB_direction = 2
                                    }
                                    if (pointB_direction == 0) {
                                        if (parseFloat(C3_data[52]).toFixed(alert_voldec_values) < parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`)) && parseFloat(C3_data[53]).toFixed(alert_voldec_values) < parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`))) {
                                            if ((parseFloat(C3_data[56]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_OPERATING_B_CURRENT_AVG`))) && (parseFloat(C3_data[57]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_OPERATING_B_CURRENT_AVG`)))) {
                                                pointB_direction = 1
                                            }
                                            else {
                                                if ((parseFloat(C3_data[58]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_OPERATING_B_CURRENT_AVG`))) && (parseFloat(C3_data[58]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_OPERATING_B_CURRENT_AVG`)))) {
                                                    pointB_direction = 2
                                                }
                                            }
                                        }
                                    }
                                    var index = pointmachineBNoDirectionAlive.findIndex(obj => { return obj.key === pointmachineid; });
                                    if (pointB_direction == 0) {
                                        if (index == -1) {
                                            pointmachineBNoDirectionAlive.push({
                                                key: pointmachineid, value: moment(),
                                                message: await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit), mode: alert_pointalive_values.mode, id: alert_pointalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_pointmachineid.pointmachinename
                                            });
                                        }
                                        else {
                                            var pointBs = pointmachineBNoDirectionAlive[index]
                                            var pointBsec = parseInt(moment().diff(pointBs.value, 'seconds'))
                                            var pointBnosec = parseInt(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@SET_NO_DIRECTION_ALIVE`))

                                            if (pointBsec > pointBnosec) {
                                                if ((lodash.differenceBy(pointsBalive, pointBs).length === 0 && pointBs.length === 0) || lodash.differenceBy(pointBs, pointBs).length > 0) {
                                                    pointsBalive = { ...pointBs }
                                                    pointmachinealive_notification([pointBs])
                                                }
                                            }
                                        }
                                    }
                                    else {
                                        if (index !== -1) {
                                            pointmachineBNoDirectionAlive.splice(index, 1)
                                            pointsBalive = {}
                                        }
                                    }

                                    if (final_result == true) {
                                        var cylcle_count = 1;
                                        if (pointA_direction === 1) {
                                            const cycle_index = pointmachineAdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Normal` });
                                            if (cycle_index !== -1) {
                                                cylcle_count = pointmachineAdatas[cycle_index].value + 1
                                                pointmachineAdatas[cycle_index].value = pointmachineAdatas[cycle_index].value + 1
                                            }
                                            else {
                                                var normal_count = [await PointmachineAdata.findOne({
                                                    where: { pointmachineid: pointmachineid, direction: 'Normal' }
                                                })]
                                                normal_count = normal_count[0] !== null ? normal_count : []
                                                if (normal_count.length > 0) {
                                                    cylcle_count = normal_count[0].cyclecount + 1
                                                }
                                                pointmachineAdatas.push({ key: `${pointmachineid}@Normal`, value: cylcle_count });
                                            }
                                        }
                                        else if (pointA_direction === 2) {
                                            const cycle_index = pointmachineAdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Reverse` });
                                            if (cycle_index !== -1) {
                                                cylcle_count = pointmachineAdatas[cycle_index].value + 1
                                                pointmachineAdatas[cycle_index].value = pointmachineAdatas[cycle_index].value + 1
                                            }
                                            else {
                                                var normal_count = [await PointmachineAdata.findOne({
                                                    order: [["id", "DESC"]],
                                                    where: { pointmachineid: pointmachineid, direction: 'Reverse' }
                                                })]
                                                normal_count = normal_count[0] !== null ? normal_count : []
                                                if (normal_count.length > 0) {
                                                    cylcle_count = normal_count[0].cyclecount + 1
                                                }
                                                pointmachineAdatas.push({ key: `${pointmachineid}@Reverse`, value: cylcle_count });
                                            }
                                        }

                                        let A_point_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            pointmachineid: parseInt(pointmachineid),
                                            pointmachinename: register_pointmachineid.pointmachinename,
                                            cyclecount: cylcle_count,
                                            pointmachineterminal: pointmachineterminal,
                                            direction: pointA_direction == 1 ? 'Normal' : pointA_direction == 2 ? 'Reverse' : 'No Direction',
                                            forwardindicationvoltage: parseFloat(C3_data[39]).toFixed(alert_voldec_values),
                                            reverseindicationvoltage: parseFloat(C3_data[40]).toFixed(alert_voldec_values),
                                            forwardvoltage: parseFloat(C3_data[41]).toFixed(alert_voldec_values),
                                            reversevoltage: parseFloat(C3_data[42]).toFixed(alert_voldec_values),
                                            forwardcurrentavg: parseFloat(C3_data[43]).toFixed(alert_curdec_values),
                                            forwardcurrentpeak: parseFloat(C3_data[44]).toFixed(alert_curdec_values),
                                            reversecurrentavg: parseFloat(C3_data[45]).toFixed(alert_curdec_values),
                                            reversecurrentpeak: parseFloat(C3_data[46]).toFixed(alert_curdec_values),
                                            vibrationx: parseFloat(C3_data[47]).toFixed(alert_curdec_values),
                                            vibrationy: parseFloat(C3_data[48]).toFixed(alert_curdec_values),
                                            vibrationz: parseFloat(C3_data[49]).toFixed(alert_curdec_values),
                                            forwardtime: parseFloat(C3_data[50]).toFixed(alert_timdec_values),
                                            reversetime: parseFloat(C3_data[51]).toFixed(alert_timdec_values),
                                            log: parseInt(A1_log),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C3', A_point_data)                     

                                        var cylcle_count = 1;
                                        if (pointB_direction === 1) {
                                            const cycle_index = pointmachineBdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Normal` });
                                            if (cycle_index !== -1) {
                                                cylcle_count = pointmachineBdatas[cycle_index].value + 1
                                                pointmachineBdatas[cycle_index].value = pointmachineBdatas[cycle_index].value + 1
                                            }
                                            else {
                                                var normal_count = await PointmachineBdata.findOne({
                                                    order: [["id", "DESC"]],
                                                    where: { pointmachineid: pointmachineid, direction: 'Normal' }
                                                })
                                                if (normal_count != null) {
                                                    cylcle_count = normal_count.cyclecount + 1
                                                }
                                                pointmachineBdatas.push({ key: `${pointmachineid}@Normal`, value: cylcle_count });
                                            }
                                        }
                                        else if (pointB_direction === 2) {
                                            const cycle_index = pointmachineBdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Reverse` });
                                            if (cycle_index !== -1) {
                                                cylcle_count = pointmachineBdatas[cycle_index].value + 1
                                                pointmachineBdatas[cycle_index].value = pointmachineBdatas[cycle_index].value + 1
                                            }
                                            else {
                                                var normal_count = await PointmachineBdata.findOne({
                                                    order: [["id", "DESC"]],
                                                    where: { pointmachineid: pointmachineid, direction: 'Reverse' }
                                                })
                                                if (normal_count != null) {
                                                    cylcle_count = normal_count.cyclecount + 1
                                                }
                                                pointmachineBdatas.push({ key: `${pointmachineid}@Reverse`, value: cylcle_count });
                                            }
                                        }

                                        let B_point_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            pointmachineid: parseInt(pointmachineid),
                                            pointmachinename: register_pointmachineid.pointmachinename,
                                            cyclecount: cylcle_count,
                                            pointmachineterminal: pointmachineterminal,
                                            direction: pointB_direction == 1 ? 'Normal' : pointB_direction == 2 ? 'Reverse' : 'No Direction',
                                            forwardindicationvoltage: parseFloat(C3_data[52]).toFixed(alert_voldec_values),
                                            reverseindicationvoltage: parseFloat(C3_data[53]).toFixed(alert_voldec_values),
                                            forwardvoltage: parseFloat(C3_data[54]).toFixed(alert_voldec_values),
                                            reversevoltage: parseFloat(C3_data[55]).toFixed(alert_voldec_values),
                                            forwardcurrentavg: parseFloat(C3_data[56]).toFixed(alert_curdec_values),
                                            forwardcurrentpeak: parseFloat(C3_data[57]).toFixed(alert_curdec_values),
                                            reversecurrentavg: parseFloat(C3_data[58]).toFixed(alert_curdec_values),
                                            reversecurrentpeak: parseFloat(C3_data[59]).toFixed(alert_curdec_values),
                                            vibrationx: parseFloat(C3_data[60]).toFixed(alert_curdec_values),
                                            vibrationy: parseFloat(C3_data[61]).toFixed(alert_curdec_values),
                                            vibrationz: parseFloat(C3_data[62]).toFixed(alert_curdec_values),
                                            forwardtime: parseFloat(C3_data[63]).toFixed(alert_timdec_values),
                                            reversetime: parseFloat(C3_data[64]).toFixed(alert_timdec_values),
                                            log: parseInt(B1_log),
                                            createddate: current_datetime

                                        }
                                        //logs.info('C3', B_point_data)

                                        let transaction = await db.transaction({ autocommit: false });
                                        try {

                                            const p1A_data_insert = await PointmachineAdata.create(
                                                A_point_data
                                                ,
                                                { transaction: transaction }
                                            )

                                            const p1B_data_insert = await PointmachineBdata.create(
                                                B_point_data
                                                ,
                                                { transaction: transaction }
                                            )
                                            await transaction.commit();

                                            //logs.info("Point Machine 1C data inserted");
                                            //console.log("Point Machine 1C data inserted");                
                                            await insert_pointmachineC(A_point_data, B_point_data);
                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/C3 ' + ex);
                                            //console.log('mqtt error stationdata/C3 ' + ex);
                                        }
                                    }
                                }
                            }
                        }

                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/C3 ' + ex);
                        //console.log('mqtt error stationdata/C3 ' + ex);
                    }
                }
            });
        });

        // Active - Cluster 4
        client.subscribe('stationdata/ct4', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/ct4') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/C4', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/C4', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var C4_data = packet.payload.toString().split(',');
                        logs.info('stationdata/C4', C4_data)

                        if (C4_data.length != 1) {

                            //63ATR
                            var allzero = C4_data.slice(2, 12).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C4_data[1]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C4_data[1]).toString(16).split("")[1] + parseInt(C4_data[1]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })
                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Relay(C4_data.slice(2, 12), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                            trackcircuitRelaydatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var RelayDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var RelayDatas = [await TrackCircuitRelayData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C4_data[2]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C4_data[3]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C4_data[4]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C4_data[5]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C4_data[6]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C4_data[7]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C4_data[8]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C4_data[9]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C4_data[10]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C4_data[11]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C4', track_data)
                                        cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitRelaydatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_relaytrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitRelayData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );

                                                await transaction.commit();
                                                insert_relaytrack_array(track_data);
                                                logs.info("Track relay data inserted");
                                                //console.log("Track relay data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C4 ' + ex);
                                                //console.log('mqtt error stationdata/C4 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            //63BTR
                            var allzero = C4_data.slice(14, 24).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C4_data[13]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C4_data[13]).toString(16).split("")[1] + parseInt(C4_data[13]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })
                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Relay(C4_data.slice(14, 24), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                            trackcircuitRelaydatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var RelayDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var RelayDatas = [await TrackCircuitRelayData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C4_data[14]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C4_data[15]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C4_data[16]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C4_data[17]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C4_data[18]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C4_data[19]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C4_data[20]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C4_data[21]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C4_data[22]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C4_data[23]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C4', track_data)
                                        cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitRelaydatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_relaytrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitRelayData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );

                                                await transaction.commit();
                                                insert_relaytrack_array(track_data);
                                                logs.info("Track relay data inserted");
                                                //console.log("Track relay data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C4 ' + ex);
                                                //console.log('mqtt error stationdata/C4 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            //2G 
                            var allzero = C4_data.slice(26, 34).every(x => x === '0')

                            var signalcircuitid = parseInt(parseInt(C4_data[25]).toString(16).split("")[0], 16).toString();
                            var signalterminal = String.fromCharCode(parseInt((parseInt(C4_data[25]).toString(16).split("")[1] + parseInt(C4_data[25]).toString(16).split("")[2]), 16))

                            var register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                            if (register_signalid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                                const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_signalalive_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)

                                    var index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });
                                    if (index !== -1) {
                                        signalcircuitAlive[index].value = moment()
                                        signalcircuitAlive[index].alive_limit = moment().add(parseInt(alert_signalalive_values.value), 'seconds')
                                        signalcircuitAlive[index].message = await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit)
                                    }
                                    else {
                                        signalcircuitAlive.push({
                                            key: signalcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_signalalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit), mode: alert_signalalive_values.mode, id: alert_signalalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_signalid.signalname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SIGNAL_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await signalcircuit_compare(C4_data.slice(26, 34), signalcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let signal_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            signalcircuitid: parseInt(signalcircuitid),
                                            signalname: register_signalid.signalname,
                                            terminal: signalterminal,
                                            aspecttypeid: register_signalid.aspecttypeid,
                                            description: signalaspects.description,
                                            greenvoltage: parseFloat(C4_data[26]).toFixed(alert_voldec_values),
                                            greencurrent: parseFloat(C4_data[27]).toFixed(alert_curdec_values),
                                            redvoltage: parseFloat(C4_data[28]).toFixed(alert_voldec_values),
                                            redcurrent: parseFloat(C4_data[29]).toFixed(alert_curdec_values),
                                            yellowvoltage: parseFloat(C4_data[30]).toFixed(alert_voldec_values),
                                            yellowcurrent: parseFloat(C4_data[31]).toFixed(alert_curdec_values),
                                            lightyellowvoltage: parseFloat(C4_data[32]).toFixed(alert_voldec_values),
                                            lightyellowcurrent: parseFloat(C4_data[33]).toFixed(alert_curdec_values),
                                            whitevoltage: 0,
                                            whitecurrent: 0,
                                            createddate: current_datetime
                                        }

                                        await insert_signalcircuit_updated(signal_data)

                                        //logs.info('C4', signal_data)        
                                    }
                                }
                            }

                            //O2TF
                            var allzero = C4_data.slice(36, 46).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C4_data[35]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C4_data[35]).toString(16).split("")[1] + parseInt(C4_data[35]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Feeder(C4_data.slice(36, 46), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                            trackcircuitFeederdatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var FeederDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].feed_count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: asserts.id,
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C4_data[36]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C4_data[37]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C4_data[38]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C4_data[39]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C4_data[40]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C4_data[41]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C4_data[42]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C4_data[43]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C4_data[44]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C4_data[45]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C4', track_data)
                                        cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitFeederdatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_feedertrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );
                                                await transaction.commit();
                                                insert_feedertrack_array(track_data);
                                                logs.info("Track feeder data inserted");
                                                //console.log("Track feeder data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C4 ' + ex);
                                                //console.log('mqtt error stationdata/C4 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            //01TR
                            var allzero = C4_data.slice(48, 58).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C4_data[47]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C4_data[47]).toString(16).split("")[1] + parseInt(C4_data[47]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })
                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Relay(C4_data.slice(48, 58), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                            trackcircuitRelaydatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var RelayDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var RelayDatas = [await TrackCircuitRelayData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C4_data[48]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C4_data[49]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C4_data[50]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C4_data[51]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C4_data[52]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C4_data[53]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C4_data[54]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C4_data[55]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C4_data[56]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C4_data[57]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C4', track_data)
                                        cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitRelaydatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_relaytrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitRelayData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );

                                                await transaction.commit();
                                                insert_relaytrack_array(track_data);
                                                logs.info("Track relay data inserted");
                                                //console.log("Track relay data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C4 ' + ex);
                                                //console.log('mqtt error stationdata/C4 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            //3G  
                            var allzero = C4_data.slice(60, 68).every(x => x === '0')

                            var signalcircuitid = parseInt(parseInt(C4_data[59]).toString(16).split("")[0], 16).toString();
                            var signalterminal = String.fromCharCode(parseInt((parseInt(C4_data[59]).toString(16).split("")[1] + parseInt(C4_data[59]).toString(16).split("")[2]), 16))

                            var register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                            if (register_signalid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                                const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_signalalive_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)

                                    var index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });
                                    if (index !== -1) {
                                        signalcircuitAlive[index].value = moment()
                                        signalcircuitAlive[index].alive_limit = moment().add(parseInt(alert_signalalive_values.value), 'seconds')
                                        signalcircuitAlive[index].message = await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit)
                                    }
                                    else {
                                        signalcircuitAlive.push({
                                            key: signalcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_signalalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit), mode: alert_signalalive_values.mode, id: alert_signalalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_signalid.signalname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SIGNAL_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await signalcircuit_compare(C4_data.slice(60, 68), signalcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let signal_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            signalcircuitid: parseInt(signalcircuitid),
                                            signalname: register_signalid.signalname,
                                            terminal: signalterminal,
                                            aspecttypeid: register_signalid.aspecttypeid,
                                            description: signalaspects.description,
                                            greenvoltage: parseFloat(C4_data[60]).toFixed(alert_voldec_values),
                                            greencurrent: parseFloat(C4_data[61]).toFixed(alert_curdec_values),
                                            redvoltage: parseFloat(C4_data[62]).toFixed(alert_voldec_values),
                                            redcurrent: parseFloat(C4_data[63]).toFixed(alert_curdec_values),
                                            yellowvoltage: parseFloat(C4_data[64]).toFixed(alert_voldec_values),
                                            yellowcurrent: parseFloat(C4_data[65]).toFixed(alert_curdec_values),
                                            lightyellowvoltage: parseFloat(C4_data[66]).toFixed(alert_voldec_values),
                                            lightyellowcurrent: parseFloat(C4_data[67]).toFixed(alert_curdec_values),
                                            whitevoltage: 0,
                                            whitecurrent: 0,
                                            createddate: current_datetime
                                        }

                                        await insert_signalcircuit_updated(signal_data)

                                        //logs.info('C4', signal_data)        
                                    }
                                }
                            }

                            //63ABW
                            var allzero = C4_data.slice(71, C4_data.length).every(x => x === '0')

                            let pointmachineid = parseInt(parseInt(C4_data[69]).toString(16).split("")[0], 16).toString();
                            let pointmachineterminal = String.fromCharCode(parseInt((parseInt(C4_data[69]).toString(16).split("")[1] + parseInt(C4_data[69]).toString(16).split("")[2]), 16))

                            const register_pointmachineid = await RegisteredPointMachine.findOne({ where: { id: pointmachineid, isdele: false } })

                            var logvalues = parseInt(C4_data[70], 10).toString(2).padStart(4, '0');

                            var A1_run = logvalues[logvalues.length - 1]
                            var B1_run = logvalues[logvalues.length - 2]
                            var A1_log = logvalues[logvalues.length - 3]
                            var B1_log = logvalues[logvalues.length - 4]

                            if (register_pointmachineid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_pointmachineid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Point Machine" } })

                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    var alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${asserts.assertname}@POINT_MACHINE_PERCENTAGE_DIFFERENCE`)
                                    var final_result = false;
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await pointmachine_compare_AB(C4_data.slice(71, C4_data.length), pointmachineid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_POINT_MACHINE_OPERATION`)
                                    var log_result = false;
                                    if (alert_name_values.isactive === true) {
                                        log_result = await pointmachine_logdifference_AB(A1_log, B1_log, pointmachineid, parseFloat(alert_name_values.value))
                                    }
                                    else {
                                        log_result = true
                                    }

                                    final_result = compare_result && log_result == true ? true
                                        : compare_result == false && log_result == true ? true
                                            : false

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_timdec_values = parseFloat(process.env.TIME_DECIMAL_POINT)
                                    let alert_pointalive_values = await get_alerts(`${station_id}@${pointmachineid}@${asserts.assertname}@SET_POINT_MACHINE_ALIVE`)

                                    var index = pointmachineAlive.findIndex(obj => { return obj.key === pointmachineid; });
                                    if (index !== -1) {
                                        pointmachineAlive[index].value = moment()
                                        pointmachineAlive[index].alive_limit = moment().add(parseInt(alert_pointalive_values.value), 'seconds')
                                        pointmachineAlive[index].message = await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit)
                                    }
                                    else {
                                        pointmachineAlive.push({
                                            key: pointmachineid, value: moment(), alive_limit: moment().add(parseInt(alert_pointalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit), mode: alert_pointalive_values.mode, id: alert_pointalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_pointmachineid.pointmachinename
                                        });
                                    }

                                    var pointA_direction = 0
                                    if (parseFloat(C4_data[71]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_A_VOLTAGE`)) && parseFloat(C4_data[71]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_A_VOLTAGE`))) {
                                        pointA_direction = 1
                                    }
                                    else if (parseFloat(C4_data[72]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_A_VOLTAGE`)) && parseFloat(C4_data[72]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_A_VOLTAGE`))) {
                                        pointA_direction = 2
                                    }
                                    if (pointA_direction == 0) {
                                        if (parseFloat(C4_data[71]).toFixed(alert_voldec_values) < parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_A_VOLTAGE`)) && parseFloat(C4_data[72]).toFixed(alert_voldec_values) < parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`))) {
                                            if ((parseFloat(C4_data[75]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_OPERATING_A_CURRENT_AVG`))) && (parseFloat(C4_data[75]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_OPERATING_B_CURRENT_AVG`)))) {
                                                pointA_direction = 1
                                            }
                                            else {
                                                if ((parseFloat(C4_data[76]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_OPERATING_A_CURRENT_AVG`))) && (parseFloat(C4_data[76]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_OPERATING_B_CURRENT_AVG`)))) {
                                                    pointA_direction = 2
                                                }
                                            }
                                        }
                                    }
                                    var index = pointmachineANoDirectionAlive.findIndex(obj => { return obj.key === pointmachineid; });
                                    if (pointA_direction == 0) {
                                        if (index == -1) {
                                            pointmachineANoDirectionAlive.push({
                                                key: pointmachineid, value: moment(),
                                                message: await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit), mode: alert_pointalive_values.mode, id: alert_pointalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_pointmachineid.pointmachinename
                                            });
                                        }
                                        else {
                                            var pointAs = pointmachineANoDirectionAlive[index]
                                            var pointAsec = parseInt(moment().diff(pointAs.value, 'seconds'))
                                            var pointAnosec = parseInt(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@SET_NO_DIRECTION_ALIVE`))
                                            if (pointAsec > pointAnosec) {
                                                if ((lodash.isEqual(pointsAalive, pointAs) === false && pointsAalive == {}) || lodash.isEqual(pointsAalive, pointAs) === false) {
                                                    pointsAalive = { ...pointAs }
                                                    pointmachinealive_notification([pointAs])
                                                }
                                            }
                                        }
                                    }
                                    else {
                                        if (index !== -1) {
                                            pointmachineANoDirectionAlive.splice(index, 1)
                                            pointsAalive = {}
                                        }
                                    }

                                    var pointB_direction = 0
                                    if (parseFloat(C4_data[84]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`)) && parseFloat(C4_data[84]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_B_VOLTAGE`))) {
                                        pointB_direction = 1
                                    }
                                    else if (parseFloat(C4_data[85]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`)) && parseFloat(C4_data[85]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_B_VOLTAGE`))) {
                                        pointB_direction = 2
                                    }
                                    if (pointB_direction == 0) {
                                        if (parseFloat(C4_data[84]).toFixed(alert_voldec_values) < parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`)) && parseFloat(C4_data[85]).toFixed(alert_voldec_values) < parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`))) {
                                            if ((parseFloat(C4_data[88]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_OPERATING_B_CURRENT_AVG`))) && (parseFloat(C4_data[88]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_OPERATING_B_CURRENT_AVG`)))) {
                                                pointB_direction = 1
                                            }
                                            else {
                                                if ((parseFloat(C4_data[90]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_OPERATING_B_CURRENT_AVG`))) && (parseFloat(C4_data[90]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_OPERATING_B_CURRENT_AVG`)))) {
                                                    pointB_direction = 2
                                                }
                                            }
                                        }
                                    }
                                    var index = pointmachineBNoDirectionAlive.findIndex(obj => { return obj.key === pointmachineid; });
                                    if (pointB_direction == 0) {
                                        if (index == -1) {
                                            pointmachineBNoDirectionAlive.push({
                                                key: pointmachineid, value: moment(),
                                                message: await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit), mode: alert_pointalive_values.mode, id: alert_pointalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_pointmachineid.pointmachinename
                                            });
                                        }
                                        else {
                                            var pointBs = pointmachineBNoDirectionAlive[index]
                                            var pointBsec = parseInt(moment().diff(pointBs.value, 'seconds'))
                                            var pointBnosec = parseInt(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@SET_NO_DIRECTION_ALIVE`))

                                            if (pointBsec > pointBnosec) {
                                                if ((lodash.differenceBy(pointsBalive, pointBs).length === 0 && pointBs.length === 0) || lodash.differenceBy(pointBs, pointBs).length > 0) {
                                                    pointsBalive = { ...pointBs }
                                                    pointmachinealive_notification([pointBs])
                                                }
                                            }
                                        }
                                    }
                                    else {
                                        if (index !== -1) {
                                            pointmachineBNoDirectionAlive.splice(index, 1)
                                            pointsBalive = {}
                                        }
                                    }

                                    if (final_result == true) {
                                        var cylcle_count = 1;
                                        if (pointA_direction === 1) {
                                            const cycle_index = pointmachineAdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Normal` });
                                            if (cycle_index !== -1) {
                                                cylcle_count = pointmachineAdatas[cycle_index].value + 1
                                                pointmachineAdatas[cycle_index].value = pointmachineAdatas[cycle_index].value + 1
                                            }
                                            else {
                                                var normal_count = [await PointmachineAdata.findOne({
                                                    where: { pointmachineid: pointmachineid, direction: 'Normal' }
                                                })]
                                                normal_count = normal_count[0] !== null ? normal_count : []
                                                if (normal_count.length > 0) {
                                                    cylcle_count = normal_count[0].cyclecount + 1
                                                }
                                                pointmachineAdatas.push({ key: `${pointmachineid}@Normal`, value: cylcle_count });
                                            }
                                        }
                                        else if (pointA_direction === 2) {
                                            const cycle_index = pointmachineAdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Reverse` });
                                            if (cycle_index !== -1) {
                                                cylcle_count = pointmachineAdatas[cycle_index].value + 1
                                                pointmachineAdatas[cycle_index].value = pointmachineAdatas[cycle_index].value + 1
                                            }
                                            else {
                                                var normal_count = [await PointmachineAdata.findOne({
                                                    order: [["id", "DESC"]],
                                                    where: { pointmachineid: pointmachineid, direction: 'Reverse' }
                                                })]
                                                normal_count = normal_count[0] !== null ? normal_count : []
                                                if (normal_count.length > 0) {
                                                    cylcle_count = normal_count[0].cyclecount + 1
                                                }
                                                pointmachineAdatas.push({ key: `${pointmachineid}@Reverse`, value: cylcle_count });
                                            }
                                        }

                                        let A_point_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            pointmachineid: parseInt(pointmachineid),
                                            pointmachinename: register_pointmachineid.pointmachinename,
                                            cyclecount: cylcle_count,
                                            pointmachineterminal: pointmachineterminal,
                                            direction: pointA_direction == 1 ? 'Normal' : pointA_direction == 2 ? 'Reverse' : 'No Direction',
                                            forwardindicationvoltage: parseFloat(C4_data[71]).toFixed(alert_voldec_values),
                                            reverseindicationvoltage: parseFloat(C4_data[72]).toFixed(alert_voldec_values),
                                            forwardvoltage: parseFloat(C4_data[73]).toFixed(alert_voldec_values),
                                            reversevoltage: parseFloat(C4_data[74]).toFixed(alert_voldec_values),
                                            forwardcurrentavg: parseFloat(C4_data[75]).toFixed(alert_curdec_values),
                                            forwardcurrentpeak: parseFloat(C4_data[76]).toFixed(alert_curdec_values),
                                            reversecurrentavg: parseFloat(C4_data[77]).toFixed(alert_curdec_values),
                                            reversecurrentpeak: parseFloat(C4_data[78]).toFixed(alert_curdec_values),
                                            vibrationx: parseFloat(C4_data[79]).toFixed(alert_curdec_values),
                                            vibrationy: parseFloat(C4_data[80]).toFixed(alert_curdec_values),
                                            vibrationz: parseFloat(C4_data[81]).toFixed(alert_curdec_values),
                                            forwardtime: parseFloat(C4_data[82]).toFixed(alert_timdec_values),
                                            reversetime: parseFloat(C4_data[83]).toFixed(alert_timdec_values),
                                            log: parseInt(A1_log),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C4', A_point_data)                     

                                        var cylcle_count = 1;
                                        if (pointB_direction === 1) {
                                            const cycle_index = pointmachineBdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Normal` });
                                            if (cycle_index !== -1) {
                                                cylcle_count = pointmachineBdatas[cycle_index].value + 1
                                                pointmachineBdatas[cycle_index].value = pointmachineBdatas[cycle_index].value + 1
                                            }
                                            else {
                                                var normal_count = await PointmachineBdata.findOne({
                                                    order: [["id", "DESC"]],
                                                    where: { pointmachineid: pointmachineid, direction: 'Normal' }
                                                })
                                                if (normal_count != null) {
                                                    cylcle_count = normal_count.cyclecount + 1
                                                }
                                                pointmachineBdatas.push({ key: `${pointmachineid}@Normal`, value: cylcle_count });
                                            }
                                        }
                                        else if (pointB_direction === 2) {
                                            const cycle_index = pointmachineBdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Reverse` });
                                            if (cycle_index !== -1) {
                                                cylcle_count = pointmachineBdatas[cycle_index].value + 1
                                                pointmachineBdatas[cycle_index].value = pointmachineBdatas[cycle_index].value + 1
                                            }
                                            else {
                                                var normal_count = await PointmachineBdata.findOne({
                                                    order: [["id", "DESC"]],
                                                    where: { pointmachineid: pointmachineid, direction: 'Reverse' }
                                                })
                                                if (normal_count != null) {
                                                    cylcle_count = normal_count.cyclecount + 1
                                                }
                                                pointmachineBdatas.push({ key: `${pointmachineid}@Reverse`, value: cylcle_count });
                                            }
                                        }

                                        let B_point_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            pointmachineid: parseInt(pointmachineid),
                                            pointmachinename: register_pointmachineid.pointmachinename,
                                            cyclecount: cylcle_count,
                                            pointmachineterminal: pointmachineterminal,
                                            direction: pointB_direction == 1 ? 'Normal' : pointB_direction == 2 ? 'Reverse' : 'No Direction',
                                            forwardindicationvoltage: parseFloat(C4_data[84]).toFixed(alert_voldec_values),
                                            reverseindicationvoltage: parseFloat(C4_data[85]).toFixed(alert_voldec_values),
                                            forwardvoltage: parseFloat(C4_data[86]).toFixed(alert_voldec_values),
                                            reversevoltage: parseFloat(C4_data[87]).toFixed(alert_voldec_values),
                                            forwardcurrentavg: parseFloat(C4_data[88]).toFixed(alert_curdec_values),
                                            forwardcurrentpeak: parseFloat(C4_data[89]).toFixed(alert_curdec_values),
                                            reversecurrentavg: parseFloat(C4_data[90]).toFixed(alert_curdec_values),
                                            reversecurrentpeak: parseFloat(C4_data[91]).toFixed(alert_curdec_values),
                                            vibrationx: parseFloat(C4_data[92]).toFixed(alert_curdec_values),
                                            vibrationy: parseFloat(C4_data[93]).toFixed(alert_curdec_values),
                                            vibrationz: parseFloat(C4_data[94]).toFixed(alert_curdec_values),
                                            forwardtime: parseFloat(C4_data[95]).toFixed(alert_timdec_values),
                                            reversetime: parseFloat(C4_data[96]).toFixed(alert_timdec_values),
                                            log: parseInt(B1_log),
                                            createddate: current_datetime

                                        }
                                        //logs.info('C4', B_point_data)

                                        let transaction = await db.transaction({ autocommit: false });
                                        try {

                                            const p1A_data_insert = await PointmachineAdata.create(
                                                A_point_data
                                                ,
                                                { transaction: transaction }
                                            )

                                            const p1B_data_insert = await PointmachineBdata.create(
                                                B_point_data
                                                ,
                                                { transaction: transaction }
                                            )
                                            await transaction.commit();

                                            //logs.info("Point Machine 1C data inserted");
                                            //console.log("Point Machine 1C data inserted");                
                                            await insert_pointmachineC(A_point_data, B_point_data);
                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/C4 ' + ex);
                                            //console.log('mqtt error stationdata/C4 ' + ex);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/C4 ' + ex);
                        //console.log('mqtt error stationdata/C4 ' + ex);
                    }
                }
            });
        });;

        // Active - Cluster 5
        client.subscribe('stationdata/ct5', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/ct5') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/C5', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/C5', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var C5_data = packet.payload.toString().split(',');
                        logs.info('stationdata/C5', C5_data)

                        if (C5_data.length != 1) {

                            //63BTF
                            var allzero = C5_data.slice(2, 12).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C5_data[1]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C5_data[1]).toString(16).split("")[1] + parseInt(C5_data[1]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Feeder(C5_data.slice(2, 12), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                            trackcircuitFeederdatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var FeederDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].feed_count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: asserts.id,
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C5_data[2]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C5_data[3]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C5_data[4]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C5_data[5]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C5_data[6]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C5_data[7]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C5_data[8]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C5_data[9]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C5_data[10]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C5_data[11]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C5', track_data)
                                        cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitFeederdatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_feedertrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );
                                                await transaction.commit();
                                                insert_feedertrack_array(track_data);
                                                logs.info("Track feeder data inserted");
                                                //console.log("Track feeder data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C5 ' + ex);
                                                //console.log('mqtt error stationdata/C5 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            //65TF
                            var track_feeder = ""
                            var allzero = C5_data.slice(14, 24).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C5_data[13]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C5_data[13]).toString(16).split("")[1] + parseInt(C5_data[13]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Feeder(C5_data.slice(14, 24), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                            trackcircuitFeederdatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var FeederDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].feed_count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: asserts.id,
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C5_data[14]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C5_data[15]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C5_data[16]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C5_data[17]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C5_data[18]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C5_data[19]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C5_data[20]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C5_data[21]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C5_data[22]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C5_data[23]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C5', track_data)
                                        cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitFeederdatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_feedertrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );
                                                await transaction.commit();
                                                track_feeder = track_data
                                                //insert_feedertrack_array(track_data);
                                                logs.info("Track feeder data inserted");
                                                //console.log("Track feeder data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C5 ' + ex);
                                                //console.log('mqtt error stationdata/C5 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            //65TR 
                            var track_relay = ""
                            var allzero = C5_data.slice(60, 70).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C5_data[59]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C5_data[59]).toString(16).split("")[1] + parseInt(C5_data[59]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })
                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Relay(C5_data.slice(60, 70), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                            trackcircuitRelaydatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var RelayDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var RelayDatas = [await TrackCircuitRelayData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C5_data[60]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C5_data[61]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C5_data[62]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C5_data[63]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C5_data[64]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C5_data[65]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C5_data[66]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C5_data[67]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C5_data[68]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C5_data[69]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C5', track_data)
                                        cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitRelaydatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_relaytrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitRelayData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );

                                                await transaction.commit();
                                                track_relay = track_data
                                                //insert_relaytrack_array(track_data);
                                                logs.info("Track relay data inserted");
                                                //console.log("Track relay data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C5 ' + ex);
                                                //console.log('mqtt error stationdata/C5 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            track_feeder != "" || track_relay != "" ? insert_feederrelaytrack_both(track_feeder, track_relay) : ""

                            //8TR
                            var allzero = C5_data.slice(26, 36).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C5_data[25]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C5_data[25]).toString(16).split("")[1] + parseInt(C5_data[25]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })
                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Relay(C5_data.slice(26, 36), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                            trackcircuitRelaydatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var RelayDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var RelayDatas = [await TrackCircuitRelayData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C5_data[26]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C5_data[27]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C5_data[28]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C5_data[29]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C5_data[30]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C5_data[31]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C5_data[32]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C5_data[33]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C5_data[34]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C5_data[35]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C5', track_data)
                                        cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitRelaydatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_relaytrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitRelayData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );

                                                await transaction.commit();
                                                insert_relaytrack_array(track_data);
                                                logs.info("Track relay data inserted");
                                                //console.log("Track relay data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C5 ' + ex);
                                                //console.log('mqtt error stationdata/C5 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            //8G
                            var allzero = C5_data.slice(38, 46).every(x => x === '0')

                            var signalcircuitid = parseInt(parseInt(C5_data[37]).toString(16).split("")[0], 16).toString();
                            var signalterminal = String.fromCharCode(parseInt((parseInt(C5_data[37]).toString(16).split("")[1] + parseInt(C5_data[37]).toString(16).split("")[2]), 16))

                            var register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                            if (register_signalid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                                const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_signalalive_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)

                                    var index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });
                                    if (index !== -1) {
                                        signalcircuitAlive[index].value = moment()
                                        signalcircuitAlive[index].alive_limit = moment().add(parseInt(alert_signalalive_values.value), 'seconds')
                                        signalcircuitAlive[index].message = await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit)
                                    }
                                    else {
                                        signalcircuitAlive.push({
                                            key: signalcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_signalalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit), mode: alert_signalalive_values.mode, id: alert_signalalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_signalid.signalname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SIGNAL_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await signalcircuit_compare(C5_data.slice(38, 46), signalcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let signal_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            signalcircuitid: parseInt(signalcircuitid),
                                            signalname: register_signalid.signalname,
                                            terminal: signalterminal,
                                            aspecttypeid: register_signalid.aspecttypeid,
                                            description: signalaspects.description,
                                            greenvoltage: parseFloat(C5_data[38]).toFixed(alert_voldec_values),
                                            greencurrent: parseFloat(C5_data[39]).toFixed(alert_curdec_values),
                                            redvoltage: parseFloat(C5_data[40]).toFixed(alert_voldec_values),
                                            redcurrent: parseFloat(C5_data[41]).toFixed(alert_curdec_values),
                                            yellowvoltage: parseFloat(C5_data[42]).toFixed(alert_voldec_values),
                                            yellowcurrent: parseFloat(C5_data[43]).toFixed(alert_curdec_values),
                                            lightyellowvoltage: parseFloat(C5_data[44]).toFixed(alert_voldec_values),
                                            lightyellowcurrent: parseFloat(C5_data[45]).toFixed(alert_curdec_values),
                                            whitevoltage: 0,
                                            whitecurrent: 0,
                                            createddate: current_datetime
                                        }

                                        insert_signalcircuit_updated(signal_data)

                                        //logs.info('C5', signal_data)        
                                    }

                                }
                            }

                            //32TF 
                            var allzero = C5_data.slice(48, 58).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C5_data[47]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C5_data[47]).toString(16).split("")[1] + parseInt(C5_data[47]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Feeder(C5_data.slice(48, 58), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                            trackcircuitFeederdatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var FeederDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].feed_count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: asserts.id,
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C5_data[48]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C5_data[49]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C5_data[50]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C5_data[51]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C5_data[52]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C5_data[53]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C5_data[54]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C5_data[55]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C5_data[56]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C5_data[57]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C5', track_data)
                                        cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitFeederdatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitFeederdatas[cycle_index].data = track_data
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_feedertrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );
                                                await transaction.commit();
                                                insert_feedertrack_array(track_data);
                                                logs.info("Track feeder data inserted");
                                                //console.log("Track feeder data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C5 ' + ex);
                                                //console.log('mqtt error stationdata/C5 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            //65W 
                            var allzero = C5_data.slice(73, 86).every(x => x === '0')

                            let pointmachineid = parseInt(parseInt(C5_data[71]).toString(16).split("")[0], 16).toString();
                            let pointmachineterminal = String.fromCharCode(parseInt((parseInt(C5_data[71]).toString(16).split("")[1] + parseInt(C5_data[71]).toString(16).split("")[2]), 16))

                            const register_pointmachineid = await RegisteredPointMachine.findOne({ where: { id: pointmachineid, isdele: false } })

                            // var logvalues = parseInt(C5_data[72], 10).toString(2).padStart(4, '0');

                            // var A1_run = logvalues[logvalues.length - 1] == 1 ? logvalues[logvalues.length - 1] : logvalues[logvalues.length - 2] == 1 ? logvalues[logvalues.length - 2] : 0
                            // var A1_log = logvalues[logvalues.length - 3] == 1 ? logvalues[logvalues.length - 3] : logvalues[logvalues.length - 4] == 1 ? logvalues[logvalues.length - 4] : 0

                            var A1_log = parseInt(C5_data[72]);

                            if (register_pointmachineid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_pointmachineid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Point Machine" } })

                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    var alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${asserts.assertname}@POINT_MACHINE_PERCENTAGE_DIFFERENCE`)
                                    var final_result = false;
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await pointmachine_compare_A(C5_data.slice(73, 86), pointmachineid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_POINT_MACHINE_OPERATION`)
                                    var log_result = false;
                                    if (alert_name_values.isactive === true) {
                                        if (A1_log) {
                                            log_result = true
                                        }
                                    }
                                    else {
                                        log_result = true
                                    }

                                    final_result = compare_result && log_result == true ? true
                                        : compare_result == false && log_result == true ? true
                                            : false

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_timdec_values = parseFloat(process.env.TIME_DECIMAL_POINT)
                                    let alert_pointalive_values = await get_alerts(`${station_id}@${pointmachineid}@${asserts.assertname}@SET_POINT_MACHINE_ALIVE`)

                                    var index = pointmachineAlive.findIndex(obj => { return obj.key === pointmachineid; });
                                    if (index !== -1) {
                                        pointmachineAlive[index].value = moment()
                                        pointmachineAlive[index].alive_limit = moment().add(parseInt(alert_pointalive_values.value), 'seconds')
                                        pointmachineAlive[index].message = await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit)
                                    }
                                    else {
                                        pointmachineAlive.push({
                                            key: pointmachineid, value: moment(), alive_limit: moment().add(parseInt(alert_pointalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit), mode: alert_pointalive_values.mode, id: alert_pointalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_pointmachineid.pointmachinename
                                        });
                                    }

                                    var pointA_direction = 0
                                    if (parseFloat(C5_data[73]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_A_VOLTAGE`)) && parseFloat(C5_data[73]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_A_VOLTAGE`))) {
                                        pointA_direction = 1
                                    }
                                    else if (parseFloat(C5_data[74]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_A_VOLTAGE`)) && parseFloat(C5_data[75]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_A_VOLTAGE`))) {
                                        pointA_direction = 2
                                    }
                                    if (pointA_direction == 0) {
                                        if (parseFloat(C5_data[73]).toFixed(alert_voldec_values) < parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_A_VOLTAGE`)) && parseFloat(C5_data[74]).toFixed(alert_voldec_values) < parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`))) {
                                            if ((parseFloat(C5_data[77]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_OPERATING_A_CURRENT_AVG`))) && (parseFloat(C5_data[77]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_OPERATING_B_CURRENT_AVG`)))) {
                                                pointA_direction = 1
                                            }
                                            else {
                                                if ((parseFloat(C5_data[79]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_OPERATING_A_CURRENT_AVG`))) && (parseFloat(C5_data[79]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_OPERATING_B_CURRENT_AVG`)))) {
                                                    pointA_direction = 2
                                                }
                                            }
                                        }
                                    }
                                    var index = pointmachineANoDirectionAlive.findIndex(obj => { return obj.key === pointmachineid; });
                                    if (pointA_direction == 0) {
                                        if (index == -1) {
                                            pointmachineANoDirectionAlive.push({
                                                key: pointmachineid, value: moment(),
                                                message: await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit), mode: alert_pointalive_values.mode, id: alert_pointalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_pointmachineid.pointmachinename
                                            });
                                        }
                                        else {
                                            var pointAs = pointmachineANoDirectionAlive[index]
                                            var pointAsec = parseInt(moment().diff(pointAs.value, 'seconds'))
                                            var pointAnosec = parseInt(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@SET_NO_DIRECTION_ALIVE`))
                                            if (pointAsec > pointAnosec) {
                                                if ((lodash.isEqual(pointsAalive, pointAs) === false && pointsAalive == {}) || lodash.isEqual(pointsAalive, pointAs) === false) {
                                                    pointsAalive = { ...pointAs }
                                                    pointmachinealive_notification([pointAs])
                                                }
                                            }
                                        }
                                    }
                                    else {
                                        if (index !== -1) {
                                            pointmachineANoDirectionAlive.splice(index, 1)
                                            pointsAalive = {}
                                        }
                                    }

                                    if (final_result == true) {
                                        var cylcle_count = 1;
                                        if (pointA_direction === 1) {
                                            const cycle_index = pointmachineAdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Normal` });
                                            if (cycle_index !== -1) {
                                                cylcle_count = pointmachineAdatas[cycle_index].value + 1
                                                pointmachineAdatas[cycle_index].value = pointmachineAdatas[cycle_index].value + 1
                                            }
                                            else {
                                                var normal_count = [await PointmachineAdata.findOne({
                                                    where: { pointmachineid: pointmachineid, direction: 'Normal' }
                                                })]
                                                normal_count = normal_count[0] !== null ? normal_count : []
                                                if (normal_count.length > 0) {
                                                    cylcle_count = normal_count[0].cyclecount + 1
                                                }
                                                pointmachineAdatas.push({ key: `${pointmachineid}@Normal`, value: cylcle_count });
                                            }
                                        }
                                        else if (pointA_direction === 2) {
                                            const cycle_index = pointmachineAdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Reverse` });
                                            if (cycle_index !== -1) {
                                                cylcle_count = pointmachineAdatas[cycle_index].value + 1
                                                pointmachineAdatas[cycle_index].value = pointmachineAdatas[cycle_index].value + 1
                                            }
                                            else {
                                                var normal_count = [await PointmachineAdata.findOne({
                                                    order: [["id", "DESC"]],
                                                    where: { pointmachineid: pointmachineid, direction: 'Reverse' }
                                                })]
                                                normal_count = normal_count[0] !== null ? normal_count : []
                                                if (normal_count.length > 0) {
                                                    cylcle_count = normal_count[0].cyclecount + 1
                                                }
                                                pointmachineAdatas.push({ key: `${pointmachineid}@Reverse`, value: cylcle_count });
                                            }
                                        }

                                        let point_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            pointmachineid: parseInt(pointmachineid),
                                            pointmachinename: register_pointmachineid.pointmachinename,
                                            cyclecount: cylcle_count,
                                            pointmachineterminal: pointmachineterminal,
                                            direction: pointA_direction == 1 ? 'Normal' : pointA_direction == 2 ? 'Reverse' : 'No Direction',
                                            forwardindicationvoltage: parseFloat(C5_data[73]).toFixed(alert_voldec_values),
                                            reverseindicationvoltage: parseFloat(C5_data[74]).toFixed(alert_voldec_values),
                                            forwardvoltage: parseFloat(C5_data[75]).toFixed(alert_voldec_values),
                                            reversevoltage: parseFloat(C5_data[76]).toFixed(alert_voldec_values),
                                            forwardcurrentavg: parseFloat(C5_data[77]).toFixed(alert_curdec_values),
                                            forwardcurrentpeak: parseFloat(C5_data[78]).toFixed(alert_curdec_values),
                                            reversecurrentavg: parseFloat(C5_data[79]).toFixed(alert_curdec_values),
                                            reversecurrentpeak: parseFloat(C5_data[80]).toFixed(alert_curdec_values),
                                            vibrationx: parseFloat(C5_data[81]).toFixed(alert_curdec_values),
                                            vibrationy: parseFloat(C5_data[82]).toFixed(alert_curdec_values),
                                            vibrationz: parseFloat(C5_data[83]).toFixed(alert_curdec_values),
                                            forwardtime: parseFloat(C5_data[84]).toFixed(alert_timdec_values),
                                            reversetime: parseFloat(C5_data[85]).toFixed(alert_timdec_values),
                                            log: parseInt(A1_log),
                                            createddate: current_datetime
                                        }

                                        //logs.info('PM_1A', point_data)

                                        let transaction = await db.transaction({ autocommit: false });
                                        try {
                                            const p1A_data_insert = await PointmachineAdata.create(
                                                point_data
                                                ,
                                                { transaction: transaction }
                                            );
                                            await transaction.commit();
                                            await insert_Apointnotification(point_data)
                                            logs.info("Point Machine 1A data inserted");
                                            //console.log("Point Machine 1A data inserted");

                                        }
                                        catch (ex) {
                                            await transaction.rollback();
                                            logs.error('mqtt error stationdata/C5 ' + ex);
                                            //console.log('mqtt error stationdata/C5 ' + ex);
                                        }
                                    }
                                }
                            }

                            //8HSSDAC
                            var allzero = C5_data.slice(88, C5_data.length).every(x => x === '0')

                            var axlecounterid = parseInt(parseInt(C5_data[87]).toString(16).split("")[0], 16).toString();
                            var axlecounterterminal = String.fromCharCode(parseInt((parseInt(C5_data[87]).toString(16).split("")[1] + parseInt(C5_data[87]).toString(16).split("")[2]), 16))

                            var register_axleid = await RegisteredAxleCounter.findOne({ attributes: [['id', 'axlecounterid'], 'stationid', 'axlecountername'], where: { id: axlecounterid, isdele: false } })
                            if (register_axleid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_axleid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Axle Counter" } })

                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_axlecounteralive_values = await get_alerts(`${station_id}@${axlecounterid}@${asserts.assertname}@SET_AXLE_COUNTER_ALIVE`)

                                    var index = axlecounterAlive.findIndex(obj => { return obj.key === axlecounterid; });
                                    if (index !== -1) {
                                        axlecounterAlive[index].value = moment()
                                        axlecounterAlive[index].alive_limit = moment().add(parseInt(alert_axlecounteralive_values.value), 'seconds')
                                        axlecounterAlive[index].message = await combine_mes_val_unit(alert_axlecounteralive_values.message, alert_axlecounteralive_values.value, alert_axlecounteralive_values.unit)
                                    }
                                    else {
                                        axlecounterAlive.push({
                                            key: axlecounterid, value: moment(), alive_limit: moment().add(parseInt(alert_axlecounteralive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_axlecounteralive_values.message, alert_axlecounteralive_values.value, alert_axlecounteralive_values.unit), mode: alert_axlecounteralive_values.mode, id: alert_axlecounteralive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_axleid.axlecountername
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${axlecounterid}@${asserts.assertname}@AXLE_COUNTER_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await axlecounter_compare(C5_data.slice(88, C5_data.length), axlecounterid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let axlecounter_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            axlecounterid: axlecounterid,
                                            axlecountername: register_axleid.axlecountername,
                                            dc_converter_voltage_1: parseFloat(C5_data[88]).toFixed(alert_voldec_values),
                                            dc_converter_voltage_2: parseFloat(C5_data[89]).toFixed(alert_voldec_values),
                                            preparatory_relay_voltage_1: parseFloat(C5_data[90]).toFixed(alert_voldec_values),
                                            preparatory_relay_voltage_2: parseFloat(C5_data[91]).toFixed(alert_voldec_values),
                                            vital_relay_voltage_1: parseFloat(C5_data[92]).toFixed(alert_voldec_values),
                                            vital_relay_voltage_2: parseFloat(C5_data[93]).toFixed(alert_voldec_values),
                                            reset_relay_voltage: parseFloat(C5_data[94]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }

                                        await insert_axlecounter(axlecounter_data)
                                    }
                                }
                            }
                        }
                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/C5 ' + ex);
                        //console.log('mqtt error stationdata/C5 ' + ex);
                    }
                }
            });
        });

        // Active - Cluster 6
        client.subscribe('stationdata/ct6', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/ct6') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/C6', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/C6', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var C6_data = packet.payload.toString().split(',');
                        logs.info('stationdata/C6', C6_data)

                        if (C6_data.length != 1) {

                            //11LC
                            var allzero = C6_data.slice(2, 4).every(x => x === '0')

                            var lcgateid = parseInt(parseInt(C6_data[1]).toString(16).split("")[0], 16).toString();
                            var lcgateterminal = String.fromCharCode(parseInt((parseInt(C6_data[1]).toString(16).split("")[1] + parseInt(C6_data[1]).toString(16).split("")[2]), 16))

                            var register_lcid = await RegisteredLCGate.findOne({ attributes: [['id', 'lcgateid'], 'stationid', 'lcgatename'], where: { id: lcgateid, isdele: false } })

                            if (register_lcid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_lcid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "LC Gate" } })

                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_lcgatealive_values = await get_alerts(`${station_id}@${lcgateid}@${asserts.assertname}@SET_LC_GATE_ALIVE`)

                                    var index = lcgateAlive.findIndex(obj => { return obj.key === lcgateid; });
                                    if (index !== -1) {
                                        lcgateAlive[index].value = moment()
                                        lcgateAlive[index].alive_limit = moment().add(parseInt(alert_lcgatealive_values.value), 'seconds')
                                        lcgateAlive[index].message = await combine_mes_val_unit(alert_lcgatealive_values.message, alert_lcgatealive_values.value, alert_lcgatealive_values.unit)
                                    }
                                    else {
                                        lcgateAlive.push({
                                            key: lcgateid, value: moment(), alive_limit: moment().add(parseInt(alert_lcgatealive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_lcgatealive_values.message, alert_lcgatealive_values.value, alert_lcgatealive_values.unit), mode: alert_lcgatealive_values.mode, id: alert_lcgatealive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_lcid.lcgatename
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${lcgateid}@${asserts.assertname}@LC_GATE_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await lcgate_compare(C6_data.slice(87, 94), lcgateid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let lcgate_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            lcgatename: register_lcid.lcgatename,
                                            lcgateid: lcgateid,
                                            announciator_relay_voltage: parseFloat(C6_data[2]).toFixed(alert_voldec_values),
                                            proving_relay_voltage: parseFloat(C6_data[3]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }

                                        await insert_lcgate(lcgate_data)
                                    }
                                }
                            }

                            //63ATF 
                            var allzero = C6_data.slice(8, 18).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C6_data[7]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C6_data[7]).toString(16).split("")[1] + parseInt(C6_data[7]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Feeder(C6_data.slice(8, 18), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                            trackcircuitFeederdatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var FeederDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].feed_count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: asserts.id,
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C6_data[8]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C6_data[9]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C6_data[10]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C6_data[11]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C6_data[12]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C6_data[13]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C6_data[14]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C6_data[15]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C6_data[16]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C6_data[17]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C6', track_data)
                                        cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitFeederdatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_feedertrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );
                                                await transaction.commit();
                                                insert_feedertrack_array(track_data);
                                                logs.info("Track feeder data inserted");
                                                //console.log("Track feeder data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C6 ' + ex);
                                                //console.log('mqtt error stationdata/C6 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            //32TR
                            var allzero = C6_data.slice(20, 30).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C6_data[19]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C6_data[19]).toString(16).split("")[1] + parseInt(C6_data[19]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })
                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Relay(C6_data.slice(18, 28), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                            trackcircuitRelaydatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var RelayDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var RelayDatas = [await TrackCircuitRelayData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C6_data[20]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C6_data[21]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C6_data[22]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C6_data[23]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C6_data[24]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C6_data[25]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C6_data[26]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C6_data[27]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C6_data[28]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C6_data[29]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }

                                        cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitRelaydatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_relaytrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitRelayData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );

                                                await transaction.commit();
                                                insert_relaytrack_array(track_data);
                                                logs.info("Track relay data inserted");
                                                //console.log("Track relay data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C6 ' + ex);
                                                //console.log('mqtt error stationdata/C6 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            //32AUG
                            var allzero = C6_data.slice(32, 42).every(x => x === '0')

                            var signalcircuitid = parseInt(parseInt(C6_data[31]).toString(16).split("")[0], 16).toString();
                            var signalterminal = String.fromCharCode(parseInt((parseInt(C6_data[31]).toString(16).split("")[1] + parseInt(C6_data[31]).toString(16).split("")[2]), 16))

                            var register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                            if (register_signalid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                                const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_signalalive_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)

                                    var index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });
                                    if (index !== -1) {
                                        signalcircuitAlive[index].value = moment()
                                        signalcircuitAlive[index].alive_limit = moment().add(parseInt(alert_signalalive_values.value), 'seconds')
                                        signalcircuitAlive[index].message = await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit)
                                    }
                                    else {
                                        signalcircuitAlive.push({
                                            key: signalcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_signalalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit), mode: alert_signalalive_values.mode, id: alert_signalalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_signalid.signalname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SIGNAL_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await signalcircuit_compare(C6_data.slice(32, 42), signalcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let signal_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            signalcircuitid: parseInt(signalcircuitid),
                                            signalname: register_signalid.signalname,
                                            terminal: signalterminal,
                                            aspecttypeid: register_signalid.aspecttypeid,
                                            description: signalaspects.description,
                                            greenvoltage: parseFloat(C6_data[32]).toFixed(alert_voldec_values),
                                            greencurrent: parseFloat(C6_data[33]).toFixed(alert_curdec_values),
                                            redvoltage: parseFloat(C6_data[34]).toFixed(alert_voldec_values),
                                            redcurrent: parseFloat(C6_data[35]).toFixed(alert_curdec_values),
                                            yellowvoltage: parseFloat(C6_data[36]).toFixed(alert_voldec_values),
                                            yellowcurrent: parseFloat(C6_data[37]).toFixed(alert_curdec_values),
                                            lightyellowvoltage: parseFloat(C6_data[38]).toFixed(alert_voldec_values),
                                            lightyellowcurrent: parseFloat(C6_data[39]).toFixed(alert_curdec_values),
                                            whitevoltage: parseFloat(C6_data[40]).toFixed(alert_voldec_values),
                                            whitecurrent: parseFloat(C6_data[41]).toFixed(alert_curdec_values),
                                            createddate: current_datetime
                                        }

                                        await insert_signalcircuit_updated(signal_data)

                                        //logs.info('C6', signal_data)        
                                    }
                                }
                            }

                            //32D
                            var allzero = C6_data.slice(56, 64).every(x => x === '0')

                            var signalcircuitid = parseInt(parseInt(C6_data[55]).toString(16).split("")[0], 16).toString();
                            var signalterminal = String.fromCharCode(parseInt((parseInt(C6_data[55]).toString(16).split("")[1] + parseInt(C6_data[55]).toString(16).split("")[2]), 16))

                            var register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                            if (register_signalid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                                const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_signalalive_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)

                                    var index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });
                                    if (index !== -1) {
                                        signalcircuitAlive[index].value = moment()
                                        signalcircuitAlive[index].alive_limit = moment().add(parseInt(alert_signalalive_values.value), 'seconds')
                                        signalcircuitAlive[index].message = await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit)
                                    }
                                    else {
                                        signalcircuitAlive.push({
                                            key: signalcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_signalalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_signalalive_values.message, alert_signalalive_values.value, alert_signalalive_values.unit), mode: alert_signalalive_values.mode, id: alert_signalalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_signalid.signalname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SIGNAL_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await signalcircuit_compare(C6_data.slice(56, 64), signalcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let signal_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: parseInt(asserts.id),
                                            assertname: asserts.assertname,
                                            signalcircuitid: parseInt(signalcircuitid),
                                            signalname: register_signalid.signalname,
                                            terminal: signalterminal,
                                            aspecttypeid: register_signalid.aspecttypeid,
                                            description: signalaspects.description,
                                            greenvoltage: parseFloat(C6_data[56]).toFixed(alert_voldec_values),
                                            greencurrent: parseFloat(C6_data[57]).toFixed(alert_curdec_values),
                                            redvoltage: parseFloat(C6_data[58]).toFixed(alert_voldec_values),
                                            redcurrent: parseFloat(C6_data[59]).toFixed(alert_curdec_values),
                                            yellowvoltage: parseFloat(C6_data[60]).toFixed(alert_voldec_values),
                                            yellowcurrent: parseFloat(C6_data[61]).toFixed(alert_curdec_values),
                                            lightyellowvoltage: parseFloat(C6_data[62]).toFixed(alert_voldec_values),
                                            lightyellowcurrent: parseFloat(C6_data[63]).toFixed(alert_curdec_values),
                                            whitevoltage: 0,
                                            whitecurrent: 0,
                                            createddate: current_datetime
                                        }

                                        await insert_signalcircuit_updated(signal_data)

                                        //logs.info('C6', signal_data)        
                                    }

                                }
                            }

                            //C32TF
                            var track_feeder = ""
                            var allzero = C6_data.slice(66, 76).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C6_data[65]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C6_data[65]).toString(16).split("")[1] + parseInt(C6_data[65]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Feeder(C6_data.slice(66, 76), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                            trackcircuitFeederdatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var FeederDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].feed_count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: asserts.id,
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C6_data[66]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C6_data[67]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C6_data[68]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C6_data[69]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C6_data[70]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C6_data[71]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C6_data[72]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C6_data[73]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C6_data[74]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C6_data[75]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C6', track_data)
                                        cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitFeederdatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_feedertrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );
                                                await transaction.commit();
                                                track_feeder = track_data
                                                //insert_feedertrack_array(track_data);
                                                logs.info("Track feeder data inserted");
                                                //console.log("Track feeder data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C6 ' + ex);
                                                //console.log('mqtt error stationdata/C6 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            //C32TR
                            var track_relay = ""
                            var allzero = C6_data.slice(44, 54).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C6_data[43]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C6_data[43]).toString(16).split("")[1] + parseInt(C6_data[43]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Feeder(C6_data.slice(44, 54), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                            trackcircuitRelaydatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var RelayDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var RelayDatas = [await TrackCircuitRelayData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                                if (RelayDatas.length > 0) {
                                                    track_count = RelayDatas[0].count + 1
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: RelayDatas[0] });
                                                }
                                                else {
                                                    trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: asserts.id,
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C6_data[44]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C6_data[45]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C6_data[46]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C6_data[47]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C6_data[48]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C6_data[49]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C6_data[50]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C6_data[51]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C6_data[52]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C6_data[53]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C6', track_data)                                
                                        cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitRelaydatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_feedertrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );
                                                await transaction.commit();
                                                track_relay = track_data
                                                //insert_feedertrack_array(track_data);
                                                logs.info("Track feeder data inserted");
                                                //console.log("Track feeder data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C6 ' + ex);
                                                //console.log('mqtt error stationdata/C6 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }

                            track_feeder != "" || track_relay != "" ? insert_feederrelaytrack_both(track_feeder, track_relay) : ""

                            //8TF
                            var allzero = C6_data.slice(78, 88).every(x => x === '0')

                            var trackcircuitid = parseInt(parseInt(C6_data[77]).toString(16).split("")[0], 16).toString();
                            var trackterminal = String.fromCharCode(parseInt((parseInt(C6_data[77]).toString(16).split("")[1] + parseInt(C6_data[77]).toString(16).split("")[2]), 16))

                            var register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                            if (register_trackid != null && allzero == false) {
                                const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                                const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                                if (get_stations != null) {
                                    let station_id = parseInt(get_stations.id)

                                    let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                    let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                    let alert_trackalive_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)

                                    var index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (index !== -1) {
                                        trackcircuitAlive[index].value = moment()
                                        trackcircuitAlive[index].alive_limit = moment().add(parseInt(alert_trackalive_values.value), 'seconds')
                                        trackcircuitAlive[index].message = await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit)
                                    }
                                    else {
                                        trackcircuitAlive.push({
                                            key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(alert_trackalive_values.value), 'seconds'),
                                            message: await combine_mes_val_unit(alert_trackalive_values.message, alert_trackalive_values.value, alert_trackalive_values.unit), mode: alert_trackalive_values.mode, id: alert_trackalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_trackid.trackname
                                        });
                                    }

                                    var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                    var compare_result = false
                                    if (alert_name_values.isactive === true) {
                                        compare_result = await trackcircuit_compare_Feeder(C6_data.slice(78, 88), trackcircuitid, alert_name_values.value)
                                    }
                                    else {
                                        compare_result = true
                                    }

                                    if (compare_result === true) {
                                        let track_count = 1;
                                        var cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index !== -1) {
                                            track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                            trackcircuitFeederdatas[cycle_index].value = track_count
                                        }
                                        else {
                                            if (trackcircuitWithoutArray === true) {
                                                var FeederDatas = [await TrackCircuitData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].feed_count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                            else {
                                                var FeederDatas = [await TrackCircuitFeederData.findOne({
                                                    limit: 1,
                                                    order: [["id", "DESC"]],
                                                    where: { trackcircuitid: trackcircuitid },
                                                    raw: true
                                                })];
                                                FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                                if (FeederDatas.length > 0) {
                                                    track_count = FeederDatas[0].count + 1
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: FeederDatas[0] });
                                                }
                                                else {
                                                    trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: {} });
                                                }
                                            }
                                        }

                                        let track_data = {
                                            stationid: parseInt(get_stations.id),
                                            stationcode: get_stations.stationcode,
                                            stationname: get_stations.stationname,
                                            assertid: asserts.id,
                                            assertname: asserts.assertname,
                                            trackcircuitid: parseInt(trackcircuitid),
                                            trackcircuitterminal: trackterminal,
                                            trackname: register_trackid.trackname,
                                            count: track_count,
                                            feed_voltage: parseFloat(C6_data[78]).toFixed(alert_voldec_values),
                                            feed_current: parseFloat(C6_data[79]).toFixed(alert_curdec_values),
                                            choke_voltage: parseFloat(C6_data[80]).toFixed(alert_voldec_values),
                                            battery_charger_dc_current: parseFloat(C6_data[81]).toFixed(alert_curdec_values),
                                            battery_charger_dc_voltage: parseFloat(C6_data[82]).toFixed(alert_voldec_values),
                                            battery_charger_ac_voltage: parseFloat(C6_data[83]).toFixed(alert_voldec_values),
                                            battery_charger_ac_current: parseFloat(C6_data[84]).toFixed(alert_curdec_values),
                                            relay_voltage: parseFloat(C6_data[85]).toFixed(alert_voldec_values),
                                            relay_current: parseFloat(C6_data[86]).toFixed(alert_curdec_values),
                                            trv: parseFloat(C6_data[87]).toFixed(alert_voldec_values),
                                            createddate: current_datetime
                                        }
                                        //logs.info('C6', track_data)
                                        cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                        if (cycle_index != -1) {
                                            trackcircuitFeederdatas[cycle_index].data = track_data
                                        }
                                        else {
                                            trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count, data: track_data });
                                        }

                                        if (trackcircuitWithoutArray === true) {
                                            insert_feedertrack_array(track_data);
                                        }
                                        else {
                                            let transaction = await db.transaction({ autocommit: false });
                                            try {
                                                const tc_f_data_insert = await TrackCircuitFeederData.create(
                                                    track_data,
                                                    { transaction: transaction },
                                                    { returning: true }
                                                );
                                                await transaction.commit();
                                                insert_feedertrack_array(track_data);
                                                logs.info("Track feeder data inserted");
                                                //console.log("Track feeder data inserted");
                                            }
                                            catch (ex) {
                                                await transaction.rollback();
                                                logs.error('mqtt error stationdata/C6 ' + ex);
                                                //console.log('mqtt error stationdata/C6 ' + ex);
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/C6 ' + ex);
                        //console.log('mqtt error stationdata/C6 ' + ex);
                    }
                }
            });
        });



        // Inactive - Point Machine 1A
        client.subscribe('stationdata/PM_1A', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/PM_1') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/PM_1A', moment().format("YYYY-MM-DD HH:mm:ss"))
                        //console.log('stationdata/PM_1A', moment().format("YYYY-MM-DD HH:mm:ss")
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss")
                        var pointmachine_1A_data = packet.payload.toString().split(',');
                        //logs.info('stationdata/PM_1A', pointmachine_1A_data)

                        var allzero = pointmachine_1A_data.slice(2, 15).every(x => x === '0')

                        let pointmachineid = parseInt(pointmachine_1A_data[0]).toString(16).split("")[0]
                        let pointmachineterminal = String.fromCharCode(parseInt((parseInt(pointmachine_1A_data[0]).toString(16).split("")[1] + parseInt(pointmachine_1A_data[0]).toString(16).split("")[2]), 16))

                        const register_pointmachineid = await RegisteredPointMachine.findOne({ where: { id: pointmachineid, isdele: false } })
                        if (register_pointmachineid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_pointmachineid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Point Machine" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_timdec_values = parseFloat(process.env.TIME_DECIMAL_POINT)
                                let alert_pointalive_values = await get_alerts(`${station_id}@${pointmachineid}@${asserts.assertname}@SET_POINT_MACHINE_ALIVE`)

                                var index = pointmachineAlive.findIndex(obj => { return obj.key === pointmachineid; });
                                if (index !== -1) {
                                    pointmachineAlive[index].value = moment()
                                    pointmachineAlive[index].alive_limit = moment().add(parseInt(alert_pointalive_values.value), 'seconds')
                                    pointmachineAlive[index].message = await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit)
                                }
                                else {
                                    pointmachineAlive.push({
                                        key: pointmachineid, value: moment(), alive_limit: moment().add(parseInt(alert_pointalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit), mode: alert_pointalive_values.mode, id: alert_pointalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_pointmachineid.pointmachinename
                                    });
                                }

                                let point_log = 0
                                let point_direction = 0

                                ////direction not needed , need to take from voltage
                                // if(parseInt(pointmachine_1A_data[1]) === parseInt(0))
                                // {
                                //     if(pointmachine_1A_data[1].length == 1)
                                //     {
                                //         point_direction = parseInt(pointmachine_1A_data[1])
                                //     }
                                //     else
                                //     {
                                //         point_log = parseInt(pointmachine_1A_data[1]).toString(16).split("")[0]
                                //         point_direction = parseInt(pointmachine_1A_data[1]).toString(16).split("")[1]
                                //     }
                                // }
                                // else
                                // {
                                //     point_direction = parseInt(pointmachine_1A_data[1])
                                // }

                                if (parseFloat(pointmachine_1A_data[2]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_A_VOLTAGE`)) && parseFloat(pointmachine_1A_data[2]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_A_VOLTAGE`))) {
                                    point_direction = 1
                                }
                                else if (parseFloat(pointmachine_1A_data[3]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_A_VOLTAGE`)) && parseFloat(pointmachine_1A_data[3]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_A_VOLTAGE`))) {
                                    point_direction = 2
                                }

                                let cylcle_count = 1;
                                if (point_direction === 1) {
                                    const cycle_index = pointmachineAdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Normal` });
                                    if (cycle_index !== -1) {
                                        cylcle_count = pointmachineAdatas[cycle_index].value + 1
                                        pointmachineAdatas[cycle_index].value = pointmachineAdatas[cycle_index].value + 1
                                    }
                                    else {
                                        var normal_count = [await PointmachineAdata.findOne({
                                            order: [["id", "DESC"]],
                                            where: { pointmachineid: pointmachineid, direction: 'Normal' }
                                        })]
                                        normal_count = normal_count[0] !== null ? normal_count : []
                                        if (normal_count.length > 0) {
                                            cylcle_count = normal_count[0].cyclecount + 1
                                        }
                                        pointmachineAdatas.push({ key: `${pointmachineid}@Normal`, value: cylcle_count });
                                    }
                                }
                                else if (point_direction === 2) {
                                    const cycle_index = pointmachineAdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Reverse` });
                                    if (cycle_index !== -1) {
                                        cylcle_count = pointmachineAdatas[cycle_index].value + 1
                                        pointmachineAdatas[cycle_index].value = pointmachineAdatas[cycle_index].value + 1
                                    }
                                    else {
                                        var normal_count = [await PointmachineAdata.findOne({
                                            order: [["id", "DESC"]],
                                            where: { pointmachineid: pointmachineid, direction: 'Reverse' }
                                        })]
                                        normal_count = normal_count[0] !== null ? normal_count : []
                                        if (normal_count.length > 0) {
                                            cylcle_count = normal_count[0].cyclecount + 1
                                        }
                                        pointmachineAdatas.push({ key: `${pointmachineid}@Reverse`, value: cylcle_count });
                                    }
                                }

                                let point_data = {
                                    stationid: parseInt(get_stations.id),
                                    stationcode: get_stations.stationcode,
                                    stationname: get_stations.stationname,
                                    assertid: parseInt(asserts.id),
                                    assertname: asserts.assertname,
                                    pointmachineid: parseInt(pointmachineid),
                                    pointmachinename: register_pointmachineid.pointmachinename,
                                    cyclecount: cylcle_count,
                                    pointmachineterminal: pointmachineterminal,
                                    direction: point_direction == 1 ? 'Normal' : point_direction == 2 ? 'Reverse' : 'No Direction',
                                    forwardindicationvoltage: parseFloat(pointmachine_1A_data[2]).toFixed(alert_voldec_values),
                                    reverseindicationvoltage: parseFloat(pointmachine_1A_data[3]).toFixed(alert_voldec_values),
                                    forwardvoltage: parseFloat(pointmachine_1A_data[4]).toFixed(alert_voldec_values),
                                    reversevoltage: parseFloat(pointmachine_1A_data[5]).toFixed(alert_voldec_values),
                                    forwardcurrentavg: parseFloat(pointmachine_1A_data[6]).toFixed(alert_curdec_values),
                                    forwardcurrentpeak: parseFloat(pointmachine_1A_data[7]).toFixed(alert_curdec_values),
                                    reversecurrentavg: parseFloat(pointmachine_1A_data[8]).toFixed(alert_curdec_values),
                                    reversecurrentpeak: parseFloat(pointmachine_1A_data[9]).toFixed(alert_curdec_values),
                                    vibrationx: parseFloat(pointmachine_1A_data[10]).toFixed(alert_curdec_values),
                                    vibrationy: parseFloat(pointmachine_1A_data[11]).toFixed(alert_curdec_values),
                                    vibrationz: parseFloat(pointmachine_1A_data[12]).toFixed(alert_curdec_values),
                                    forwardtime: parseFloat(pointmachine_1A_data[13]).toFixed(alert_timdec_values),
                                    reversetime: parseFloat(pointmachine_1A_data[14]).toFixed(alert_timdec_values),
                                    log: parseInt(pointmachine_1A_data[1]),
                                    createddate: current_datetime
                                }
                                //logs.info('PM_1A', point_data)

                                let transaction = await db.transaction({ autocommit: false });
                                try {
                                    const p1A_data_insert = await PointmachineAdata.create(
                                        point_data
                                        ,
                                        { transaction: transaction }
                                    );
                                    await transaction.commit();
                                    await insert_Apointnotification(point_data)
                                    logs.info("Point Machine 1A data inserted");
                                    //console.log("Point Machine 1A data inserted");

                                }
                                catch (ex) {
                                    await transaction.rollback();
                                    logs.error('mqtt error stationdata/PM_1A_inside ' + ex);
                                    //console.log('mqtt error stationdata/PM_1A_inside ' + ex);
                                }
                            }
                        }
                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/PM_1A_outside ' + ex);
                        //console.log('mqtt error stationdata/PM_1A_outside ' + ex);
                    }
                }
            });
        });

        // Inactive - Point Machine 1B
        client.subscribe('stationdata/PM_1B', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/PM_1') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/PM_1B', moment().format("YYYY-MM-DD HH:mm:ss"))
                        //console.log('stationdata/PM_1B', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss")
                        var pointmachine_1B_data = packet.payload.toString().split(',');
                        //logs.info('stationdata/PM_1B', pointmachine_1B_data) 

                        var allzero = pointmachine_1B_data.slice(2, 15).every(x => x === '0')

                        let pointmachineid = parseInt(pointmachine_1B_data[0]).toString(16).split("")[0]
                        let pointmachineterminal = String.fromCharCode(parseInt((parseInt(pointmachine_1B_data[0]).toString(16).split("")[1] + parseInt(pointmachine_1B_data[0]).toString(16).split("")[2]), 16))

                        const register_pointmachineid = await RegisteredPointMachine.findOne({ where: { id: pointmachineid, isdele: false } })
                        if (register_pointmachineid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_pointmachineid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Point Machine" } })

                            if (get_stations != null) {

                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_timdec_values = parseFloat(process.env.TIME_DECIMAL_POINT)
                                let alert_pointalive_values = await get_alerts(`${station_id}@${pointmachineid}@${asserts.assertname}@SET_POINT_MACHINE_ALIVE`)

                                var index = pointmachineAlive.findIndex(obj => { return obj.key === pointmachineid; });
                                if (index !== -1) {
                                    pointmachineAlive[index].value = moment()
                                    pointmachineAlive[index].alive_limit = moment().add(parseInt(alert_pointalive_values.value), 'seconds')
                                    pointmachineAlive[index].message = await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit)
                                }
                                else {
                                    pointmachineAlive.push({
                                        key: pointmachineid, value: moment(), alive_limit: moment().add(parseInt(alert_pointalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_pointalive_values.message, alert_pointalive_values.value, alert_pointalive_values.unit), mode: alert_pointalive_values.mode, id: alert_pointalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_pointmachineid.pointmachinename
                                    });
                                }

                                // //direction not needed, need to take from voltage
                                let point_log = 0
                                let point_direction = 0

                                // if(parseInt(pointmachine_1B_data[1]) !== 0 )
                                // {
                                //     if(pointmachine_1B_data[1].length == 1)
                                //     {
                                //         point_direction = parseInt(pointmachine_1B_data[1])
                                //     }
                                //     else
                                //     {
                                //         point_log = parseInt(pointmachine_1B_data[1]).toString(16).split("")[0]
                                //         point_direction = parseInt(pointmachine_1B_data[1]).toString(16).split("")[1]
                                //     }

                                // }
                                // else
                                // {
                                //     point_direction = parseInt(pointmachine_1B_data[1])
                                // }

                                if (parseFloat(pointmachine_1B_data[2]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`)) && parseFloat(pointmachine_1B_data[2]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_B_VOLTAGE`))) {
                                    point_direction = 1
                                }
                                else if (parseFloat(pointmachine_1B_data[3]).toFixed(alert_voldec_values) >= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MIN_INDICATION_B_VOLTAGE`)) && parseFloat(pointmachine_1B_data[3]).toFixed(alert_voldec_values) <= parseFloat(await get_alert_value(`${station_id}@${pointmachineid}@${asserts.assertname}@MAX_INDICATION_B_VOLTAGE`))) {
                                    point_direction = 2
                                }

                                let cylcle_count = 1;
                                if (point_direction === 1) {
                                    const cycle_index = pointmachineBdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Normal` });
                                    if (cycle_index !== -1) {
                                        cylcle_count = pointmachineBdatas[cycle_index].value + 1
                                        pointmachineBdatas[cycle_index].value = pointmachineBdatas[cycle_index].value + 1
                                    }
                                    else {
                                        var normal_count = await PointmachineBdata.findOne({
                                            order: [["id", "DESC"]],
                                            where: { pointmachineid: pointmachineid, direction: 'Normal' }
                                        })
                                        if (normal_count != null) {
                                            cylcle_count = normal_count.cyclecount + 1
                                        }
                                        pointmachineBdatas.push({ key: `${pointmachineid}@Normal`, value: cylcle_count });
                                    }
                                }
                                else if (point_direction === 2) {
                                    const cycle_index = pointmachineBdatas.findIndex(obj => { return obj.key === `${pointmachineid}@Reverse` });
                                    if (cycle_index !== -1) {
                                        cylcle_count = pointmachineBdatas[cycle_index].value + 1
                                        pointmachineBdatas[cycle_index].value = pointmachineBdatas[cycle_index].value + 1
                                    }
                                    else {
                                        var normal_count = await PointmachineBdata.findOne({
                                            order: [["id", "DESC"]],
                                            where: { pointmachineid: pointmachineid, direction: 'Reverse' }
                                        })
                                        if (normal_count != null) {
                                            cylcle_count = normal_count.cyclecount + 1
                                        }
                                        pointmachineBdatas.push({ key: `${pointmachineid}@Reverse`, value: cylcle_count });
                                    }
                                }

                                let point_data = {
                                    stationid: parseInt(get_stations.id),
                                    stationcode: get_stations.stationcode,
                                    stationname: get_stations.stationname,
                                    assertid: parseInt(asserts.id),
                                    assertname: asserts.assertname,
                                    pointmachineid: parseInt(pointmachineid),
                                    pointmachinename: register_pointmachineid.pointmachinename,
                                    cyclecount: cylcle_count,
                                    pointmachineterminal: pointmachineterminal,
                                    direction: point_direction == 1 ? 'Normal' : point_direction == 2 ? 'Reverse' : 'No Direction',
                                    forwardindicationvoltage: parseFloat(pointmachine_1B_data[2]).toFixed(alert_voldec_values),
                                    reverseindicationvoltage: parseFloat(pointmachine_1B_data[3]).toFixed(alert_voldec_values),
                                    forwardvoltage: parseFloat(pointmachine_1B_data[4]).toFixed(alert_voldec_values),
                                    reversevoltage: parseFloat(pointmachine_1B_data[5]).toFixed(alert_voldec_values),
                                    forwardcurrentavg: parseFloat(pointmachine_1B_data[6]).toFixed(alert_curdec_values),
                                    forwardcurrentpeak: parseFloat(pointmachine_1B_data[7]).toFixed(alert_curdec_values),
                                    reversecurrentavg: parseFloat(pointmachine_1B_data[8]).toFixed(alert_curdec_values),
                                    reversecurrentpeak: parseFloat(pointmachine_1B_data[9]).toFixed(alert_curdec_values),
                                    vibrationx: parseFloat(pointmachine_1B_data[10]).toFixed(alert_curdec_values),
                                    vibrationy: parseFloat(pointmachine_1B_data[11]).toFixed(alert_curdec_values),
                                    vibrationz: parseFloat(pointmachine_1B_data[12]).toFixed(alert_curdec_values),
                                    forwardtime: parseFloat(pointmachine_1B_data[13]).toFixed(alert_timdec_values),
                                    reversetime: parseFloat(pointmachine_1B_data[14]).toFixed(alert_timdec_values),
                                    log: parseInt(pointmachine_1B_data[1]),
                                    createddate: current_datetime
                                }
                                //logs.info('PM_1B', point_data)                     

                                let transaction = await db.transaction({ autocommit: false });
                                try {
                                    const p1B_data_insert = await PointmachineBdata.create(
                                        point_data
                                        ,
                                        { transaction: transaction }
                                    );
                                    await transaction.commit();
                                    await insert_Bpointnotification(point_data)
                                    logs.info("Point Machine 1B data inserted");
                                    //console.log("Point Machine 1B data inserted"); 

                                }
                                catch (ex) {
                                    await transaction.rollback();
                                    logs.error('mqtt error stationdata/PM_1B_inside ' + ex);
                                    //console.log('mqtt error stationdata/PM_1B_inside ' + ex);
                                }
                            }
                        }
                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/PM_1B_outside ' + ex);
                        //console.log('mqtt error stationdata/PM_1B_outside ' + ex);
                    }
                }
            });
        });

        // Inactive - Track Circuit Feeder Loop
        client.subscribe('stationdata/TS_1F', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/TS_1') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/TS_1F', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/TS_1F', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var TS_1F_data = packet.payload.toString().split(',');
                        //logs.info('stationdata/TS_1F', TS_1F_data)      

                        var allzero = TS_1F_data.slice(1, 11).every(x => x === '0')

                        let trackcircuitid = parseInt(TS_1F_data[0]).toString(16).split("")[0];
                        let trackterminal = String.fromCharCode(parseInt((parseInt(TS_1F_data[0]).toString(16).split("")[1] + parseInt(TS_1F_data[0]).toString(16).split("")[2]), 16))

                        const register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)

                                const index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                if (index !== -1) {
                                    trackcircuitAlive[index].value = moment()
                                    trackcircuitAlive[index].alive_limit = moment().add(parseInt(await get_alert_value(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)), 'seconds')
                                }
                                else {
                                    trackcircuitAlive.push({ key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(await get_alert_value(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)), 'seconds'), stationname: get_stations.stationname, stationid: station_id, trackname: register_trackid.trackname });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await trackcircuit_compare_Feeder(TS_1F_data.slice(1, 11), trackcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let track_count = 1;
                                    const cycle_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (cycle_index !== -1) {
                                        track_count = trackcircuitFeederdatas[cycle_index].value + 1
                                        trackcircuitFeederdatas[cycle_index].value = track_count
                                    }
                                    else {
                                        var FeederDatas = [await TrackCircuitFeederData.findOne({
                                            limit: 1,
                                            order: [["id", "DESC"]],
                                            where: { trackcircuitid: trackcircuitid },
                                            raw: true
                                        })];
                                        FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                                        if (FeederDatas.length > 0) {
                                            track_count = FeederDatas[0].count + 1
                                        }
                                        trackcircuitFeederdatas.push({ key: trackcircuitid, value: track_count });
                                    }

                                    let track_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: asserts.id,
                                        assertname: asserts.assertname,
                                        trackcircuitid: parseInt(trackcircuitid),
                                        trackcircuitterminal: trackterminal,
                                        trackname: register_trackid.trackname,
                                        count: track_count,
                                        feed_voltage: parseFloat(TS_1F_data[1]).toFixed(alert_voldec_values),
                                        feed_current: parseFloat(TS_1F_data[2]).toFixed(alert_curdec_values),
                                        choke_voltage: parseFloat(TS_1F_data[3]).toFixed(alert_voldec_values),
                                        battery_charger_dc_current: parseFloat(TS_1F_data[4]).toFixed(alert_curdec_values),
                                        battery_charger_dc_voltage: parseFloat(TS_1F_data[5]).toFixed(alert_voldec_values),
                                        battery_charger_ac_voltage: parseFloat(TS_1F_data[6]).toFixed(alert_voldec_values),
                                        battery_charger_ac_current: parseFloat(TS_1F_data[7]).toFixed(alert_curdec_values),
                                        relay_voltage: parseFloat(TS_1F_data[8]).toFixed(alert_voldec_values),
                                        relay_current: parseFloat(TS_1F_data[9]).toFixed(alert_curdec_values),
                                        trv: parseFloat(TS_1F_data[10]).toFixed(alert_voldec_values),
                                        createddate: current_datetime
                                    }
                                    //logs.info('TS_1F', track_data)

                                    let transaction = await db.transaction({ autocommit: false });
                                    try {
                                        const tc_f_data_insert = await TrackCircuitFeederData.create(
                                            track_data,
                                            { transaction: transaction },
                                            { returning: true }
                                        );

                                        await transaction.commit();
                                        insert_feedertrack(track_data);
                                        logs.info("Track feeder data inserted");
                                        //console.log("Track feeder data inserted");
                                    }
                                    catch (ex) {
                                        await transaction.rollback();
                                        logs.error('mqtt error stationdata/TS_1F ' + ex);
                                        //console.log('mqtt error stationdata/TS_1F ' + ex);
                                    }

                                }
                            }
                        }

                        var allzero = TS_1F_data.slice(12, TS_1F_data.length).every(x => x === '0')

                        let signalcircuitid = parseInt(TS_1F_data[11]).toString(16).split("")[0];
                        let signalterminal = String.fromCharCode(parseInt((parseInt(TS_1F_data[11]).toString(16).split("")[1] + parseInt(TS_1F_data[11]).toString(16).split("")[2]), 16))

                        const register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                        if (register_signalid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                            const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)

                                const index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });
                                if (index !== -1) {
                                    signalcircuitAlive[index].value = moment()
                                    signalcircuitAlive[index].alive_limit = moment().add(parseInt(await get_alert_value(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)), 'seconds')
                                }
                                else {
                                    signalcircuitAlive.push({ key: signalcircuitid, value: moment(), alive_limit: moment().add(parseInt(await get_alert_value(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)), 'seconds'), stationname: get_stations.stationname, stationid: station_id, signalname: register_signalid.signalname });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SIGNAL_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await signalcircuit_compare(TS_1F_data.slice(12, TS_1F_data.length), signalcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let signal_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        signalcircuitid: parseInt(signalcircuitid),
                                        signalname: register_signalid.signalname,
                                        terminal: signalterminal,
                                        aspecttypeid: register_signalid.aspecttypeid,
                                        description: signalaspects.description,
                                        greenvoltage: parseFloat(TS_1F_data[12]).toFixed(alert_voldec_values),
                                        greencurrent: parseFloat(TS_1F_data[13]).toFixed(alert_curdec_values),
                                        redvoltage: parseFloat(TS_1F_data[14]).toFixed(alert_voldec_values),
                                        redcurrent: parseFloat(TS_1F_data[15]).toFixed(alert_curdec_values),
                                        yellowvoltage: parseFloat(TS_1F_data[16]).toFixed(alert_voldec_values),
                                        yellowcurrent: parseFloat(TS_1F_data[17]).toFixed(alert_curdec_values),
                                        lightyellowvoltage: parseFloat(TS_1F_data[18]).toFixed(alert_voldec_values),
                                        lightyellowcurrent: parseFloat(TS_1F_data[19]).toFixed(alert_curdec_values),
                                        createddate: current_datetime
                                    }

                                    await insert_signalcircuit(signal_data)

                                    //logs.info('TS_1F', signal_data)      
                                }
                            }
                        }

                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/TS_1F ' + ex);
                        //console.log('mqtt error stationdata/TS_1F ' + ex);
                    }
                }
            });
        });

        // Inactive - Track Circuit Relay & Signal Loop
        client.subscribe('stationdata/TS_1R', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/TS_1') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/TS_1R', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/TS_1R', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var TS_1R_data = packet.payload.toString().split(',');
                        //logs.info('stationdata/TS_1R', TS_1R_data)   

                        var allzero = TS_1R_data.slice(1, 11).every(x => x === '0')

                        let trackcircuitid = parseInt(TS_1R_data[0]).toString(16).split("")[0];
                        let trackterminal = String.fromCharCode(parseInt((parseInt(TS_1R_data[0]).toString(16).split("")[1] + parseInt(TS_1R_data[0]).toString(16).split("")[2]), 16))

                        const register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)

                                const index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });
                                if (index !== -1) {
                                    trackcircuitAlive[index].value = moment()
                                    trackcircuitAlive[index].alive_limit = moment().add(parseInt(await get_alert_value(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)), 'seconds')
                                }
                                else {
                                    trackcircuitAlive.push({ key: trackcircuitid, value: moment(), alive_limit: moment().add(parseInt(await get_alert_value(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)), 'seconds'), stationname: get_stations.stationname, stationid: station_id, trackname: register_trackid.trackname });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${asserts.assertname}@TRACK_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await trackcircuit_compare_Relay(TS_1R_data.slice(1, 11), trackcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let track_count = 1;
                                    const cycle_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === trackcircuitid; });
                                    if (cycle_index !== -1) {
                                        track_count = trackcircuitRelaydatas[cycle_index].value + 1
                                        trackcircuitRelaydatas[cycle_index].value = track_count
                                    }
                                    else {
                                        var RelayDatas = [await TrackCircuitRelayData.findOne({
                                            limit: 1,
                                            order: [["id", "DESC"]],
                                            where: { trackcircuitid: trackcircuitid },
                                            raw: true
                                        })];
                                        RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                                        if (RelayDatas.length > 0) {
                                            track_count = RelayDatas[0].count + 1
                                        }
                                        trackcircuitRelaydatas.push({ key: trackcircuitid, value: track_count });
                                    }

                                    let track_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        trackcircuitid: parseInt(trackcircuitid),
                                        trackcircuitterminal: trackterminal,
                                        trackname: register_trackid.trackname,
                                        count: track_count,
                                        feed_voltage: parseFloat(TS_1R_data[1]).toFixed(alert_voldec_values),
                                        feed_current: parseFloat(TS_1R_data[2]).toFixed(alert_curdec_values),
                                        choke_voltage: parseFloat(TS_1R_data[3]).toFixed(alert_voldec_values),
                                        battery_charger_dc_current: parseFloat(TS_1R_data[4]).toFixed(alert_curdec_values),
                                        battery_charger_dc_voltage: parseFloat(TS_1R_data[5]).toFixed(alert_voldec_values),
                                        battery_charger_ac_voltage: parseFloat(TS_1R_data[6]).toFixed(alert_voldec_values),
                                        battery_charger_ac_current: parseFloat(TS_1R_data[7]).toFixed(alert_curdec_values),
                                        relay_voltage: parseFloat(TS_1R_data[8]).toFixed(alert_voldec_values),
                                        relay_current: parseFloat(TS_1R_data[9]).toFixed(alert_curdec_values),
                                        trv: parseFloat(TS_1R_data[10]).toFixed(alert_voldec_values),
                                        createddate: current_datetime
                                    }
                                    //logs.info('TS_1R', track_data)

                                    let transaction = await db.transaction({ autocommit: false });
                                    try {
                                        const tc_f_data_insert = await TrackCircuitRelayData.create(
                                            track_data,
                                            { transaction: transaction },
                                            { returning: true }
                                        );

                                        await transaction.commit();
                                        insert_relaytrack(track_data);
                                        logs.info("Track relay data inserted");
                                        //console.log("Track relay data inserted");
                                    }
                                    catch (ex) {
                                        await transaction.rollback();
                                        logs.error('mqtt error stationdata/TS_1R ' + ex);
                                        //console.log('mqtt error stationdata/TS_1R ' + ex);
                                    }
                                }

                            }

                        }

                        var allzero = TS_1R_data.slice(12, TS_1R_data.length).every(x => x === '0')

                        let signalcircuitid = parseInt(TS_1R_data[11]).toString(16).split("")[0];
                        let signalterminal = String.fromCharCode(parseInt((parseInt(TS_1R_data[11]).toString(16).split("")[1] + parseInt(TS_1R_data[11]).toString(16).split("")[2]), 16))

                        const register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                        if (register_signalid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                            const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)

                                const index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });
                                if (index !== -1) {
                                    signalcircuitAlive[index].value = moment()
                                    signalcircuitAlive[index].alive_limit = moment().add(parseInt(await get_alert_value(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)), 'seconds')
                                }
                                else {
                                    signalcircuitAlive.push({ key: signalcircuitid, value: moment(), alive_limit: moment().add(parseInt(await get_alert_value(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)), 'seconds'), stationname: get_stations.stationname, stationid: station_id, signalname: register_signalid.signalname });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${signalcircuitid}@${asserts.assertname}@SIGNAL_CIRCUIT_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await signalcircuit_compare(TS_1R_data.slice(12, TS_1R_data.length), signalcircuitid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result === true) {
                                    let signal_data = {
                                        stationid: parseInt(get_stations.id),
                                        stationcode: get_stations.stationcode,
                                        stationname: get_stations.stationname,
                                        assertid: parseInt(asserts.id),
                                        assertname: asserts.assertname,
                                        signalcircuitid: parseInt(signalcircuitid),
                                        signalname: register_signalid.signalname,
                                        terminal: signalterminal,
                                        aspecttypeid: register_signalid.aspecttypeid,
                                        description: signalaspects.description,
                                        greenvoltage: parseFloat(TS_1R_data[12]).toFixed(alert_voldec_values),
                                        greencurrent: parseFloat(TS_1R_data[13]).toFixed(alert_curdec_values),
                                        redvoltage: parseFloat(TS_1R_data[14]).toFixed(alert_voldec_values),
                                        redcurrent: parseFloat(TS_1R_data[15]).toFixed(alert_curdec_values),
                                        yellowvoltage: parseFloat(TS_1R_data[16]).toFixed(alert_voldec_values),
                                        yellowcurrent: parseFloat(TS_1R_data[17]).toFixed(alert_curdec_values),
                                        lightyellowvoltage: parseFloat(TS_1R_data[18]).toFixed(alert_voldec_values),
                                        lightyellowcurrent: parseFloat(TS_1R_data[19]).toFixed(alert_curdec_values),
                                        createddate: current_datetime
                                    }
                                    await insert_signalcircuit(signal_data)

                                    //logs.info('TS_1R', signal_data)    
                                }

                            }
                        }
                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/TS_1R ' + ex);
                        //console.log('mqtt error stationdata/TS_1R ' + ex);
                    }
                }
            });
        });

        // Inactive - Feeder
        client.subscribe('stationdata/TC_1', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/TC_1') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        //logs.info('stationdata/TC_1F', moment().format("YYYY-MM-DD HH:mm:ss"))
                        //console.log('stationdata/TC_1F', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var TC_1F_data = packet.payload.toString().split(',');
                        //logs.info('stationdata/TC_1F', TC_1F_data)

                        let trackcircuitid = parseInt(TC_1F_data[0]).toString(16).split("")[0];
                        let trackterminal = String.fromCharCode(parseInt((parseInt(TC_1F_data[0]).toString(16).split("")[1] + parseInt(TC_1F_data[0]).toString(16).split("")[2]), 16))

                        const register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                            const get_track_previous_count = [await TrackCircuitFeederData.findOne({
                                limit: 1,
                                where: { trackcircuitid: trackcircuitid },
                                order: [["id", "DESC"]]
                            })];
                            get_track_previous_count = get_track_previous_count[0] !== null ? get_track_previous_count : []

                            var track_count = 1;
                            if (get_track_previous_count.length > 0) {
                                track_count = get_track_previous_count[0].count + 1
                            }

                            if (get_stations != null) {

                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)

                                // const index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });                        
                                // if(index !== -1)
                                // {
                                //     trackcircuitAlive[index].value = moment()
                                //     trackcircuitAlive[index].alive_limit = moment().add(parseInt(await get_alert_value(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)),'seconds') 
                                // }
                                // else
                                // {
                                //     trackcircuitAlive.push({ key: trackcircuitid , value: moment() , alive_limit : moment().add(parseInt(await get_alert_value(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)),'seconds') , stationname : get_stations.stationname , stationid : station_id , trackname : register_trackid.trackname});
                                // }

                                let track_data = {
                                    stationid: parseInt(get_stations.id),
                                    stationcode: get_stations.stationcode,
                                    stationname: get_stations.stationname,
                                    assertid: parseInt(asserts.id),
                                    assertname: asserts.assertname,
                                    trackcircuitid: parseInt(trackcircuitid),
                                    trackcircuitterminal: trackterminal,
                                    trackname: register_trackid.trackname,
                                    count: track_count,
                                    feederendvoltage: parseFloat(TC_1F_data[1]),
                                    feederendcurrent: parseFloat(TC_1F_data[2]),
                                    chokevoltage: parseFloat(TC_1F_data[3]),
                                    charger: parseFloat(TC_1F_data[4]),
                                    createddate: current_datetime
                                }

                                logs.info('TC_1F', track_data)

                                var last_feeder_data = await TrackCircuitFeederData.findOne({ where: { isdele: false, trackcircuitid: trackcircuitid, count: track_count }, order: [["id", "DESC"]] });
                                if (last_feeder_data == null) {
                                    let transaction = await db.transaction({ autocommit: false });
                                    try {
                                        const tc_f_data_insert = await TrackCircuitFeederData.create(
                                            track_data,
                                            { transaction: transaction },
                                            { returning: true }
                                        );

                                        await transaction.commit();
                                        await insert_feedertracknotification(track_data);
                                        logs.info("Track feeder data inserted");
                                        //console.log("Track feeder data inserted"); 
                                    }
                                    catch (ex) {
                                        await transaction.rollback();
                                        logs.error('mqtt error stationdata/TC_1F ' + ex);
                                        //console.log('mqtt error stationdata/TC_1F ' + ex);
                                    }
                                }
                            }
                        }

                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/TC_1F ' + ex);
                        //console.log('mqtt error stationdata/TC_1F ' + ex);
                    }
                }
            });
        });

        // Inactive - Relay
        client.subscribe('stationdata/TC_1', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/TC_1') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        //logs.info('stationdata/TC_1R', moment().format("YYYY-MM-DD HH:mm:ss"))
                        //console.log('stationdata/TC_1R', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var TC_1R_data = packet.payload.toString().split(',');
                        //logs.info('stationdata/TC_1R', TC_1R_data)

                        let trackcircuitid = parseInt(TC_1R_data[0]).toString(16).split("")[0];
                        let trackterminal = String.fromCharCode(parseInt((parseInt(TC_1R_data[0]).toString(16).split("")[1] + parseInt(TC_1R_data[0]).toString(16).split("")[2]), 16))

                        const register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                            const get_track_previous_count = [await TrackCircuitRelayData.findOne({
                                limit: 1,
                                where: { trackcircuitid: trackcircuitid },
                                order: [["id", "DESC"]]
                            })];
                            get_track_previous_count = get_track_previous_count[0] !== null ? get_track_previous_count : []

                            var track_count = 1;
                            if (get_track_previous_count.length > 0 && get_track_previous_count[0] !== null) {
                                track_count = get_track_previous_count[0].count + 1
                            }

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)

                                // const index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });                        
                                // if(index !== -1)
                                // {
                                //     trackcircuitAlive[index].value = moment()
                                //     trackcircuitAlive[index].alive_limit = moment().add(parseInt(await get_alert_value(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)),'seconds') 
                                // }
                                // else
                                // {
                                //     trackcircuitAlive.push({ key: trackcircuitid , value: moment() , alive_limit : moment().add(parseInt(await get_alert_value(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)),'seconds') , stationname : get_stations.stationname , stationid : station_id , trackname : register_trackid.trackname});
                                // }


                                let track_data = {
                                    stationid: parseInt(get_stations.id),
                                    stationcode: get_stations.stationcode,
                                    stationname: get_stations.stationname,
                                    assertid: parseInt(asserts.id),
                                    assertname: asserts.assertname,
                                    trackcircuitid: parseInt(trackcircuitid),
                                    trackcircuitterminal: trackterminal,
                                    trackname: register_trackid.trackname,
                                    count: track_count,
                                    relayendvoltage: parseFloat(TC_1R_data[5]),
                                    relayendcurrent: parseFloat(TC_1R_data[6]),
                                    trackvoltage: parseFloat(TC_1R_data[7]),
                                    createddate: current_datetime
                                }

                                logs.info('TC_1R', track_data)

                                var last_relay_data = await TrackCircuitRelayData.findOne({ where: { isdele: false, trackcircuitid: trackcircuitid, count: track_count }, order: [["id", "DESC"]] });

                                let transaction = await db.transaction({ autocommit: false });
                                try {
                                    if (last_relay_data == null) {
                                        const tc_f_data_insert = await TrackCircuitRelayData.create(
                                            track_data,
                                            { transaction: transaction },
                                            { returning: true }
                                        );

                                        await transaction.commit();
                                        await insert_relaytracknotification(track_data);
                                        logs.info("Track relay data inserted");
                                        //console.log("Track relay data inserted");
                                    }
                                }
                                catch (ex) {
                                    await transaction.rollback();
                                    logs.error('mqtt error stationdata/TC_1R ' + ex);
                                    //console.log('mqtt error stationdata/TC_1R ' + ex);
                                }
                            }
                        }
                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/TC_1R ' + ex);
                        //console.log('mqtt error stationdata/TC_1R ' + ex);
                    }
                }
            });
        });

        // Inactive - Feeder
        client.subscribe('stationdata/TC_1', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/TC_1') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        //logs.info('stationdata/TC_1F', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/TC_1F', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var TC_1F_data = packet.payload.toString().split(',');
                        //logs.info('stationdata/TC_1F', TC_1F_data)

                        let trackcircuitid = parseInt(TC_1F_data[0]).toString(16).split("")[0];
                        let trackterminal = String.fromCharCode(parseInt((parseInt(TC_1F_data[0]).toString(16).split("")[1] + parseInt(TC_1F_data[0]).toString(16).split("")[2]), 16))

                        const register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)

                                // const index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });                        
                                // if(index !== -1)
                                // {
                                //     trackcircuitAlive[index].value = moment()
                                //     trackcircuitAlive[index].alive_limit = moment().add(parseInt(await get_alert_value(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)),'seconds') 
                                // }
                                // else
                                // {
                                //     trackcircuitAlive.push({ key: trackcircuitid , value: moment() , alive_limit : moment().add(parseInt(await get_alert_value(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)),'seconds') , stationname : get_stations.stationname , stationid : station_id , trackname : register_trackid.trackname});
                                // }

                                let track_details = {
                                    stationid: parseInt(get_stations.id),
                                    stationcode: get_stations.stationcode,
                                    stationname: get_stations.stationname,
                                    assertid: parseInt(asserts.id),
                                    assertname: asserts.assertname,
                                    trackcircuitid: parseInt(trackcircuitid),
                                    trackcircuitterminal: trackterminal,
                                    trackname: register_trackid.trackname,
                                    feed_count: 0,
                                    feed_voltage: parseFloat(TC_1F_data[1]),
                                    feed_current: parseFloat(TC_1F_data[2]),
                                    choke_voltage: parseFloat(TC_1F_data[3]),
                                    charger: parseFloat(TC_1F_data[4]),
                                    relay_count: 0,
                                    relay_voltage: parseFloat(TC_1F_data[5]),
                                    relay_current: parseFloat(TC_1F_data[6]),
                                    trv: parseFloat(TC_1F_data[7]),
                                    index_score: 5,
                                    leakage_current: Math.abs(parseFloat(TC_1F_data[2]) - parseFloat(TC_1F_data[6])).toFixed(alert_curdec_values) * 1000,
                                    health: 'OK',
                                    track_OC: Math.sign(parseFloat(fed_cur) - parseFloat(rel_cur)) === 1 ? (parseFloat(rel_cur)) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${asserts.assertname}@MAX_TRACK_OC`)) ? 'O' : 'C' : 'C',
                                    createddate: current_datetime
                                }


                                let track_data = {
                                    trackcircuitid: parseInt(trackcircuitid),
                                    feed_count: 0,
                                    feed_voltage: parseFloat(TC_1F_data[1]),
                                    feed_current: parseFloat(TC_1F_data[2]),
                                    choke_voltage: parseFloat(TC_1F_data[3]),
                                    charger: parseFloat(TC_1F_data[4]),
                                    relay_count: 0,
                                    relay_voltage: parseFloat(TC_1F_data[5]),
                                    relay_current: parseFloat(TC_1F_data[6]),
                                    trv: parseFloat(TC_1F_data[7]),
                                    index_score: 5,
                                    leakage_current: Math.abs(parseFloat(TC_1F_data[2]) - parseFloat(TC_1F_data[6])).toFixed(alert_curdec_values) * 1000,
                                    health: 'OK',
                                    track_OC: Math.sign(parseFloat(fed_cur) - parseFloat(rel_cur)) === 1 ? (parseFloat(rel_cur)) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${asserts.assertname}@MAX_TRACK_OC`)) ? 'O' : 'C' : 'C',
                                    createddate: current_datetime,
                                    isdele: false
                                }

                                logs.info('TC_1F', track_data)

                                let transaction = await db.transaction({ autocommit: false });
                                try {
                                    let dataid = ""
                                    const tc_f_data_insert = await TrackCircuitData.create(
                                        track_data,
                                        { transaction: transaction },
                                        { returning: true }
                                    ).then(res => dataid = res.id);

                                    await transaction.commit();
                                    await insert_trackcircuit(track_details, dataid);
                                    logs.info("Track feeder data inserted");
                                    //console.log("Track feeder data inserted");   
                                }
                                catch (ex) {
                                    await transaction.rollback();
                                    logs.error('mqtt error stationdata/TC_1F ' + ex);
                                    //console.log('mqtt error stationdata/TC_1F ' + ex);
                                }
                            }
                        }

                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/TS_1F ' + ex);
                        //console.log('mqtt error stationdata/TC_1F ' + ex);
                    }
                }
            });
        });

        // Inactive - Relay
        client.subscribe('stationdata/TC_1', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/TC_1') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        //logs.info('stationdata/TC_1R', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/TC_1R', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var TC_1R_data = packet.payload.toString().split(',');
                        //logs.info('stationdata/TC_1R', TC_1R_data)                     

                        let trackcircuitid = parseInt(TC_1R_data[0]).toString(16).split("")[0];
                        let trackterminal = String.fromCharCode(parseInt((parseInt(TC_1R_data[0]).toString(16).split("")[1] + parseInt(TC_1R_data[0]).toString(16).split("")[2]), 16))

                        const get_track_previous_count = [await TrackCircuitRelayData.findOne({
                            limit: 1,
                            where: { trackcircuitid: trackcircuitid },
                            order: [["id", "DESC"]]
                        })];
                        get_track_previous_count = get_track_previous_count[0] !== null ? get_track_previous_count : []

                        var track_count = 1;
                        if (get_track_previous_count.length > 0) {
                            track_count = get_track_previous_count[0].count + 1
                        }

                        const register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)

                                // const index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });                        
                                // if(index !== -1)
                                // {
                                //     trackcircuitAlive[index].value = moment()
                                //     trackcircuitAlive[index].alive_limit = moment().add(parseInt(await get_alert_value(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)),'seconds') 
                                // }
                                // else
                                // {
                                //     trackcircuitAlive.push({ key: trackcircuitid , value: moment() , alive_limit : moment().add(parseInt(await get_alert_value(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)),'seconds') , stationname : get_stations.stationname , stationid : station_id , trackname : register_trackid.trackname});
                                // }

                                let track_details = {
                                    stationid: parseInt(get_stations.id),
                                    stationcode: get_stations.stationcode,
                                    stationname: get_stations.stationname,
                                    assertid: parseInt(asserts.id),
                                    assertname: asserts.assertname,
                                    trackcircuitid: parseInt(trackcircuitid),
                                    trackcircuitterminal: trackterminal,
                                    trackname: register_trackid.trackname,
                                    feed_count: 0,
                                    feed_voltage: parseFloat(TC_1R_data[1]),
                                    feed_current: parseFloat(TC_1R_data[2]),
                                    choke_voltage: parseFloat(TC_1R_data[3]),
                                    charger: parseFloat(TC_1R_data[4]),
                                    relay_count: 0,
                                    relay_voltage: parseFloat(TC_1R_data[5]),
                                    relay_current: parseFloat(TC_1R_data[6]),
                                    trv: parseFloat(TC_1R_data[7]),
                                    index_score: 5,
                                    leakage_current: Math.abs(parseFloat(TC_1R_data[2]) - parseFloat(TC_1R_data[6])).toFixed(alert_curdec_values) * 1000,
                                    health: 'OK',
                                    track_OC: Math.sign(parseFloat(fed_cur) - parseFloat(rel_cur)) === 1 ? (parseFloat(rel_cur)) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${asserts.assertname}@MAX_TRACK_OC`)) ? 'O' : 'C' : 'C',
                                    createddate: current_datetime
                                }

                                let track_data = {
                                    trackcircuitid: parseInt(trackcircuitid),
                                    feed_count: 0,
                                    feed_voltage: parseFloat(TC_1R_data[1]),
                                    feed_current: parseFloat(TC_1R_data[2]),
                                    choke_voltage: parseFloat(TC_1R_data[3]),
                                    charger: parseFloat(TC_1R_data[4]),
                                    relay_count: 0,
                                    relay_voltage: parseFloat(TC_1R_data[5]),
                                    relay_current: parseFloat(TC_1R_data[6]),
                                    trv: parseFloat(TC_1R_data[7]),
                                    index_score: 5,
                                    leakage_current: Math.abs(parseFloat(TC_1R_data[2]) - parseFloat(TC_1R_data[6])).toFixed(alert_curdec_values) * 1000,
                                    health: 'OK',
                                    track_OC: Math.sign(parseFloat(fed_cur) - parseFloat(rel_cur)) === 1 ? (parseFloat(rel_cur)) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${asserts.assertname}@MAX_TRACK_OC`)) ? 'O' : 'C' : 'C',
                                    createddate: current_datetime,
                                    isdele: false
                                }

                                logs.info('TC_1R', track_data)

                                let transaction = await db.transaction({ autocommit: false });
                                try {
                                    let dataid = ""
                                    const tc_r_data_insert = await TrackCircuitData.create(
                                        track_data,
                                        { transaction: transaction },
                                        { returning: true }
                                    ).then(res => dataid = res.id);

                                    await transaction.commit();
                                    await insert_trackcircuit(track_details, dataid);
                                    logs.info("Track relay data inserted");
                                    //console.log("Track relay data inserted");   
                                }
                                catch (ex) {
                                    await transaction.rollback();
                                    logs.error('mqtt error stationdata/TC_1R ' + ex);
                                    //console.log('mqtt error stationdata/TC_1R ' + ex);
                                }

                            }
                        }

                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/TS_1R ' + ex);
                        //console.log('mqtt error stationdata/TC_1R ' + ex);
                    }
                }
            });
        });

        // Inactive - Signal 1A
        client.subscribe('stationdata/SC_1', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/SC_1') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        //logs.info('stationdata/SC_1A', moment().format("YYYY-MM-DD HH:mm:ss"))
                        //console.log('stationdata/SC_1A', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var sc_1A_data = packet.payload.toString().split(',');
                        //logs.info('stationdata/SC_1A', sc_1A_data)  

                        let signalcircuitid = parseInt(sc_1A_data[0]).toString(16).split("")[0]
                        let signalterminal = String.fromCharCode(parseInt((parseInt(sc_1A_data[0]).toString(16).split("")[1] + parseInt(sc_1A_data[0]).toString(16).split("")[2]), 16))

                        const register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                        if (register_signalid != null) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                            const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)

                                // const index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });                        
                                // if(index !== -1)
                                // {
                                //     signalcircuitAlive[index].value = moment()
                                //     signalcircuitAlive[index].alive_limit = moment().add(parseInt(await get_alert_value(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)),'seconds') 
                                // }
                                // else
                                // {
                                //     signalcircuitAlive.push({ key: signalcircuitid , value: moment() , alive_limit : moment().add(parseInt(await get_alert_value(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)),'seconds') , stationname : get_stations.stationname , stationid : station_id , signalname : register_signalid.signalname});
                                // }

                                let signal_data = {
                                    stationid: parseInt(get_stations.id),
                                    stationcode: get_stations.stationcode,
                                    stationname: get_stations.stationname,
                                    assertid: parseInt(asserts.id),
                                    assertname: asserts.assertname,
                                    signalcircuitid: parseInt(signalcircuitid),
                                    signalname: register_signalid.signalname,
                                    terminal: signalterminal,
                                    aspecttypeid: register_signalid.aspecttypeid,
                                    description: signalaspects.description,
                                    greenvoltage: parseFloat(sc_1A_data[1]).toFixed(alert_voldec_values),
                                    greencurrent: parseFloat(sc_1A_data[2]).toFixed(alert_curdec_values),
                                    redvoltage: parseFloat(sc_1A_data[3]).toFixed(alert_voldec_values),
                                    redcurrent: parseFloat(sc_1A_data[4]).toFixed(alert_curdec_values),
                                    yellowvoltage: parseFloat(sc_1A_data[5]).toFixed(alert_voldec_values),
                                    yellowcurrent: parseFloat(sc_1A_data[6]).toFixed(alert_curdec_values),
                                    lightyellowvoltage: parseFloat(sc_1A_data[7]).toFixed(alert_voldec_values),
                                    lightyellowcurrent: parseFloat(sc_1A_data[8]).toFixed(alert_curdec_values),
                                    createddate: current_datetime
                                }
                                logs.info('SC_1A', signal_data)

                                await insert_signalcircuit(signal_data)

                            }
                        }
                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/SC_1A ' + ex);
                        //console.log('mqtt error stationdata/SC_1A ' + ex);
                    }
                }
            });
        });

        // Inactive - Signal 1B
        client.subscribe('stationdata/SC_1', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/SC_1') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        //logs.info('stationdata/SC_1B', moment().format("YYYY-MM-DD HH:mm:ss"))
                        //console.log('stationdata/SC_1B', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var SC_1B_data = packet.payload.toString().split(',');
                        //logs.info('stationdata/SC_1B', SC_1B_data)  

                        let signalcircuitid = parseInt(SC_1B_data[0]).toString(16).split("")[0]
                        let signalterminal = String.fromCharCode(parseInt((parseInt(SC_1B_data[0]).toString(16).split("")[1] + parseInt(SC_1B_data[0]).toString(16).split("")[2]), 16))

                        const register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                        if (register_signalid != null) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                            const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)

                                // const index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });                        
                                // if(index !== -1)
                                // {
                                //     signalcircuitAlive[index].value = moment()
                                //     signalcircuitAlive[index].alive_limit = moment().add(parseInt(await get_alert_value(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)),'seconds') 
                                // }
                                // else
                                // {
                                //     signalcircuitAlive.push({ key: signalcircuitid , value: moment() , alive_limit : moment().add(parseInt(await get_alert_value(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)),'seconds') , stationname : get_stations.stationname , stationid : station_id , signalname : register_signalid.signalname});
                                // }

                                let signal_data = {
                                    stationid: parseInt(get_stations.id),
                                    stationcode: get_stations.stationcode,
                                    stationname: get_stations.stationname,
                                    assertid: parseInt(asserts.id),
                                    assertname: asserts.assertname,
                                    signalcircuitid: parseInt(signalcircuitid),
                                    signalname: register_signalid.signalname,
                                    terminal: signalterminal,
                                    aspecttypeid: register_signalid.aspecttypeid,
                                    description: signalaspects.description,
                                    greenvoltage: parseFloat(SC_1B_data[1]).toFixed(alert_voldec_values),
                                    greencurrent: parseFloat(SC_1B_data[2]).toFixed(alert_curdec_values),
                                    redvoltage: parseFloat(SC_1B_data[3]).toFixed(alert_voldec_values),
                                    redcurrent: parseFloat(SC_1B_data[4]).toFixed(alert_curdec_values),
                                    yellowvoltage: parseFloat(SC_1B_data[5]).toFixed(alert_voldec_values),
                                    yellowcurrent: parseFloat(SC_1B_data[6]).toFixed(alert_curdec_values),
                                    lightyellowvoltage: parseFloat(SC_1B_data[7]).toFixed(alert_voldec_values),
                                    lightyellowcurrent: parseFloat(SC_1B_data[8]).toFixed(alert_curdec_values),
                                    createddate: current_datetime
                                }
                                logs.info('SC_1B', signal_data)

                                await insert_signalcircuit(signal_data)


                            }
                        }
                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/SC_1B ' + ex);
                        //console.log('mqtt error stationdata/SC_1B ' + ex);
                    }
                }
            });
        });

        // Inactive - Feeder & Signal 
        client.subscribe('stationdata/TS_1', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/TS_1') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        //logs.info('stationdata/TS_1F', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/TS_1F', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var TS_1F_data = packet.payload.toString().split(',');
                        //logs.info('stationdata/TS_1F', TS_1F_data)  

                        let trackcircuitid = parseInt(TS_1F_data[0]).toString(16).split("")[0];
                        let trackterminal = String.fromCharCode(parseInt((parseInt(TS_1F_data[0]).toString(16).split("")[1] + parseInt(TS_1F_data[0]).toString(16).split("")[2]), 16))

                        let signalcircuitid = parseInt(TS_1F_data[8]).toString(16).split("")[0];
                        let signalterminal = String.fromCharCode(parseInt((parseInt(TS_1F_data[8]).toString(16).split("")[1] + parseInt(TS_1F_data[8]).toString(16).split("")[2]), 16))

                        const get_track_previous_count = [await TrackCircuitFeederData.findOne({
                            limit: 1,
                            where: { trackcircuitid: trackcircuitid },
                            order: [["id", "DESC"]]
                        })];
                        get_track_previous_count = get_track_previous_count[0] !== null ? get_track_previous_count : []

                        var track_count = 1;
                        if (get_track_previous_count.length > 0) {
                            track_count = get_track_previous_count[0].count + 1
                        }

                        const register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)

                                // const index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });                        
                                // if(index !== -1)
                                // {
                                //     trackcircuitAlive[index].value = moment()
                                //     trackcircuitAlive[index].alive_limit = moment().add(parseInt(await get_alert_value(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)),'seconds') 
                                // }
                                // else
                                // {
                                //     trackcircuitAlive.push({ key: trackcircuitid , value: moment() , alive_limit : moment().add(parseInt(await get_alert_value(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)),'seconds') , stationname : get_stations.stationname , stationid : station_id , trackname : register_trackid.trackname});
                                // }

                                let track_data = {
                                    stationid: parseInt(get_stations.id),
                                    stationcode: get_stations.stationcode,
                                    stationname: get_stations.stationname,
                                    assertid: parseInt(asserts.id),
                                    assertname: asserts.assertname,
                                    trackcircuitid: parseInt(trackcircuitid),
                                    trackcircuitterminal: trackterminal,
                                    trackname: register_trackid.trackname,
                                    count: track_count,
                                    feederendvoltage: parseFloat(TS_1F_data[1]),
                                    feederendcurrent: parseFloat(TS_1F_data[2]),
                                    chokevoltage: parseFloat(TS_1F_data[3]),
                                    charger: parseFloat(TS_1F_data[4]),
                                    createddate: current_datetime
                                }

                                logs.info('TS_1F', track_data)
                                let transaction = await db.transaction({ autocommit: false });
                                try {
                                    const tc_f_data_insert = await TrackCircuitFeederData.create(
                                        track_data,
                                        { transaction: transaction },
                                        { returning: true }
                                    );

                                    await transaction.commit();
                                    await insert_feedertracknotification(track_data);
                                    logs.info("Track feeder data inserted");
                                    //console.log("Track feeder data inserted");   
                                }
                                catch (ex) {
                                    await transaction.rollback();
                                    logs.error('mqtt error stationdata/TS_1F ' + ex);
                                    //console.log('mqtt error stationdata/TS_1F ' + ex);
                                }
                            }
                        }

                        const register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                        if (register_signalid != null) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                            const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)

                                // const index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });                        
                                // if(index !== -1)
                                // {
                                //     signalcircuitAlive[index].value = moment()
                                //     signalcircuitAlive[index].alive_limit = moment().add(parseInt(await get_alert_value(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)),'seconds') 
                                // }
                                // else
                                // {
                                //     signalcircuitAlive.push({ key: signalcircuitid , value: moment() , alive_limit : moment().add(parseInt(await get_alert_value(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)),'seconds') , stationname : get_stations.stationname , stationid : station_id , signalname : register_signalid.signalname});
                                // }  

                                let signal_data = {
                                    stationid: parseInt(get_stations.id),
                                    stationcode: get_stations.stationcode,
                                    stationname: get_stations.stationname,
                                    assertid: parseInt(asserts.id),
                                    assertname: asserts.assertname,
                                    signalcircuitid: parseInt(signalcircuitid),
                                    signalname: register_signalid.signalname,
                                    terminal: signalterminal,
                                    aspecttypeid: register_signalid.aspecttypeid,
                                    description: signalaspects.description,
                                    greenvoltage: parseFloat(TS_1F_data[6]).toFixed(alert_voldec_values),
                                    greencurrent: parseFloat(TS_1F_data[7]).toFixed(alert_curdec_values),
                                    redvoltage: parseFloat(TS_1F_data[8]).toFixed(alert_voldec_values),
                                    redcurrent: parseFloat(TS_1F_data[9]).toFixed(alert_curdec_values),
                                    yellowvoltage: parseFloat(TS_1F_data[10]).toFixed(alert_voldec_values),
                                    yellowcurrent: parseFloat(TS_1F_data[11]).toFixed(alert_curdec_values),
                                    lightyellowvoltage: parseFloat(TS_1F_data[12]).toFixed(alert_voldec_values),
                                    lightyellowcurrent: parseFloat(TS_1F_data[13]).toFixed(alert_curdec_values),
                                    createddate: current_datetime
                                }
                                logs.info('TS_1F', signal_data)

                                await insert_signalcircuit(signal_data)

                            }
                        }

                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/TS_1F ' + ex);
                        //console.log('mqtt error stationdata/TS_1F ' + ex);
                    }
                }
            });
        });

        // Inactive - Relay & Signal
        client.subscribe('stationdata/TS_1', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/TS_1') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        //logs.info('stationdata/TS_1R', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/TS_1R', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var TS_1R_data = packet.payload.toString().split(',');
                        //logs.info('stationdata/TS_1R', TS_1R_data)   

                        let trackcircuitid = parseInt(TS_1R_data[0]).toString(16).split("")[0];
                        let trackterminal = String.fromCharCode(parseInt((parseInt(TS_1R_data[0]).toString(16).split("")[1] + parseInt(TS_1R_data[0]).toString(16).split("")[2]), 16))

                        let signalcircuitid = parseInt(TS_1R_data[8]).toString(16).split("")[0];
                        let signalterminal = String.fromCharCode(parseInt((parseInt(TS_1R_data[8]).toString(16).split("")[1] + parseInt(TS_1R_data[8]).toString(16).split("")[2]), 16))

                        const get_track_previous_count = [await TrackCircuitRelayData.findOne({
                            limit: 1,
                            where: { trackcircuitid: trackcircuitid },
                            order: [["id", "DESC"]]
                        })];
                        get_track_previous_count = get_track_previous_count[0] !== null ? get_track_previous_count : []

                        var track_count = 1;
                        if (get_track_previous_count.length > 0) {
                            track_count = get_track_previous_count[0].count + 1
                        }

                        const register_trackid = await RegisteredTrackCircuit.findOne({ where: { id: trackcircuitid, isdele: false } })
                        if (register_trackid != null) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_trackid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Track Circuit" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)

                                // const index = trackcircuitAlive.findIndex(obj => { return obj.key === trackcircuitid; });                        
                                // if(index !== -1)
                                // {
                                //     trackcircuitAlive[index].value = moment()
                                //     trackcircuitAlive[index].alive_limit = moment().add(parseInt(await get_alert_value(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)),'seconds') 
                                // }
                                // else
                                // {
                                //     trackcircuitAlive.push({ key: trackcircuitid , value: moment() , alive_limit : moment().add(parseInt(await get_alert_value(`${station_id}@${trackcircuitid}@${asserts.assertname}@SET_TRACK_CIRCUIT_ALIVE`)),'seconds') , stationname : get_stations.stationname , stationid : station_id , trackname : register_trackid.trackname});
                                // }

                                let track_data = {
                                    stationid: parseInt(get_stations.id),
                                    stationcode: get_stations.stationcode,
                                    stationname: get_stations.stationname,
                                    assertid: parseInt(asserts.id),
                                    assertname: asserts.assertname,
                                    trackcircuitid: parseInt(trackcircuitid),
                                    trackcircuitterminal: trackterminal,
                                    trackname: register_trackid.trackname,
                                    count: track_count,
                                    relayendvoltage: parseFloat(TS_1R_data[5]),
                                    relayendcurrent: parseFloat(TS_1R_data[6]),
                                    trackvoltage: parseFloat(TS_1R_data[7]),
                                    createddate: current_datetime
                                }

                                logs.info('TS_1R', track_data)

                                let transaction = await db.transaction({ autocommit: false });
                                try {
                                    const tc_f_data_insert = await TrackCircuitRelayData.create(
                                        track_data,
                                        { transaction: transaction },
                                        { returning: true }
                                    );

                                    await transaction.commit();
                                    await insert_relaytracknotification(track_data);
                                    logs.info("Track relay data inserted");
                                    //console.log("Track relay data inserted");
                                }
                                catch (ex) {
                                    await transaction.rollback();
                                    logs.error('mqtt error stationdata/TS_1R ' + ex);
                                    //console.log('mqtt error stationdata/TS_1R ' + ex);
                                }

                            }
                        }

                        const register_signalid = await RegisteredSignalCircuit.findOne({ where: { id: signalcircuitid, isdele: false } })
                        if (register_signalid != null) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_signalid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "Signal Circuit" } })
                            const signalaspects = await SignalAspectType.findOne({ where: { id: register_signalid.aspecttypeid } })
                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)

                                // const index = signalcircuitAlive.findIndex(obj => { return obj.key === signalcircuitid; });                        
                                // if(index !== -1)
                                // {
                                //     signalcircuitAlive[index].value = moment()
                                //     signalcircuitAlive[index].alive_limit = moment().add(parseInt(await get_alert_value(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)),'seconds') 
                                // }
                                // else
                                // {
                                //     signalcircuitAlive.push({ key: signalcircuitid , value: moment() , alive_limit : moment().add(parseInt(await get_alert_value(`${station_id}@${signalcircuitid}@${asserts.assertname}@SET_SIGNAL_CIRCUIT_ALIVE`)),'seconds') , stationname : get_stations.stationname , stationid : station_id , signalname : register_signalid.signalname});
                                // }  

                                let signal_data = {
                                    stationid: parseInt(get_stations.id),
                                    stationcode: get_stations.stationcode,
                                    stationname: get_stations.stationname,
                                    assertid: parseInt(asserts.id),
                                    assertname: asserts.assertname,
                                    signalcircuitid: parseInt(signalcircuitid),
                                    signalname: register_signalid.signalname,
                                    terminal: signalterminal,
                                    aspecttypeid: register_signalid.aspecttypeid,
                                    description: signalaspects.description,
                                    greenvoltage: parseFloat(TS_1R_data[6]).toFixed(alert_voldec_values),
                                    greencurrent: parseFloat(TS_1R_data[7]).toFixed(alert_curdec_values),
                                    redvoltage: parseFloat(TS_1R_data[8]).toFixed(alert_voldec_values),
                                    redcurrent: parseFloat(TS_1R_data[9]).toFixed(alert_curdec_values),
                                    yellowvoltage: parseFloat(TS_1R_data[10]).toFixed(alert_voldec_values),
                                    yellowcurrent: parseFloat(TS_1R_data[11]).toFixed(alert_curdec_values),
                                    lightyellowvoltage: parseFloat(TS_1R_data[12]).toFixed(alert_voldec_values),
                                    lightyellowcurrent: parseFloat(TS_1R_data[13]).toFixed(alert_curdec_values),
                                    createddate: current_datetime
                                }
                                logs.info('TS_1R', signal_data)

                                await insert_signalcircuit(signal_data)

                            }
                        }

                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/TS_1R ' + ex);
                        //console.log('mqtt error stationdata/TS_1R ' + ex);
                    }
                }
            });
        });

        // Inactive- Ips
        client.subscribe('stationdata/IPS1', function () {
            client.on('message', async function (topic, message, packet) {
                if (packet.topic === 'stationdata/IPS1') {
                    try {
                        global.gc()
                        alert_value_list = require("./alertvalue").getValues();
                        logs.info('stationdata/IPS', moment().format("YYYY-MM-DD HH:mm:ss"));
                        //console.log('stationdata/IPS', moment().format("YYYY-MM-DD HH:mm:ss"))
                        const current_datetime = moment().format("YYYY-MM-DD HH:mm:ss");
                        var ipsdata = packet.payload.toString().split(',');
                        logs.info('stationdata/IPS', ipsdata)

                        var allzero = ipsdata.slice(1, ipsdata.length).every(x => x === '0')

                        var ipsid = parseInt(parseInt(ipsdata[0]).toString(16).split("")[0], 16).toString();

                        var register_ipsid = await RegisteredIPS.findOne({ attributes: [['id', 'ipsid'], 'stationid', 'ipsname'], where: { id: ipsid, isdele: false }, raw: true })
                        if (register_ipsid != null && allzero == false) {
                            const get_stations = await RegisteredRailwayStations.findOne({ where: { id: register_ipsid.stationid, isdele: false } })
                            const asserts = await Asserts.findOne({ where: { assertname: "IPS" } })

                            if (get_stations != null) {
                                let station_id = parseInt(get_stations.id)

                                let alert_voldec_values = parseFloat(process.env.VOLTAGE_DECIMAL_POINT)
                                let alert_curdec_values = parseFloat(process.env.CURRENT_DECIMAL_POINT)
                                let alert_ipsalive_values = await get_alerts(`${station_id}@${ipsid}@${asserts.assertname}@SET_IPS_ALIVE`)

                                var index = ipsAlive.findIndex(obj => { return obj.key === ipsid; });
                                if (index !== -1) {
                                    ipsAlive[index].value = moment()
                                    ipsAlive[index].alive_limit = moment().add(parseInt(alert_ipsalive_values.value), 'seconds')
                                    ipsAlive[index].message = await combine_mes_val_unit(alert_ipsalive_values.message, alert_ipsalive_values.value, alert_ipsalive_values.unit)
                                }
                                else {
                                    ipsAlive.push({
                                        key: ipsid, value: moment(), alive_limit: moment().add(parseInt(alert_ipsalive_values.value), 'seconds'),
                                        message: await combine_mes_val_unit(alert_ipsalive_values.message, alert_ipsalive_values.value, alert_ipsalive_values.unit), mode: alert_ipsalive_values.mode, id: alert_ipsalive_values.id, stationname: get_stations.stationname, stationid: station_id, stationcode: get_stations.stationcode, assertname: asserts.assertname, assertid: asserts.id, assertidname: register_ipsid.ipsname
                                    });
                                }

                                var alert_name_values = await get_alerts(`${station_id}@${ipsid}@${asserts.assertname}@IPS_PERCENTAGE_DIFFERENCE`)
                                var compare_result = false
                                if (alert_name_values.isactive === true) {
                                    compare_result = await ips_compare(ipsdata.slice(1, ipsdata.length), ipsid, alert_name_values.value)
                                }
                                else {
                                    compare_result = true
                                }

                                if (compare_result == true) {
                                    let ips_data = {
                                        ipsid: register_ipsid.ipsid,
                                        vdc_24_terminal: ipsdata[1],
                                        relay_internal_voltage: parseFloat(ipsdata[2]).toFixed(alert_voldec_values),
                                        ri_current_1: parseFloat(ipsdata[3]).toFixed(alert_curdec_values),
                                        ri_current_2: parseFloat(ipsdata[4]).toFixed(alert_curdec_values),
                                        ri_current_3: parseFloat(ipsdata[5]).toFixed(alert_curdec_values),
                                        ri_current_4: parseFloat(ipsdata[5]).toFixed(alert_curdec_values),
                                        ri_current_5: parseFloat(ipsdata[6]).toFixed(alert_curdec_values),
                                        ri_current_6: parseFloat(ipsdata[7]).toFixed(alert_curdec_values),
                                        relay_external_voltage: parseFloat(ipsdata[8]).toFixed(alert_voldec_values),
                                        re_current_1: parseFloat(ipsdata[9]).toFixed(alert_curdec_values),
                                        re_current_2: parseFloat(ipsdata[10]).toFixed(alert_curdec_values),
                                        re_current_3: parseFloat(ipsdata[11]).toFixed(alert_curdec_values),
                                        re_current_4: parseFloat(ipsdata[12]).toFixed(alert_curdec_values),
                                        re_current_5: parseFloat(ipsdata[13]).toFixed(alert_curdec_values),
                                        re_current_6: parseFloat(ipsdata[14]).toFixed(alert_curdec_values),
                                        data_logger_supply: parseFloat(ipsdata[15]).toFixed(alert_voldec_values),
                                        dl_current_1: parseFloat(ipsdata[16]).toFixed(alert_curdec_values),
                                        dl_current_2: parseFloat(ipsdata[17]).toFixed(alert_curdec_values),
                                        vdu_pc_voltage: parseFloat(ipsdata[18]).toFixed(alert_voldec_values),
                                        vdu_current_1: parseFloat(ipsdata[19]).toFixed(alert_curdec_values),
                                        vdu_current_2: parseFloat(ipsdata[20]).toFixed(alert_curdec_values),
                                        ssicha_voltage: parseFloat(ipsdata[21]).toFixed(alert_voldec_values),
                                        ssicha_current_1: parseFloat(ipsdata[22]).toFixed(alert_curdec_values),
                                        ssicha_current_2: parseFloat(ipsdata[23]).toFixed(alert_curdec_values),
                                        ssicha_current_3: parseFloat(ipsdata[24]).toFixed(alert_curdec_values),
                                        ssicha_current_4: parseFloat(ipsdata[25]).toFixed(alert_curdec_values),
                                        ssichb_voltage: parseFloat(ipsdata[26]).toFixed(alert_voldec_values),
                                        ssichb_current_1: parseFloat(ipsdata[27]).toFixed(alert_curdec_values),
                                        ssichb_current_2: parseFloat(ipsdata[28]).toFixed(alert_curdec_values),
                                        ssichb_current_3: parseFloat(ipsdata[29]).toFixed(alert_curdec_values),
                                        ssichb_current_4: parseFloat(ipsdata[30]).toFixed(alert_curdec_values),
                                        panel_indicator_voltage: parseFloat(ipsdata[31]).toFixed(alert_voldec_values),
                                        pi_current_1: parseFloat(ipsdata[32]).toFixed(alert_curdec_values),
                                        pi_current_2: parseFloat(ipsdata[33]).toFixed(alert_curdec_values),
                                        spare_cell_charger_voltage: parseFloat(ipsdata[34]).toFixed(alert_voldec_values),
                                        spc_current_1: parseFloat(ipsdata[35]).toFixed(alert_curdec_values),
                                        spc_current_2: parseFloat(ipsdata[36]).toFixed(alert_curdec_values),
                                        blk_cbf_voltage: parseFloat(ipsdata[37]).toFixed(alert_voldec_values),
                                        blku_current_1: parseFloat(ipsdata[38]).toFixed(alert_curdec_values),
                                        blku_current_2: parseFloat(ipsdata[39]).toFixed(alert_curdec_values),
                                        blk_mtp_voltage: parseFloat(ipsdata[40]).toFixed(alert_voldec_values),
                                        blkd_current_1: parseFloat(ipsdata[41]).toFixed(alert_curdec_values),
                                        blkd_current_2: parseFloat(ipsdata[42]).toFixed(alert_curdec_values),
                                        axle_counter_cbf_voltage: parseFloat(ipsdata[43]).toFixed(alert_voldec_values),
                                        axu_current_1: parseFloat(ipsdata[44]).toFixed(alert_curdec_values),
                                        axu_current_2: parseFloat(ipsdata[45]).toFixed(alert_curdec_values),
                                        axu_current_3: parseFloat(ipsdata[46]).toFixed(alert_curdec_values),
                                        axu_current_4: parseFloat(ipsdata[47]).toFixed(alert_curdec_values),
                                        axle_counter_mtp_voltage: parseFloat(ipsdata[48]).toFixed(alert_voldec_values),
                                        axd_current_1: parseFloat(ipsdata[49]).toFixed(alert_curdec_values),
                                        axd_current_2: parseFloat(ipsdata[50]).toFixed(alert_curdec_values),
                                        axd_current_3: parseFloat(ipsdata[51]).toFixed(alert_curdec_values),
                                        axd_current_4: parseFloat(ipsdata[52]).toFixed(alert_curdec_values),
                                        vdc_110_terminal: parseFloat(ipsdata[53]).toFixed(alert_voldec_values),
                                        blk_lineup_cbf_voltage: parseFloat(ipsdata[52]).toFixed(alert_voldec_values),
                                        blu_current_1: parseFloat(ipsdata[53]).toFixed(alert_curdec_values),
                                        blu_current_2: parseFloat(ipsdata[54]).toFixed(alert_curdec_values),
                                        blu_current_3: parseFloat(ipsdata[55]).toFixed(alert_curdec_values),
                                        blk_linedown_mtp_voltage: parseFloat(ipsdata[56]).toFixed(alert_voldec_values),
                                        bld_current_1: parseFloat(ipsdata[57]).toFixed(alert_curdec_values),
                                        bld_current_2: parseFloat(ipsdata[58]).toFixed(alert_curdec_values),
                                        bld_current_3: parseFloat(ipsdata[59]).toFixed(alert_curdec_values),
                                        point_machine_voltage: parseFloat(ipsdata[60]).toFixed(alert_voldec_values),
                                        pm_current_1: parseFloat(ipsdata[61]).toFixed(alert_curdec_values),
                                        pm_current_2: parseFloat(ipsdata[62]).toFixed(alert_curdec_values),
                                        ac_110_terminal: parseFloat(ipsdata[63]).toFixed(alert_voldec_values),
                                        cmf_signal_voltage: parseFloat(ipsdata[64]).toFixed(alert_voldec_values),
                                        sig_current_cbf_1: parseFloat(ipsdata[65]).toFixed(alert_curdec_values),
                                        mtp_signal_voltage: parseFloat(ipsdata[66]).toFixed(alert_voldec_values),
                                        sig_current_mtp_1: parseFloat(ipsdata[67]).toFixed(alert_curdec_values),
                                        cbf_track_voltage: parseFloat(ipsdata[68]).toFixed(alert_voldec_values),
                                        tc_current_cbf_1: parseFloat(ipsdata[69]).toFixed(alert_curdec_values),
                                        mtp_track_voltage: parseFloat(ipsdata[70]).toFixed(alert_voldec_values),
                                        tc_current_mtp_1: parseFloat(ipsdata[71]).toFixed(alert_curdec_values),
                                        ac_230_terminal: parseFloat(ipsdata[72]).toFixed(alert_voldec_values),
                                        auxilary_transformer: parseFloat(ipsdata[73]).toFixed(alert_voldec_values),
                                        local_main_power: parseFloat(ipsdata[74]).toFixed(alert_voldec_values),
                                        load_current: parseFloat(ipsdata[75]).toFixed(alert_curdec_values),
                                        createddate: current_datetime
                                    }

                                    let transaction = await db.transaction({ autocommit: false });
                                    try {
                                        await IPSData.create(ips_data, { transaction: transaction })
                                        await transaction.commit();
                                        logs.info("IPS Data inserted");

                                        let alert_data = {}
                                        let alert_logs = []
                                        let alert_modeid = 0

                                        let socket_data = {
                                            data_logs: ips_data,
                                            alertmodeid: alert_logs.length > 0 ? alert_modeid : null,
                                            alerts: alert_logs
                                        }
                                        //logs.info('ipsdata',socket_data )
                                        Socket.emit("ipsdata", socket_data)
                                        //socketcloud.emit("IPS", socket_data)
                                    }
                                    catch (ex) {
                                        await transaction.rollback();
                                        logs.error('mqtt error stationdata/IPS ' + ex);
                                        //console.log('mqtt error stationdata/IPS ' + ex);
                                    }
                                }
                            }
                        }
                    }
                    catch (ex) {
                        logs.error('mqtt error stationdata/IPS ' + ex);
                        //console.log('mqtt error stationdata/IPS ' + ex);
                    }
                }
            });
        });

    })



    // -------- mqtt setup -----------

    // Active - Point Machine 1A
    async function insert_Apointnotification(data) {
        logs.info(`insert station pointmachine 1A data started`);
        //console.log(`insert station pointmachine A data started`);   
        try {
            alert_value_list = require("./alertvalue").getValues();
            let station_id = data.stationid
            let pointmachineid = data.pointmachineid
            let assertname = data.assertname
            let data_insert = []

            var pointmachineB_data = {}
            var pointmachineB_data_index = pointmachineBdatas.findIndex(obj => { return obj.key === data.pointmachineid.toString(); });
            if (pointmachineB_data_index !== -1) {
                pointmachineB_data = pointmachineBdatas[pointmachineB_data_index].data
            }
            else {
                if (pointmachineWithoutArray === true) {
                    var PointmachineB_Datas = [await PointMachineData.findOne({
                        limit: 1,
                        order: [["id", "DESC"]],
                        where: { pointmachineid: data.pointmachineid }
                    })];
                    PointmachineB_Datas = PointmachineB_Datas[0] !== null ? PointmachineB_Datas : []
                    if (PointmachineB_Datas.length > 0) {
                        pointmachineB_data = PointmachineB_Datas[0]
                        pointmachineB_data.count = pointmachineB_data.b_cyclecount
                        pointmachineBdatas.push({ key: data.pointmachineid.toString(), value: PointmachineB_Datas[0].b_cyclecount, data: PointmachineB_Datas[0] !== null ? PointmachineB_Datas[0] : {} });
                    }
                }
                else {
                    var PointmachineB_Datas = [await PointmachineBdata.findOne({
                        limit: 1,
                        order: [["id", "DESC"]],
                        where: { pointmachineid: data.pointmachineid }
                    })];
                    PointmachineB_Datas = PointmachineB_Datas[0] !== null ? PointmachineB_Datas : []
                    if (PointmachineB_Datas.length > 0) {
                        pointmachineB_data = PointmachineB_Datas[0]
                        pointmachineBdatas.push({ key: data.pointmachineid.toString(), value: PointmachineB_Datas[0].cyclecount, data: PointmachineB_Datas[0] !== null ? PointmachineB_Datas[0] : {} });
                    }
                }
            }

            if (lodash.isEmpty(pointmachineB_data)) {
                data_insert.push({
                    pointmachineid: pointmachineid,
                    direction: 'Normal',
                    pointcyclecount: 0,
                    a_direction: data.direction,
                    a_cyclecount: data.cyclecount,
                    a_indication_voltage: data.direction == 'Normal' ? data.forwardindicationvoltage : data.reverseindicationvoltage,
                    a_current_max: data.direction == 'Normal' ? data.forwardcurrentpeak : data.reversecurrentpeak,
                    a_current_avg: data.direction == 'Normal' ? data.forwardcurrentavg : data.reversecurrentavg,
                    a_voltage: data.direction == 'Normal' ? data.forwardvoltage : data.reversevoltage,
                    a_time: data.direction == 'Normal' ? data.forwardtime : data.reversetime,
                    a_vibration_x: data.vibrationx,
                    a_vibration_y: data.vibrationy,
                    a_vibration_z: data.vibrationz,
                    b_direction: '',
                    b_cyclecount: 0,
                    b_indication_voltage: 0,
                    b_current_max: 0,
                    b_current_avg: 0,
                    b_voltage: 0,
                    b_time: 0,
                    b_vibration_x: 0,
                    b_vibration_y: 0,
                    b_vibration_z: 0,
                    log: data.log,
                    createddate: data.createddate,
                    isdele: false
                })
            }
            else {
                data_insert.push({
                    pointmachineid: data.pointmachineid,
                    direction: 'Normal',
                    pointcyclecount: 0,
                    a_direction: data.direction,
                    a_cyclecount: data.cyclecount,
                    a_indication_voltage: data.direction == 'Normal' ? data.forwardindicationvoltage : data.reverseindicationvoltage,
                    a_current_max: data.direction == 'Normal' ? data.forwardcurrentpeak : data.reversecurrentpeak,
                    a_current_avg: data.direction == 'Normal' ? data.forwardcurrentavg : data.reversecurrentavg,
                    a_voltage: data.direction == 'Normal' ? data.forwardvoltage : data.reversevoltage,
                    a_time: data.direction == 'Normal' ? data.forwardtime : data.reversetime,
                    a_vibration_x: data.vibrationx,
                    a_vibration_y: data.vibrationy,
                    a_vibration_z: data.vibrationz,
                    b_direction: pointmachineB_data.direction,
                    b_cyclecount: pointmachineB_data.cyclecount,
                    b_indication_voltage: pointmachineB_data.direction == 'Normal' ? pointmachineB_data.forwardindicationvoltage : pointmachineB_data.reverseindicationvoltage,
                    b_current_max: pointmachineB_data.direction == 'Normal' ? pointmachineB_data.forwardcurrentpeak : pointmachineB_data.reversecurrentpeak,
                    b_current_avg: pointmachineB_data.direction == 'Normal' ? pointmachineB_data.forwardcurrentavg : pointmachineB_data.reversecurrentavg,
                    b_voltage: pointmachineB_data.direction == 'Normal' ? pointmachineB_data.forwardvoltage : pointmachineB_data.reversevoltage,
                    b_time: pointmachineB_data.direction == 'Normal' ? pointmachineB_data.forwardtime : pointmachineB_data.reversetime,
                    b_vibration_x: pointmachineB_data.vibrationx,
                    b_vibration_y: pointmachineB_data.vibrationy,
                    b_vibration_z: pointmachineB_data.vibrationz,
                    log: data.log == 1 ? 1 : pointmachineB_data.log == 1 ? 1 : 0,
                    createddate: data.createddate,
                    isdele: false
                })
            }

            if (data_insert.length == 1) {
                let transaction = await db.transaction({ autocommit: false });
                try {
                    let insert_data = ""
                    const create_data = await PointMachineData
                        .create(data_insert[0], { transaction: transaction }).then(res => insert_data = res)
                    //logs.info('pointmachineA_insert_dataid', insert_data.id)
                    var final_result = false
                    const cycle_index = pointmachineABdatas.findIndex(obj => { return obj.key === data.pointmachineid.toString(); });
                    if (cycle_index !== -1) {
                        if (lodash.isEqual([pointmachineABdatas[cycle_index].data.a_cyclecount, pointmachineABdatas[cycle_index].data.b_cyclecount], [data_insert[0].a_cyclecount, data_insert[0].b_cyclecount]) === false) {
                            final_result = true
                        }
                        pointmachineABdatas[cycle_index].data = data_insert[0]
                        pointmachineABdatas[cycle_index].id = insert_data.id
                    }
                    else {
                        pointmachineABdatas.push({ key: data.pointmachineid.toString(), data: data_insert[0], id: insert_data.id });
                        final_result = true
                    }
                    if (final_result) {
                        await transaction.commit();
                        insert_pointmachine(data, data_insert[0], insert_data.id);
                    }
                    else {
                        await transaction.rollback();
                    }
                }
                catch (ex) {
                    await transaction.rollback();
                    logs.error('station point machine 1A data error' + ex);
                    //console.log('station point machine 1A data error' + ex);
                }
            }

        }
        catch (ex) {
            logs.error('station point machine 1A data error' + ex);
            //console.log('station point machine 1A data error' + ex);
        }
    }

    // Active - Point Machine 1B
    async function insert_Bpointnotification(data) {
        logs.info(`insert station pointmachine 1B data started`);
        //console.log(`insert station pointmachine A data started`);
        try {
            alert_value_list = require("./alertvalue").getValues();
            let station_id = data.stationid
            let pointmachineid = data.pointmachineid
            let assertname = data.assertname
            let data_insert = []

            var pointmachineA_data = {}
            var pointmachineA_data_index = pointmachineAdatas.findIndex(obj => { return obj.key === data.pointmachineid.toString(); });
            if (pointmachineA_data_index !== -1) {
                pointmachineA_data = pointmachineAdatas[pointmachineA_data_index].data
            }
            else {
                if (pointmachineWithoutArray === true) {
                    var PointmachineA_Datas = [await PointMachineData.findOne({
                        limit: 1,
                        order: [["id", "DESC"]],
                        where: { pointmachineid: data.pointmachineid }
                    })];
                    PointmachineA_Datas = PointmachineA_Datas[0] !== null ? PointmachineA_Datas : []
                    if (PointmachineA_Datas.length > 0) {
                        pointmachineA_data = PointmachineA_Datas[0]
                        pointmachineA_data.count = pointmachineA_data.b_cyclecount
                        pointmachineAdatas.push({ key: data.pointmachineid.toString(), value: PointmachineA_Datas[0].b_cyclecount, data: PointmachineA_Datas[0] !== null ? PointmachineA_Datas[0] : {} });
                    }
                }
                else {
                    var PointmachineA_Datas = [await PointmachineAdata.findOne({
                        limit: 1,
                        order: [["id", "DESC"]],
                        where: { pointmachineid: data.pointmachineid }
                    })];
                    PointmachineA_Datas = PointmachineA_Datas[0] !== null ? PointmachineA_Datas : []
                    if (PointmachineA_Datas.length > 0) {
                        pointmachineA_data = PointmachineA_Datas[0]
                        pointmachineAdatas.push({ key: data.pointmachineid.toString(), value: PointmachineA_Datas[0].cyclecount, data: PointmachineA_Datas[0] !== null ? PointmachineA_Datas[0] : {} });
                    }
                }
            }

            if (lodash.isEmpty(pointmachineA_data)) {
                data_insert.push({
                    pointmachineid: pointmachineid,
                    direction: 'Normal',
                    pointcyclecount: 0,
                    a_direction: '',
                    a_cyclecount: 0,
                    a_indication_voltage: 0,
                    a_current_max: 0,
                    a_current_avg: 0,
                    a_voltage: 0,
                    a_time: 0,
                    a_vibration_x: 0,
                    a_vibration_y: 0,
                    a_vibration_z: 0,
                    b_direction: data.direction,
                    b_cyclecount: data.cyclecount,
                    b_indication_voltage: data.direction == 'Normal' ? data.forwardindicationvoltage : data.reverseindicationvoltage,
                    b_current_max: data.direction == 'Normal' ? data.forwardcurrentpeak : data.reversecurrentpeak,
                    b_current_avg: data.direction == 'Normal' ? data.forwardcurrentavg : data.reversecurrentavg,
                    b_voltage: data.direction == 'Normal' ? data.forwardvoltage : data.reversevoltage,
                    b_time: data.direction == 'Normal' ? data.forwardtime : data.reversetime,
                    b_vibration_x: data.vibrationx,
                    b_vibration_y: data.vibrationy,
                    b_vibration_z: data.vibrationz,
                    log: data.log,
                    createddate: data.createddate,
                    isdele: false
                })
            }
            else {
                data_insert.push({
                    pointmachineid: data.pointmachineid,
                    direction: 'Normal',
                    pointcyclecount: 0,
                    a_direction: pointmachineA_data.direction,
                    a_cyclecount: pointmachineA_data.cyclecount,
                    a_indication_voltage: pointmachineA_data.direction == 'Normal' ? pointmachineA_data.forwardindicationvoltage : pointmachineA_data.reverseindicationvoltage,
                    a_current_max: pointmachineA_data.direction == 'Normal' ? pointmachineA_data.forwardcurrentpeak : pointmachineA_data.reversecurrentpeak,
                    a_current_avg: pointmachineA_data.direction == 'Normal' ? pointmachineA_data.forwardcurrentavg : pointmachineA_data.reversecurrentavg,
                    a_voltage: pointmachineA_data.direction == 'Normal' ? pointmachineA_data.forwardvoltage : pointmachineA_data.reversevoltage,
                    a_time: pointmachineA_data.direction == 'Normal' ? pointmachineA_data.forwardtime : pointmachineA_data.reversetime,
                    a_vibration_x: pointmachineA_data.vibrationx,
                    a_vibration_y: pointmachineA_data.vibrationy,
                    a_vibration_z: pointmachineA_data.vibrationz,
                    b_direction: data.direction,
                    b_cyclecount: data.cyclecount,
                    b_indication_voltage: data.direction == 'Normal' ? data.forwardindicationvoltage : data.reverseindicationvoltage,
                    b_current_max: data.direction == 'Normal' ? data.forwardcurrentpeak : data.reversecurrentpeak,
                    b_current_avg: data.direction == 'Normal' ? data.forwardcurrentavg : data.reversecurrentavg,
                    b_voltage: data.direction == 'Normal' ? data.forwardvoltage : data.reversevoltage,
                    b_time: data.direction == 'Normal' ? data.forwardtime : data.reversetime,
                    b_vibration_x: data.vibrationx,
                    b_vibration_y: data.vibrationy,
                    b_vibration_z: data.vibrationz,
                    log: data.log == 1 ? 1 : pointmachineA_data.log == 1 ? 1 : 0,
                    createddate: data.createddate,
                    isdele: false
                })
            }

            if (data_insert.length == 1) {
                let transaction = await db.transaction({ autocommit: false });
                try {
                    let insert_data = ""
                    const create_data = await PointMachineData
                        .create(data_insert[0], { transaction: transaction }).then(res => insert_data = res)
                    //logs.info('pointmachineA_insert_dataid', insert_data.id)
                    var final_result = false
                    const cycle_index = pointmachineABdatas.findIndex(obj => { return obj.key === data.pointmachineid.toString(); });
                    if (cycle_index !== -1) {
                        if (lodash.isEqual([pointmachineABdatas[cycle_index].data.a_cyclecount, pointmachineABdatas[cycle_index].data.b_cyclecount], [data_insert[0].a_cyclecount, data_insert[0].b_cyclecount]) === false) {
                            final_result = true
                        }
                        pointmachineABdatas[cycle_index].data = data_insert[0]
                        pointmachineABdatas[cycle_index].id = insert_data.id
                    }
                    else {
                        pointmachineABdatas.push({ key: data.pointmachineid.toString(), data: data_insert[0], id: insert_data.id });
                        final_result = true
                    }
                    if (final_result) {
                        await transaction.commit();
                        insert_pointmachine(data, data_insert[0], insert_data.id);
                    }
                    else {
                        await transaction.rollback();
                    }
                }
                catch (ex) {
                    await transaction.rollback();
                    logs.error('station point machine 1A data error' + ex);
                    //console.log('station point machine 1A data error' + ex);
                }
            }


        }
        catch (ex) {
            logs.error('station pointmachine 1B data error' + ex);
            //console.log('station point machine 1B data error' + ex);
        }
    }

    // Active - Point Machine 1AB Data
    async function insert_pointmachine(datas, data, dataid) {
        logs.info('insert point machine alert started');
        //console.log('insert point machine alert started');
        let transaction = await db.transaction({ autocommit: false });
        try {
            alert_value_list = require("./alertvalue").getValues();
            let point_check = [];
            let station_id = datas.stationid
            let pointmachineid = datas.pointmachineid
            let assertname = datas.assertname
            var alert_name_values;

            //point_check
            if (data.a_cyclecount != 0) {
                alert_name_values = data.a_direction == 'Normal' ? await get_alerts(`${station_id}@${pointmachineid}@${assertname}@NORMAL_DIRECTION`) : data.b_direction == 'Reverse' ? await get_alerts(`${station_id}@${pointmachineid}@${assertname}@REVERSE_DIRECTION`) : null
                if (alert_name_values != null) {
                    data.a_cyclecount > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                        point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.a_cyclecount, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""
                }

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_A_CURRENT_MAX`)
                data.a_current_max < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                    point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.a_current_max, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                    alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_A_CURRENT_MAX`)
                data.a_current_max > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                    point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.a_current_max, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_A_CURRENT_AVG`)
                data.a_current_avg < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                    point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.a_current_avg, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                    alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_A_CURRENT_AVG`)
                data.a_current_avg > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                    point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.a_current_avg, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_A_VOLTAGE`)
                data.a_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                    point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.a_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                    alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_A_VOLTAGE`)
                data.a_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                    point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.a_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_INDICATION_A_VOLTAGE`)
                data.a_indication_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                    point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.a_indication_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                    alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_INDICATION_A_VOLTAGE`)
                data.a_indication_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                    point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.a_indication_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_A_TIME`)
                data.a_time < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                    point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.a_time, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                    alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_A_TIME`)
                data.a_time > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                    point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.a_time, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""


            }

            if (data.b_cyclecount != 0) {
                alert_name_values = data.a_direction == 'Normal' ? await get_alerts(`${station_id}@${pointmachineid}@${assertname}@NORMAL_DIRECTION`) : data.b_direction == 'Reverse' ? await get_alerts(`${station_id}@${pointmachineid}@${assertname}@REVERSE_DIRECTION`) : null
                if (alert_name_values != null) {
                    data.b_cyclecount > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                        point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.b_cyclecount, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""
                }

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_B_CURRENT_MAX`)
                data.b_current_max < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                    point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.b_current_max, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                    alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_B_CURRENT_MAX`)
                data.b_current_max > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                    point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.b_current_max, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_B_CURRENT_AVG`)
                data.b_current_avg < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                    point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.b_current_avg, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                    alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_B_CURRENT_AVG`)
                data.b_current_avg > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                    point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.b_current_avg, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_B_VOLTAGE`)
                data.b_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                    point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.b_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                    alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_B_VOLTAGE`)
                data.b_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                    point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.b_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_INDICATION_B_VOLTAGE`)
                data.b_indication_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                    point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.b_indication_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                    alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_INDICATION_B_VOLTAGE`)
                data.b_indication_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                    point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.b_indication_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_B_TIME`)
                data.b_time < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                    point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.b_time, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                    alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_B_TIME`)
                data.b_time > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                    point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.b_time, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            }

            var result = lodash.filter(point_check, function (o) { return o.result; });
            var mode_filtered = lodash.groupBy(point_check, function (o) { return o.mode });

            let alert_data = {}
            let alert_logs = []
            let alert_modeid = 0

            let mobile_notification_data = []

            if (result.length > 0) {
                for (var property in mode_filtered) {
                    let alertid = ""
                    let modeid = lodash.result(lodash.find(AlertModes, { 'mode': property }), 'id')
                    alert_modeid = alert_modeid == null ? modeid : alert_modeid > modeid ? alert_modeid : modeid

                    alert_data = {
                        pointmachineid: parseInt(data.pointmachineid),
                        pointmachinedataid: dataid,
                        stationid: datas.stationid,
                        message: mode_filtered[property].map(item => item.message).join(' ; '),
                        assertid: datas.assertid,
                        modeid: modeid,
                        mode: property,
                        createddate: datas.createddate,
                        isdele: false
                    }
                    alert_logs.push(alert_data)

                    const alertinsert = await PointMachineAlert.create(alert_data, { transaction: transaction }).then(res => alertid = res.id)
                    //logs.info(`station pointmachine alert ended`);
                    //console.log(`station pointmachine alert ended`); 

                    var get_users = await NotificationControl.findAll({ where: { assertsid: datas.assertid, stationid: datas.stationid, isdele: false } })
                    var get_users_id = lodash.uniq(get_users.map(item => item.userid))

                    let alert_message_ids = lodash.uniq(mode_filtered[property].map(i => i.id)).sort((a, b) => a - b)
                    for (let i = 0; i < get_users_id.length; i++) {
                        const get_previous_notification = await NotificationSend.findOne({
                            where: { stationid: datas.stationid, assertsid: datas.assertid, alertmessageids: alert_message_ids, modeid: modeid, userid: get_users_id[i], isseen: false, isdele: false },
                            order: [["id", "DESC"]]
                        })

                        if (get_previous_notification == null) {

                            mobile_notification_data.push({
                                stationid: datas.stationid,
                                stationcode: datas.stationcode,
                                stationname: datas.stationname,
                                assertname: datas.assertname,
                                assertsid: datas.assertid,
                                assertidname: datas.pointmachinename,
                                alertid: alertid,
                                userid: get_users_id[i],
                                message: alert_data.message,
                                modeid: modeid,
                                mode: property,
                                alertmessageids: alert_message_ids,
                                isseen: false,
                                issend: false,
                                createddate: datas.createddate,
                            })
                        }
                    }
                }

                if (mobile_notification_data.length > 0) {
                    const notifiyinsert = await NotificationSend.bulkCreate(mobile_notification_data, { transaction: transaction })
                    Socket.emit('Notification', mobile_notification_data);
                    //socketcloud.emit("Notification", mobile_notification_data)
                }
            }

            let data_logs = {
                id: dataid,
                pointmachineid: parseInt(datas.pointmachineid),
                pointmachinename: datas.pointmachinename,
                direction: data.direction,
                pointcyclecount: data.pointcyclecount,
                a_direction: data.a_direction,
                a_cyclecount: data.a_cyclecount,
                a_indication_voltage: data.a_indication_voltage,
                a_current_max: data.a_current_max,
                a_current_avg: data.a_current_avg,
                a_voltage: data.a_voltage,
                a_time: data.a_time,
                a_vibration_x: data.a_vibration_x,
                a_vibration_y: data.a_vibration_y,
                a_vibration_z: data.a_vibration_z,
                b_direction: data.b_direction,
                b_cyclecount: data.b_cyclecount,
                b_indication_voltage: data.b_indication_voltage,
                b_current_max: data.b_current_max,
                b_current_avg: data.b_current_avg,
                b_voltage: data.b_voltage,
                b_time: data.b_time,
                b_vibration_x: data.b_vibration_x,
                b_vibration_y: data.b_vibration_y,
                b_vibration_z: data.b_vibration_z,
                log: data.log,
                createddate: data.createddate,
                time: moment(data.createddate).format("HH:mm:ss"),
                isdele: data.isdele
            }

            let socket_data = {
                data_logs: data_logs,
                // points : points,  
                alertmodeid: alert_logs.length > 0 ? alert_modeid : null,
                alerts: alert_logs
            }
            await transaction.commit();
            //logs.info('point_machine_socket_data',socket_data)
            Socket.emit("pointmachinedata", socket_data)
            //socketcloud.emit("Point", socket_data)

        } catch (ex) {
            await transaction.rollback();
            logs.error('station point machine data error' + ex);
            //console.log('station point machine data error' + ex);
        }
    }

    // Active - Point Machine 1C Data
    async function insert_pointmachineC(A_point_data, B_point_data) {
        logs.info('insert point machine C alert started');
        //console.log('insert point machine alert started');
        let transaction = await db.transaction({ autocommit: false });
        try {
            alert_value_list = require("./alertvalue").getValues();
            let point_check = [];
            let station_id = A_point_data.stationid
            let pointmachineid = A_point_data.pointmachineid
            let assertname = A_point_data.assertname

            let data_insert = {
                pointmachineid: A_point_data.pointmachineid,
                direction: 'Normal',
                pointcyclecount: 0,
                a_direction: A_point_data.direction,
                a_cyclecount: A_point_data.cyclecount,
                a_indication_voltage: A_point_data.direction == 'Normal' ? A_point_data.forwardindicationvoltage : A_point_data.reverseindicationvoltage,
                a_current_max: A_point_data.direction == 'Normal' ? A_point_data.forwardcurrentpeak : A_point_data.reversecurrentpeak,
                a_current_avg: A_point_data.direction == 'Normal' ? A_point_data.forwardcurrentavg : A_point_data.reversecurrentavg,
                a_voltage: A_point_data.direction == 'Normal' ? A_point_data.forwardvoltage : A_point_data.reversevoltage,
                a_time: A_point_data.direction == 'Normal' ? A_point_data.forwardtime : A_point_data.reversetime,
                a_vibration_x: A_point_data.vibrationx,
                a_vibration_y: A_point_data.vibrationy,
                a_vibration_z: A_point_data.vibrationz,
                b_direction: B_point_data.direction,
                b_cyclecount: B_point_data.cyclecount,
                b_indication_voltage: B_point_data.direction == 'Normal' ? B_point_data.forwardindicationvoltage : B_point_data.reverseindicationvoltage,
                b_current_max: B_point_data.direction == 'Normal' ? B_point_data.forwardcurrentpeak : B_point_data.reversecurrentpeak,
                b_current_avg: B_point_data.direction == 'Normal' ? B_point_data.forwardcurrentavg : B_point_data.reversecurrentavg,
                b_voltage: B_point_data.direction == 'Normal' ? B_point_data.forwardvoltage : B_point_data.reversevoltage,
                b_time: B_point_data.direction == 'Normal' ? B_point_data.forwardtime : B_point_data.reversetime,
                b_vibration_x: B_point_data.vibrationx,
                b_vibration_y: B_point_data.vibrationy,
                b_vibration_z: B_point_data.vibrationz,
                log: A_point_data.log == 1 ? 1 : B_point_data.log == 1 ? 1 : 0,
                createddate: A_point_data.createddate,
                isdele: false
            }

            let data = ""
            const create_data = await PointMachineData
                .create(data_insert, { transaction: transaction }).then(res => data = res)
            logs.info('point machine C_data_insert', data.id)

            const cycle_index = pointmachineABdatas.findIndex(obj => { return obj.key === A_point_data.pointmachineid.toString(); });
            if (cycle_index !== -1) {
                pointmachineABdatas[cycle_index].data = data_insert
                pointmachineABdatas[cycle_index].id = data.id
            }
            else {
                pointmachineABdatas.push({ key: A_point_data.pointmachineid.toString(), data: data_insert, id: data.id });
            }

            //point_check
            var alert_name_values = data_insert.a_direction == 'Normal' ? await get_alerts(`${station_id}@${pointmachineid}@${assertname}@NORMAL_DIRECTION`) : data_insert.a_direction == 'Reverse' ? await get_alerts(`${station_id}@${pointmachineid}@${assertname}@REVERSE_DIRECTION`) : null
            if (alert_name_values != null) {
                data_insert.a_cyclecount > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                    point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data_insert.a_cyclecount, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""
            }

            alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_A_CURRENT_MAX`)
            data_insert.a_current_max < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data_insert.a_current_max, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_A_CURRENT_MAX`)
            data_insert.a_current_max > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data_insert.a_current_max, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_A_CURRENT_AVG`)
            data_insert.a_current_avg < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data_insert.a_current_avg, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_A_CURRENT_AVG`)
            data_insert.a_current_avg > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data_insert.a_current_avg, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_A_VOLTAGE`)
            data_insert.a_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data_insert.a_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_A_VOLTAGE`)
            data_insert.a_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data_insert.a_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_INDICATION_A_VOLTAGE`)
            data_insert.a_indication_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data_insert.a_indication_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_INDICATION_A_VOLTAGE`)
            data_insert.a_indication_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data_insert.a_indication_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_A_TIME`)
            data_insert.a_time < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data_insert.a_time, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_A_TIME`)
            data_insert.a_time > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data_insert.a_time, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = data_insert.b_direction == 'Normal' ? await get_alerts(`${station_id}@${pointmachineid}@${assertname}@NORMAL_DIRECTION`) : data_insert.b_direction == 'Reverse' ? await get_alerts(`${station_id}@${pointmachineid}@${assertname}@REVERSE_DIRECTION`) : null
            if (alert_name_values != null) {
                data_insert.b_cyclecount > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                    point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data_insert.b_cyclecount, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""
            }

            alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_B_CURRENT_MAX`)
            data_insert.b_current_max < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data_insert.b_current_max, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_B_CURRENT_MAX`)
            data_insert.b_current_max > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data_insert.b_current_max, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_B_CURRENT_AVG`)
            data_insert.b_current_avg < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data_insert.b_current_avg, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_B_CURRENT_AVG`)
            data_insert.b_current_avg > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data_insert.b_current_avg, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_B_VOLTAGE`)
            data_insert.b_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data_insert.b_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_B_VOLTAGE`)
            data_insert.b_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data_insert.b_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_INDICATION_B_VOLTAGE`)
            data_insert.b_indication_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data_insert.b_indication_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_INDICATION_B_VOLTAGE`)
            data_insert.b_indication_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data_insert.b_indication_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_B_TIME`)
            data_insert.b_time < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data_insert.b_time, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_B_TIME`)
            data_insert.b_time > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data_insert.b_time, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            var result = lodash.filter(point_check, function (o) { return o.result; });
            var mode_filtered = lodash.groupBy(point_check, function (o) { return o.mode });

            let alert_data = {}
            let alert_logs = []
            let alert_modeid = 0

            let mobile_notification_data = []

            if (result.length > 0) {
                for (var property in mode_filtered) {
                    let alertid = ""
                    let modeid = lodash.result(lodash.find(AlertModes, { 'mode': property }), 'id')
                    alert_modeid = alert_modeid == null ? modeid : alert_modeid > modeid ? alert_modeid : modeid

                    alert_data = {
                        pointmachineid: A_point_data.pointmachineid,
                        pointmachinedataid: data.id,
                        stationid: A_point_data.stationid,
                        message: mode_filtered[property].map(item => item.message).join(' ; '),
                        assertid: A_point_data.assertid,
                        modeid: modeid,
                        mode: property,
                        createddate: A_point_data.createddate,
                        isdele: false
                    }
                    alert_logs.push(alert_data)

                    const alertinsert = await PointMachineAlert.create(alert_data, { transaction: transaction }).then(res => alertid = res.id)
                    //logs.info(`station pointmachine alert ended`);
                    //console.log(`station pointmachine alert ended`); 

                    var get_users = await NotificationControl.findAll({ where: { assertsid: A_point_data.assertid, stationid: station_id, isdele: false } })
                    var get_users_id = lodash.uniq(get_users.map(item => item.userid))

                    let alert_message_ids = lodash.uniq(mode_filtered[property].map(i => i.id)).sort((a, b) => a - b)
                    for (let i = 0; i < get_users_id.length; i++) {
                        const get_previous_notification = await NotificationSend.findOne({
                            where: { stationid: station_id, assertsid: A_point_data.assertid, alertmessageids: alert_message_ids, modeid: modeid, userid: get_users_id[i], isseen: false, isdele: false },
                            order: [["id", "DESC"]]
                        })

                        if (get_previous_notification == null) {

                            mobile_notification_data.push({
                                stationid: station_id,
                                stationcode: A_point_data.stationcode,
                                stationname: A_point_data.stationname,
                                assertname: A_point_data.assertname,
                                assertsid: A_point_data.assertid,
                                assertidname: A_point_data.pointmachinename,
                                alertid: alertid,
                                userid: get_users_id[i],
                                message: alert_data.message,
                                modeid: modeid,
                                mode: property,
                                alertmessageids: alert_message_ids,
                                isseen: false,
                                issend: false,
                                createddate: data.createddate,
                            })
                        }
                    }
                }

                if (mobile_notification_data.length > 0) {
                    const notifiyinsert = await NotificationSend.bulkCreate(mobile_notification_data, { transaction: transaction })
                    Socket.emit('Notification', mobile_notification_data);
                    //socketcloud.emit("Notification", mobile_notification_data)
                }
            }

            let data_logs = {
                id: data.id,
                pointmachineid: A_point_data.pointmachineid,
                pointmachinename: A_point_data.pointmachinename,
                direction: data.direction,
                pointcyclecount: data.pointcyclecount,
                a_direction: data.a_direction,
                a_cyclecount: data.a_cyclecount,
                a_indication_voltage: data.a_indication_voltage,
                a_current_max: data.a_current_max,
                a_current_avg: data.a_current_avg,
                a_voltage: data.a_voltage,
                a_time: data.a_time,
                a_vibration_x: data.a_vibration_x,
                a_vibration_y: data.a_vibration_y,
                a_vibration_z: data.a_vibration_z,
                b_direction: data.b_direction,
                b_cyclecount: data.b_cyclecount,
                b_indication_voltage: data.b_indication_voltage,
                b_current_max: data.b_current_max,
                b_current_avg: data.b_current_avg,
                b_voltage: data.b_voltage,
                b_time: data.b_time,
                b_vibration_x: data.b_vibration_x,
                b_vibration_y: data.b_vibration_y,
                b_vibration_z: data.b_vibration_z,
                log: data.log,
                createddate: data.createddate,
                time: moment(data.createddate).format("HH:mm:ss"),
                isdele: data.isdele
            }

            //commented it out because not using now
            // let points = []
            // points.push({
            //     id : A_point_data.pointmachineid,
            //     pointmachinename : A_point_data.pointmachinename,
            //     direction : data.direction,
            //     pointcyclecount : data.pointcyclecount,
            //     a_direction : data.a_direction,
            //     a_cyclecount : data.a_cyclecount,
            //     a_indication_voltage : data.a_indication_voltage,
            //     a_current_max :  data.a_current_max,
            //     a_current_avg : data.a_current_avg,
            //     a_voltage :  data.a_voltage,
            //     a_time :  data.a_time,
            //     a_vibration_x : data.a_vibration_x,
            //     a_vibration_y : data.a_vibration_y,
            //     a_vibration_z : data.a_vibration_z,
            //     b_direction : data.b_direction,
            //     b_cyclecount : data.b_cyclecount,
            //     b_indication_voltage : data.b_indication_voltage,
            //     b_current_max : data.b_current_max,
            //     b_current_avg : data.b_current_avg,
            //     b_voltage : data.b_voltage,
            //     b_time : data.b_time,
            //     b_vibration_x : data.b_vibration_x,
            //     b_vibration_y : data.b_vibration_y,
            //     b_vibration_z: data.b_vibration_z,
            //     log : data.log,
            //     createddate : data.createddate,
            //     isdele : data.isdele
            // })        
            // var pointmachines = await RegisteredPointMachine.findAll({where:{isdele:false, stationid:station_id}})            
            // for(let i=0 ; i < pointmachines.length;i++ )
            // {
            //     let element =  pointmachines[i]
            //   var get_finalpointmachines_datas = [await PointMachineData.findOne({limit : 1, where :{isdele : false, pointmachineid:element.id}, order : [["id","DESC"]]})];
            //   get_finalpointmachines_datas = get_finalpointmachines_datas[0] !== null ? get_finalpointmachines_datas : []
            //   if(get_finalpointmachines_datas.length > 0 && element.id != parseInt(A_point_data.pointmachineid))
            //   {
            //     points.push({
            //       id : element.id,
            //       pointmachinename : element.pointmachinename,
            //       direction : get_finalpointmachines_datas[0].direction,
            //       pointcyclecount : get_finalpointmachines_datas[0].pointcyclecount,
            //       a_direction : get_finalpointmachines_datas[0].a_direction,
            //       a_cyclecount : get_finalpointmachines_datas[0].a_cyclecount,
            //       a_indication_voltage : get_finalpointmachines_datas[0].a_indication_voltage,
            //       a_current_max :  get_finalpointmachines_datas[0].a_current_max,
            //       a_current_avg : get_finalpointmachines_datas[0].a_current_avg,
            //       a_voltage :  get_finalpointmachines_datas[0].a_voltage,
            //       a_time :  get_finalpointmachines_datas[0].a_time,
            //       a_vibration_x : get_finalpointmachines_datas[0].a_vibration_x,
            //       a_vibration_y : get_finalpointmachines_datas[0].a_vibration_y,
            //       a_vibration_z : get_finalpointmachines_datas[0].a_vibration_z,
            //       b_direction : get_finalpointmachines_datas[0].b_direction,
            //       b_cyclecount : get_finalpointmachines_datas[0].b_cyclecount,
            //       b_indication_voltage : get_finalpointmachines_datas[0].b_indication_voltage,
            //       b_current_max : get_finalpointmachines_datas[0].b_current_max,
            //       b_current_avg : get_finalpointmachines_datas[0].b_current_avg,
            //       b_voltage : get_finalpointmachines_datas[0].b_voltage,
            //       b_time : get_finalpointmachines_datas[0].b_time,
            //       b_vibration_x : get_finalpointmachines_datas[0].b_vibration_x,
            //       b_vibration_y : get_finalpointmachines_datas[0].b_vibration_y,
            //       b_vibration_z: get_finalpointmachines_datas[0].b_vibration_z,
            //       log : get_finalpointmachines_datas[0].log,
            //       createddate : get_finalpointmachines_datas[0].createddate,
            //       isdele : get_finalpointmachines_datas[0].isdele
            //   })
            //   }   
            // }   

            let socket_data = {
                data_logs: data_logs,
                // points : points, 
                alertmodeid: alert_logs.length > 0 ? alert_modeid : null,
                alerts: alert_logs
            }
            await transaction.commit();
            //logs.info('point_machine_socket_data',socket_data)
            Socket.emit("pointmachinedata", socket_data)
            //socketcloud.emit("Point", socket_data)

        } catch (ex) {
            await transaction.rollback();
            logs.error('station point machine C data error' + ex);
            //console.log('station point machine C data error' + ex);
        }
    }

    // Active - Signal Circuit Data
    async function insert_signalcircuit(data) {
        logs.info(`station signalcircuit alert started`);
        //console.log(`station signalcircuit alert started`);
        let transaction = await db.transaction({ autocommit: false });
        try {
            alert_value_list = require("./alertvalue").getValues();
            let station_id = data.stationid
            let signalcircuitid = data.signalcircuitid
            let assertname = data.assertname
            let aspectcurrent = 0
            let aspectvoltage = 0
            let gui = 0
            let index_score = 5

            let glow_check = []
            let error_voltage_data = []
            let error_current_data = []

            //get for only one light glows based on min and max conditions
            //logs.info(`signal cirucit glow result check`);
            //console.log(`signal cirucit glow result check`);

            var alert_minvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@MIN_ASPECT_VOLTAGE`)
            var alert_maxvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@MAX_ASPECT_VOLTAGE`)
            var alert_mincur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@MIN_ASPECT_CURRENT`)
            var alert_maxcur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@MAX_ASPECT_CURRENT`)

            var alert_rgmincur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@RG_CURRENT_MIN`)
            var alert_dgmincur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@DG_CURRENT_MIN`)
            var alert_hgmincur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HG_CURRENT_MIN`)
            var alert_hhgmincur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HHG_CURRENT_MIN`)

            var alert_rgmaxcur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@RG_CURRENT_MAX`)
            var alert_dgmaxcur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@DG_CURRENT_MAX`)
            var alert_hgmaxcur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HG_CURRENT_MAX`)
            var alert_hhgmaxcur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HHG_CURRENT_MAX`)

            var alert_rgminvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@RG_VOLTAGE_MIN`)
            var alert_dgminvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@DG_VOLTAGE_MIN`)
            var alert_hgminvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HG_VOLTAGE_MIN`)
            var alert_hhgminvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HHG_VOLTAGE_MIN`)

            var alert_rgmaxvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@RG_VOLTAGE_MAX`)
            var alert_dgmaxvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@DG_VOLTAGE_MAX`)
            var alert_hgmaxvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HG_VOLTAGE_MAX`)
            var alert_hhgmaxvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HHG_VOLTAGE_MAX`)

            var alert_rgdg_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@RG_DG`)
            var alert_rghg_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@RG_HG`)
            var alert_rghhg_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@RG_HHG`)
            var alert_dghg_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@DG_HG`)
            var alert_dghhg_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@DG_HHG`)
            var alert_hghhg_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HG_HHG`)

            var alert_message_mode = []

            var alert_off_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@SIGNAL_BLANK_ALERT`)
            var alert_on_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@SIGNAL_GLOW_ALERT`)

            data.redvoltage >= parseFloat(alert_minvol_values.value) && data.redvoltage <= parseFloat(alert_maxvol_values.value) && data.redcurrent >= parseFloat(alert_mincur_values.value) && data.redcurrent <= parseFloat(alert_maxcur_values.value)
                ? glow_check.push({ result: true, voltage: data.redvoltage, current: data.redcurrent, gui: 1 }) : ""

            data.greenvoltage >= parseFloat(alert_minvol_values.value) && data.greenvoltage <= parseFloat(alert_maxvol_values.value) && data.greencurrent >= parseFloat(alert_mincur_values.value) && data.greencurrent <= parseFloat(alert_maxcur_values.value)
                ? glow_check.push({ result: true, voltage: data.greenvoltage, current: data.greencurrent, gui: 2 }) : ""

            data.yellowvoltage >= parseFloat(alert_minvol_values.value) && data.yellowvoltage <= parseFloat(alert_maxvol_values.value) && data.yellowcurrent >= parseFloat(alert_mincur_values.value) && data.yellowcurrent <= parseFloat(alert_maxcur_values.value)
                ? glow_check.push({ result: true, voltage: data.yellowvoltage, current: data.yellowcurrent, gui: 3 }) : ""


            if (data.aspecttypeid == 3) {
                data.lightyellowvoltage >= parseFloat(alert_minvol_values.value) && data.lightyellowvoltage <= parseFloat(alert_maxvol_values.value) && data.lightyellowcurrent >= parseFloat(alert_mincur_values.value) && data.lightyellowcurrent <= parseFloat(alert_maxcur_values.value)
                    ? glow_check.push({ result: true, voltage: data.lightyellowvoltage, current: data.lightyellowcurrent, gui: 4 }) : ""
            }

            //check for only current
            //logs.info(`signal cirucit current error check`);
            //console.log(`signal cirucit current error check`);

            data.redvoltage >= parseFloat(alert_minvol_values.value) && data.redvoltage <= parseFloat(alert_maxvol_values.value)
                ? data.redcurrent < parseFloat(alert_mincur_values.value) && alert_rgmincur_values.isactive === true
                    ? error_current_data.push({ message: await combine_mes_val_unit(alert_rgmincur_values.message, data.redcurrent, alert_rgmincur_values.unit), voltage: data.redvoltage, current: data.redcurrent, max_current: data.redcurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: data.redcurrent < parseFloat(alert_mincur_values.value) ? true : false, gui: 1, id: alert_rgmincur_values.id, mode: alert_rgmincur_values.mode })
                    : data.redcurrent > parseFloat(alert_maxcur_values.value) && alert_rgmaxcur_values.isactive === true
                        ? error_current_data.push({ message: await combine_mes_val_unit(alert_rgmaxcur_values.message, data.redcurrent, alert_rgmaxcur_values.unit), voltage: data.redvoltage, current: data.redcurrent, max_current: data.redcurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: false, gui: 1, id: alert_rgmaxcur_values.id, mode: alert_rgmaxcur_values.mode })
                        : "" : ""

            data.greenvoltage >= parseFloat(alert_minvol_values.value) && data.greenvoltage <= parseFloat(alert_maxvol_values.value)
                ? data.greencurrent < parseFloat(alert_mincur_values.value) && alert_dgmincur_values.isactive === true
                    ? error_current_data.push({ message: await combine_mes_val_unit(alert_dgmincur_values.message, data.greencurrent, alert_dgmincur_values.unit), voltage: data.greenvoltage, current: data.greencurrent, max_current: data.greencurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: data.greencurrent < parseFloat(alert_mincur_values.value) ? true : false, gui: 2, id: alert_dgmincur_values.id, mode: alert_dgmincur_values.mode })
                    : data.greencurrent > parseFloat(alert_maxcur_values.value) && alert_dgmaxcur_values.isactive === true
                        ? error_current_data.push({ message: await combine_mes_val_unit(alert_dgmaxcur_values.message, data.greencurrent, alert_dgmaxcur_values.unit), voltage: data.greenvoltage, current: data.greencurrent, max_current: data.greencurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: false, gui: 2, id: alert_dgmaxcur_values.id, mode: alert_dgmaxcur_values.mode })
                        : "" : ""

            data.yellowvoltage >= parseFloat(alert_minvol_values.value) && data.yellowvoltage <= parseFloat(alert_maxvol_values.value)
                ? data.yellowcurrent < parseFloat(alert_mincur_values.value) && alert_hgmincur_values.isactive === true
                    ? error_current_data.push({ message: await combine_mes_val_unit(alert_hgmincur_values.message, data.yellowcurrent, alert_hgmincur_values.unit), voltage: data.yellowvoltage, current: data.yellowcurrent, max_current: data.yellowcurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: data.yellowcurrent < parseFloat(alert_mincur_values.value) ? true : false, gui: 3, id: alert_hgmincur_values.id, mode: alert_hgmincur_values.mode })
                    : data.yellowcurrent > parseFloat(alert_maxcur_values.value) && alert_hgmaxcur_values.isactive === true
                        ? error_current_data.push({ message: await combine_mes_val_unit(alert_hgmaxcur_values.message, data.yellowcurrent, alert_hgmaxcur_values.unit), voltage: data.yellowvoltage, current: data.yellowcurrent, max_current: data.yellowcurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: false, gui: 3, id: alert_hgmaxcur_values.id, mode: alert_hgmaxcur_values.mode })
                        : "" : ""

            if (data.aspecttypeid == 3) {
                data.lightyellowvoltage >= parseFloat(alert_minvol_values.value) && data.lightyellowvoltage <= parseFloat(alert_maxvol_values.value)
                    ? data.lightyellowcurrent < parseFloat(alert_mincur_values.value) && alert_hhgmincur_values.isactive === true
                        ? error_current_data.push({ message: await combine_mes_val_unit(alert_hhgmincur_values.message, data.lightyellowcurrent, alert_hhgmincur_values.unit), voltage: data.lightyellowvoltage, current: data.lightyellowcurrent, max_current: data.lightyellowcurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: data.lightyellowcurrent < parseFloat(alert_mincur_values.value) ? true : false, gui: 3, id: alert_hhgmincur_values.id, mode: alert_hhgmincur_values.mode })
                        : data.lightyellowcurrent > parseFloat(alert_maxcur_values.value) && alert_hhgmaxcur_values.isactive === true
                            ? error_current_data.push({ message: await combine_mes_val_unit(alert_hhgmaxcur_values.message, data.lightyellowcurrent, alert_hhgmaxcur_values.unit), voltage: data.lightyellowvoltage, current: data.lightyellowcurrent, max_current: data.lightyellowcurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: false, gui: 3, id: alert_hhgmaxcur_values.id, mode: alert_hhgmaxcur_values.mode })
                            : "" : ""
            }

            //check for only voltage
            //logs.info(`signal cirucit voltage error check`);
            //console.log(`signal cirucit voltage error check`);

            data.redcurrent >= parseFloat(alert_mincur_values.value) && data.redcurrent <= parseFloat(alert_maxcur_values.value)
                ? data.redvoltage < parseFloat(alert_minvol_values.value) && alert_rgminvol_values.isactive === true
                    ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_rgminvol_values.message, data.redvoltage, alert_rgminvol_values.unit), voltage: data.redvoltage, current: data.redcurrent, max_voltage: data.redvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: data.redvoltage < parseFloat(alert_minvol_values.value) ? true : false, gui: 1, id: alert_rgminvol_values.id, mode: alert_rgminvol_values.mode })
                    : data.redvoltage > parseFloat(alert_maxvol_values.value) && alert_rgmaxvol_values.isactive === true
                        ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_rgmaxvol_values.message, data.redvoltage, alert_rgmaxvol_values.unit), voltage: data.redvoltage, current: data.redcurrent, max_voltage: data.redvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: false, gui: 1, id: alert_rgmaxvol_values.id, mode: alert_rgmaxvol_values.mode })
                        : "" : ""

            data.greencurrent >= parseFloat(alert_mincur_values.value) && data.greencurrent <= parseFloat(alert_maxcur_values.value)
                ? data.greenvoltage < parseFloat(alert_minvol_values.value) && alert_dgminvol_values.isactive === true
                    ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_dgminvol_values.message, data.greenvoltage, alert_dgminvol_values.unit), voltage: data.greenvoltage, current: data.greencurrent, max_voltage: data.greenvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: data.greenvoltage < parseFloat(alert_minvol_values.value) ? true : false, gui: 2, id: alert_dgminvol_values.id, mode: alert_dgminvol_values.mode })
                    : data.greenvoltage > parseFloat(alert_maxvol_values.value) && alert_dgmaxvol_values.isactive === true
                        ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_dgmaxvol_values.message, data.greenvoltage, alert_dgmaxvol_values.unit), voltage: data.greenvoltage, current: data.greencurrent, max_voltage: data.greenvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: false, gui: 2, id: alert_dgmaxvol_values.id, mode: alert_dgmaxvol_values.mode })
                        : "" : ""

            data.yellowcurrent >= parseFloat(alert_mincur_values.value) && data.yellowcurrent <= parseFloat(alert_maxcur_values.value)
                ? data.yellowvoltage < parseFloat(alert_minvol_values.value) && alert_hgminvol_values.isactive === true
                    ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_hgminvol_values.message, data.yellowvoltage, alert_hgminvol_values.unit), voltage: data.yellowvoltage, current: data.yellowcurrent, max_voltage: data.yellowvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: data.yellowvoltage < parseFloat(alert_minvol_values.value) ? true : false, gui: 3, id: alert_hgminvol_values.id, mode: alert_hgminvol_values.mode })
                    : data.yellowvoltage > parseFloat(alert_maxvol_values.value) && alert_hgmaxvol_values.isactive === true
                        ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_hgmaxvol_values.message, data.yellowvoltage, alert_hgmaxvol_values.unit), voltage: data.yellowvoltage, current: data.yellowcurrent, max_voltage: data.yellowvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: false, gui: 3, id: alert_hgmaxvol_values.id, mode: alert_hgmaxvol_values.mode })
                        : "" : ""

            if (data.aspecttypeid == 3) {
                data.lightyellowcurrent >= parseFloat(alert_mincur_values.value) && data.lightyellowcurrent <= parseFloat(alert_maxcur_values.value)
                    ? data.lightyellowvoltage < parseFloat(alert_minvol_values.value) && alert_hhgminvol_values.isactive === true
                        ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_hhgminvol_values.message, data.lightyellowvoltage, alert_hhgminvol_values.unit), voltage: data.lightyellowvoltage, current: data.lightyellowcurrent, max_voltage: data.lightyellowvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: data.lightyellowvoltage < parseFloat(alert_minvol_values.value) ? true : false, gui: 3, id: alert_hhgminvol_values.id, mode: alert_hhgminvol_values.mode })
                        : data.lightyellowvoltage > parseFloat(alert_maxvol_values.value) && alert_hhgmaxvol_values.isactive === true
                            ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_hhgmaxvol_values.message, data.lightyellowvoltage, alert_hhgmaxvol_values.unit), voltage: data.lightyellowvoltage, current: data.lightyellowcurrent, max_voltage: data.lightyellowvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: false, gui: 3, id: alert_hhgmaxvol_values.id, mode: alert_hhgmaxvol_values.mode })
                            : "" : ""
            }

            //check for only relay voltage                
            var result = lodash.filter(glow_check, function (o) { return o.result; });
            var from_date = new Date(new Date().setSeconds(-parseInt(alert_off_values.value)));
            var to_date = new Date(new Date().setSeconds(-parseInt(alert_off_values.value) - parseInt(process.env.GRACE_BLANK_ALERT)));

            if (result.length == 1) // satifies only one condition
            {
                aspectcurrent = result[0].current
                aspectvoltage = result[0].voltage
                gui = result[0].gui

                if (error_voltage_data.length > 0) {
                    var max_voltage_result = lodash.filter(error_voltage_data, function (o) { return o.max_voltage; });
                    if (max_voltage_result.length > 0) {
                        let gui_glow = gui == 1 ? "RG glows and " : gui == 2 ? "DG glows and " : gui == 3 ? "HG glows and " : gui == 4 ? "HHG glows and " : ""
                        for (var element of error_voltage_data) {
                            alert_message_mode.push({ message: gui_glow + element.message, id: element.id, mode: element.mode })
                        }
                    }
                }
                else {
                    if (error_current_data.length > 0) {
                        var max_current_result = lodash.filter(error_current_data, function (o) { return o.max_current; });
                        if (max_current_result.length > 0) {
                            let gui_glow = gui == 1 ? "RG glows and " : gui == 2 ? "DG glows and " : gui == 3 ? "HG glows and " : gui == 4 ? "HHG glows and " : ""
                            for (var element of error_current_data) {
                                alert_message_mode.push({ message: gui_glow + element.message, id: element.id, mode: element.mode })
                            }
                        }
                    }
                }
            }
            else {
                if (result.length == 0) {
                    if (error_voltage_data.length > 0) {
                        var max_voltage_result = lodash.filter(error_voltage_data, function (o) { return o.max_voltage; });
                        if (max_voltage_result.length > 0) {
                            for (var element of error_voltage_data) {
                                alert_message_mode.push({ message: element.message, id: element.id, mode: element.mode })
                            }
                            let check_gui = [1]
                            let get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                            if (get_gui.length == 1) {
                                gui = 1
                                aspectcurrent = get_gui[0].current
                                aspectvoltage = get_gui[0].voltage
                            }
                            else {
                                check_gui = [2]
                                get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                if (get_gui.length == 1) {
                                    gui = 2
                                    aspectcurrent = get_gui[0].current
                                    aspectvoltage = get_gui[0].voltage
                                }
                                else {
                                    check_gui = [3]
                                    get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                    if (get_gui.length == 1) {
                                        gui = 3
                                        aspectcurrent = get_gui[0].current
                                        aspectvoltage = get_gui[0].voltage
                                    }
                                    else {
                                        if (data.aspecttypeid == 3) {
                                            check_gui = [4]
                                            get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                            if (get_gui.length == 1) {
                                                gui = 4
                                                aspectcurrent = get_gui[0].current
                                                aspectvoltage = get_gui[0].voltage
                                            }
                                        }
                                        check_gui = [1, 2]
                                        get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                        if (get_gui.length == 2) {
                                            gui = 5;
                                        }
                                        else {
                                            check_gui = [1, 3]
                                            get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                            if (get_gui.length == 2) {
                                                gui = 6;
                                            }
                                            else {
                                                if (data.aspecttypeid == 3) {
                                                    check_gui = [1, 4]
                                                    get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                                    if (get_gui.length == 2) {
                                                        gui = 7
                                                        aspectcurrent = get_gui[0].current
                                                        aspectvoltage = get_gui[0].voltage
                                                    }
                                                }
                                                check_gui = [2, 3]
                                                get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                                if (get_gui.length == 2) {
                                                    gui = 8;
                                                }
                                                else {
                                                    if (data.aspecttypeid == 3) {
                                                        check_gui = [2, 4]
                                                        get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                                        if (get_gui.length == 2) {
                                                            gui = 9
                                                            aspectcurrent = get_gui[0].current
                                                            aspectvoltage = get_gui[0].voltage
                                                        }
                                                        else {
                                                            check_gui = [3, 4]
                                                            get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                                            if (get_gui.length == 2) {
                                                                gui = 10
                                                                aspectcurrent = get_gui[0].current
                                                                aspectvoltage = get_gui[0].voltage
                                                            }
                                                        }
                                                    }
                                                    if (data.aspecttypeid == 3) {
                                                        check_gui = [1, 2, 3, 4]
                                                        get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                                        if (get_gui.length == 4) {
                                                            gui = 11;
                                                        }
                                                    }
                                                    else {
                                                        check_gui = [1, 2, 3]
                                                        get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                                        if (get_gui.length == 3) {
                                                            gui = 11;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else {
                        if (error_current_data.length > 0) {
                            var max_current_result = lodash.filter(error_current_data, function (o) { return o.max_current; });
                            if (max_current_result.length > 0) {
                                for (var element of error_current_data) {
                                    alert_message_mode.push({ message: element.message, id: element.id, mode: element.mode })
                                }
                                let check_gui = [1]
                                let get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                if (get_gui.length == 1) {

                                    gui = 1
                                    aspectcurrent = get_gui[0].current
                                    aspectvoltage = get_gui[0].voltage
                                }
                                else {
                                    check_gui = [2]
                                    get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                    if (get_gui.length == 1) {
                                        gui = 2
                                        aspectcurrent = get_gui[0].current
                                        aspectvoltage = get_gui[0].voltage
                                    }
                                    else {
                                        check_gui = [3]
                                        get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                        if (get_gui.length == 1) {
                                            gui = 3
                                            aspectcurrent = get_gui[0].current
                                            aspectvoltage = get_gui[0].voltage
                                        }
                                        else {
                                            if (data.aspecttypeid == 3) {
                                                check_gui = [4]
                                                get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                if (get_gui.length == 1) {
                                                    gui = 4
                                                    aspectcurrent = get_gui[0].current
                                                    aspectvoltage = get_gui[0].voltage
                                                }
                                            }
                                            check_gui = [1, 2]
                                            get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                            if (get_gui.length == 2) {
                                                gui = 5;
                                            }
                                            else {
                                                check_gui = [1, 3]
                                                get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                if (get_gui.length == 2) {
                                                    gui = 6;
                                                }
                                                else {
                                                    if (data.aspecttypeid == 3) {
                                                        check_gui = [1, 4]
                                                        get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                        if (get_gui.length == 2) {
                                                            gui = 7
                                                            aspectcurrent = get_gui[0].current
                                                            aspectvoltage = get_gui[0].voltage
                                                        }
                                                    }
                                                    check_gui = [2, 3]
                                                    get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                    if (get_gui.length == 2) {
                                                        gui = 8;
                                                    }
                                                    else {
                                                        if (data.aspecttypeid == 3) {
                                                            check_gui = [2, 4]
                                                            get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                            if (get_gui.length == 2) {
                                                                gui = 9
                                                                aspectcurrent = get_gui[0].current
                                                                aspectvoltage = get_gui[0].voltage
                                                            }
                                                            else {
                                                                check_gui = [3, 4]
                                                                get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                                if (get_gui.length == 2) {
                                                                    gui = 10
                                                                    aspectcurrent = get_gui[0].current
                                                                    aspectvoltage = get_gui[0].voltage
                                                                }
                                                            }
                                                        }
                                                        if (data.aspecttypeid == 3) {
                                                            check_gui = [1, 2, 3, 4]
                                                            get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                            if (get_gui.length == 4) {
                                                                gui = 11;
                                                            }
                                                        }
                                                        else {
                                                            check_gui = [1, 2, 3]
                                                            get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                            if (get_gui.length == 3) {
                                                                gui = 11;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else {
                            var get_off_list = [await SignalCircuitData.findOne({
                                where: {
                                    gui: 12,
                                    isdele: false,
                                    createddate: { [Op.gt]: to_date, [Op.lt]: from_date }
                                },
                                limit: 1,
                                order: [["id", "ASC"]]
                            })]
                            get_off_list = get_off_list[0] !== null ? get_off_list : []

                            if (get_off_list.length == 1) {
                                alert_message_mode.push({ message: await combine_mes_val_unit(alert_off_values.message, alert_off_values.value, alert_off_values.unit), id: [alert_off_values.id], mode: alert_off_values.mode })
                            }
                            gui = 12
                        }
                    }
                }
                else {
                    if (result.length > 0) {
                        let check_gui = []
                        if (data.aspecttypeid == 3) {
                            check_gui = [1, 2, 3]
                        }
                        else {
                            check_gui = [1, 2, 3, 4]
                        }

                        let get_gui = result.filter(e => check_gui.includes(e.gui));
                        if (get_gui.length == 3 || get_gui.length == 4) {
                            gui = 11
                            var get_on_list = [await SignalCircuitData.findOne({
                                where: {
                                    gui: 11,
                                    isdele: false,
                                    createddate: { [Op.gt]: to_date, [Op.lt]: from_date }
                                },
                                limit: 1,
                                order: [["id", "ASC"]]
                            })]
                            get_on_list = get_on_list[0] !== null ? get_on_list : []

                            if (get_on_list.length == 1) {
                                alert_message_mode.push({ message: await combine_mes_val_unit(alert_on_values.message, alert_on_values.value, alert_on_values.unit), id: [alert_on_values.id], mode: alert_on_values.mode })
                            }
                        }
                        else {
                            check_gui = [1, 2]
                            get_gui = result.filter(e => check_gui.includes(e.gui));
                            if (get_gui.length == 2) {
                                gui = 5
                                alert_message_mode.push({ message: await combine_mes_val_unit(alert_rgdg_values.message, alert_rgdg_values.value, alert_rgdg_values.unit), id: [alert_rgdg_values.id], mode: alert_rgdg_values.mode })
                            }
                            else {
                                check_gui = [1, 3]
                                get_gui = result.filter(e => check_gui.includes(e.gui));
                                if (get_gui.length == 2) {
                                    gui = 6
                                    alert_message_mode.push({ message: await combine_mes_val_unit(alert_rghg_values.message, alert_rghg_values.value, alert_rghg_values.unit), id: [alert_rghg_values.id], mode: alert_rghg_values.mode })
                                }
                                else {
                                    check_gui = [1, 4]
                                    get_gui = result.filter(e => check_gui.includes(e.gui));
                                    if (get_gui.length == 2) {
                                        gui = 7
                                        alert_message_mode.push({ message: await combine_mes_val_unit(alert_rghhg_values.message, alert_rghhg_values.value, alert_rghhg_values.unit), id: [alert_rghhg_values.id], mode: alert_rghhg_values.mode })
                                    }
                                    else {
                                        check_gui = [2, 3]
                                        get_gui = result.filter(e => check_gui.includes(e.gui));
                                        if (get_gui.length == 2) {
                                            gui = 8
                                            alert_message_mode.push({ message: await combine_mes_val_unit(alert_dghg_values.message, alert_dghg_values.value, alert_dghg_values.unit), id: [alert_dghg_values.id], mode: alert_dghg_values.mode })
                                        }
                                        else {
                                            check_gui = [2, 4]
                                            get_gui = result.filter(e => check_gui.includes(e.gui));
                                            if (get_gui.length == 2) {
                                                gui = 9
                                                alert_message_mode.push({ message: await combine_mes_val_unit(alert_dghhg_values.message, alert_dghhg_values.value, alert_dghhg_values.unit), id: [alert_dghhg_values.id], mode: alert_dghhg_values.mode })
                                            }
                                            else {
                                                check_gui = [3, 4]
                                                get_gui = result.filter(e => check_gui.includes(e.gui));
                                                if (get_gui.length == 2) {
                                                    gui = 10
                                                    alert_message_mode.push({ message: await combine_mes_val_unit(alert_hghhg_values.message, alert_hghhg_values.value, alert_hghhg_values.unit), id: [alert_hghhg_values.id], mode: alert_hghhg_values.mode })
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (error_voltage_data.length > 0) {
                var min_voltage_result = lodash.filter(error_voltage_data, function (o) { return o.min_voltage; });
                if (min_voltage_result.length > 0) {
                    let gui_glow = gui == 1 ? "RG glows and " : gui == 2 ? "DG glows and " : gui == 3 ? "HG glows and " : gui == 4 ? "HHG glows and " : ""
                    if (gui_glow == "") {
                        for (var element of error_voltage_data) {
                            alert_message_mode.push({ message: element.message, id: element.id, mode: element.mode })
                        }
                        if (min_voltage_result.length == 1) {
                            gui = min_voltage_result[0].gui
                            aspectcurrent = min_voltage_result[0].current
                            aspectvoltage = min_voltage_result[0].voltage
                        }
                    }
                    else {
                        for (var element of error_voltage_data) {
                            alert_message_mode.push({ message: gui_glow + element.message, id: element.id, mode: element.mode })
                        }
                    }
                }
            }
            if (error_current_data.length > 0) {
                var min_current_result = lodash.filter(error_current_data, function (o) { return o.min_current; });
                if (min_current_result.length > 0) {
                    let gui_glow = gui == 1 ? "RG glows and " : gui == 2 ? "DG glows and " : gui == 3 ? "HG glows and " : gui == 4 ? "HHG glows and " : ""
                    if (gui_glow == "") {
                        for (var element of error_current_data) {
                            alert_message_mode.push({ message: element.message, id: element.id, mode: element.mode })
                        }
                        if (min_current_result.length == 1) {
                            gui = min_current_result[0].gui
                            aspectcurrent = min_current_result[0].current
                            aspectvoltage = min_current_result[0].voltage
                        }
                    }
                    else {
                        for (var element of error_current_data) {
                            alert_message_mode.push({ message: gui_glow + element.message, id: element.id, mode: element.mode })
                        }
                    }
                }
            }

            if (gui == 0) {
                gui = 12
            }

            let signal_aspect = gui == 1 ? "RG" : gui == 2 ? "DG" : gui == 3 ? "HG" : gui == 4 ? "HHG" : gui == 5 ? "RG DG" : gui == 6 ? "RG HG"
                : gui == 7 ? "RG HHG" : gui == 8 ? "DG HG" : gui == 9 ? "DG HHG" : gui == 10 ? "HG HHG" : gui == 11 ? "ALL" : gui == 12 ? "OFF" : "OFF"

            let insert_dataid = ""

            const data_insert = await SignalCircuitData.create({
                signalcircuitid: parseInt(data.signalcircuitid),
                terminal: data.terminal,
                greenvoltage: data.greenvoltage,
                greencurrent: data.greencurrent,
                redvoltage: data.redvoltage,
                redcurrent: data.redcurrent,
                yellowvoltage: data.yellowvoltage,
                yellowcurrent: data.yellowcurrent,
                lightyellowvoltage: data.lightyellowvoltage,
                lightyellowcurrent: data.lightyellowcurrent,
                signal_aspect: signal_aspect,
                aspect_current: aspectcurrent,
                aspect_voltage: aspectvoltage,
                index_score: index_score,
                gui: gui,
                createddate: data.createddate,
                isdele: false
            },
                { transaction: transaction }
            ).then(res => insert_dataid = res.id)
            //logs.info('signal_insert_dataid', insert_dataid)

            const cycle_index = signalcircuitdatas.findIndex(obj => { return obj.key === data.signalcircuitid.toString(); });
            if (cycle_index !== -1) {
                signalcircuitdatas[cycle_index].data = data_insert[0]
                signalcircuitdatas[cycle_index].id = insert_dataid
            }
            else {
                signalcircuitdatas.push({ key: data.signalcircuitid.toString(), data: data_insert[0], id: insert_dataid });
            }

            let alert_data = {}
            let alert_logs = []
            let alert_modeid = 0

            let mobile_notification_data = []

            var mode_filtered = lodash.groupBy(alert_message_mode, function (o) { return o.mode })

            if (alert_message_mode.length > 0) {
                for (var property in mode_filtered) {
                    let alertid = ""
                    let modeid = lodash.result(lodash.find(AlertModes, { 'mode': property }), 'id')
                    alert_modeid = alert_modeid == null ? modeid : alert_modeid > modeid ? alert_modeid : modeid

                    alert_data = {
                        signalcircuitid: parseInt(data.signalcircuitid),
                        signalcircuitdataid: insert_dataid,
                        stationid: data.stationid,
                        message: mode_filtered[property].map(i => i.message).join(' ; '),
                        assertsid: data.assertid,
                        modeid: modeid,
                        createddate: data.createddate,
                        isdele: false
                    }
                    alert_logs.push(alert_data)

                    const alertinsert = await SignalCircuitAlert.create(alert_data, { transaction: transaction }).then(res => alertid = res.id)
                    //logs.info(`station signalcircuit alert ended`);
                    //console.log(`station signalcircuit alert ended`); 

                    var get_users = await NotificationControl.findAll({ where: { assertsid: data.assertid, stationid: data.stationid, isdele: false } })
                    var get_users_id = lodash.uniq(get_users.map(item => item.userid))

                    let alert_message_ids = lodash.uniq(mode_filtered[property].map(i => i.id)).sort((a, b) => a - b)

                    for (let i = 0; i < get_users_id.length; i++) {

                        const get_previous_notification = await NotificationSend.findOne({
                            where: { stationid: data.stationid, assertsid: data.assertid, alertmessageids: alert_message_ids, modeid: modeid, userid: get_users_id[i], isseen: false, isdele: false },
                            order: [["id", "DESC"]]
                        })

                        if (get_previous_notification == null) {
                            mobile_notification_data.push({
                                stationid: data.stationid,
                                stationcode: data.stationcode,
                                stationname: data.stationname,
                                assertname: data.assertname,
                                assertsid: data.assertid,
                                assertidname: data.signalname,
                                alertid: alertid,
                                userid: get_users_id[i],
                                message: mode_filtered[property].map(i => i.message),
                                modeid: modeid,
                                mode: property,
                                alertmessageids: alert_message_ids,
                                isseen: false,
                                issend: false,
                                createddate: data.createddate,
                            })
                        }
                    }
                }

                if (mobile_notification_data.length > 0) {
                    const notifiyinsert = await NotificationSend.bulkCreate(mobile_notification_data, { transaction: transaction })
                    Socket.emit('Notification', mobile_notification_data);
                    //socketcloud.emit("Notification", mobile_notification_data)
                }
            }

            let data_logs = {
                id: insert_dataid,
                signalcircuitid: parseInt(data.signalcircuitid),
                signalname: data.signalname,
                terminal: data.terminal,
                aspecttypeid: data.aspecttypeid,
                greenvoltage: data.greenvoltage,
                greencurrent: data.greencurrent,
                redvoltage: data.redvoltage,
                redcurrent: data.redcurrent,
                yellowvoltage: data.yellowvoltage,
                yellowcurrent: data.yellowcurrent,
                lightyellowvoltage: data.lightyellowvoltage,
                lightyellowcurrent: data.lightyellowcurrent,
                signal_aspect: signal_aspect,
                aspect_current: aspectcurrent,
                aspect_voltage: aspectvoltage,
                index_score: index_score,
                gui: gui,
                createddate: data.createddate,
                time: moment(data.createddate).format("HH:mm:ss"),
                isdele: false
            }

            // //commented it out because not using now
            // let signals = []
            // signals.push({
            //     id: parseInt(data.signalcircuitid),
            //     signalname: data.signalname,
            //     signal_aspect: signal_aspect,
            //     aspect_current: aspectcurrent,
            //     aspect_voltage: aspectvoltage,
            //     index_score: index_score,
            //     gui: gui,
            //     createddate: data.createddate,
            // })

            // var signalcircuits = await RegisteredSignalCircuit.findAll({ where: { isdele: false, stationid: data.stationid } })
            // for (let i = 0; i < signalcircuits.length; i++) //for await(const element of signalcircuits)
            // {
            //     let element = signalcircuits[i]
            //     var get_finalsignalcircuit_datas = [await SignalCircuitData.findOne({ limit: 1, where: { isdele: false, signalcircuitid: element.id }, order: [["id", "DESC"]] }, { transaction: transaction })];
            //     get_finalsignalcircuit_datas = get_finalsignalcircuit_datas[0] !== null ? get_finalsignalcircuit_datas : []
            //     if (get_finalsignalcircuit_datas.length > 0 && element.id != parseInt(data.signalcircuitid)) {
            //         signals.push({
            //             id: element.id,
            //             signalname: element.signalname,
            //             signal_aspect: get_finalsignalcircuit_datas[0].signal_aspect,
            //             aspect_current: get_finalsignalcircuit_datas[0].aspect_current,
            //             aspect_voltage: get_finalsignalcircuit_datas[0].aspect_voltage,
            //             index_score: get_finalsignalcircuit_datas[0].index_score,
            //             gui: get_finalsignalcircuit_datas[0].gui,
            //             createddate: get_finalsignalcircuit_datas[0].createddate,
            //         })
            //     }
            // }

            let socket_data = {
                data_logs: data_logs,
                // signals: signals,
                alertmodeid: alert_logs.length > 0 ? alert_modeid : null,
                alerts: alert_logs
            }

            await transaction.commit();
            //logs.info('signalcircuitdata',socket_data )
            Socket.emit("signalcircuitdata", socket_data)
            //socketcloud.emit("Signal", socket_data)
        }
        catch (ex) {
            await transaction.rollback();
            logs.error('station signal circuit data error' + ex);
            //console.log('station signal circuit data error' + ex);
        }
    }

    // Active - Signal Circuit Data
    async function insert_signalcircuit_updated(data) {
        logs.info(`station signalcircuit alert started`);
        //console.log(`station signalcircuit alert started`);
        let transaction = await db.transaction({ autocommit: false });
        try {
            alert_value_list = require("./alertvalue").getValues();
            let station_id = data.stationid
            let signalcircuitid = data.signalcircuitid
            let assertname = data.assertname
            let aspectcurrent = 0
            let aspectvoltage = 0
            let gui = 0
            let index_score = 5

            let glow_check = []
            let error_voltage_data = []
            let error_current_data = []

            //get for only one light glows based on min and max conditions
            //logs.info(`signal cirucit glow result check`);
            //console.log(`signal cirucit glow result check`);

            var alert_minvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@MIN_ASPECT_VOLTAGE`)
            var alert_maxvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@MAX_ASPECT_VOLTAGE`)
            var alert_mincur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@MIN_ASPECT_CURRENT`)
            var alert_maxcur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@MAX_ASPECT_CURRENT`)

            var alert_rgmincur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@RG_CURRENT_MIN`)
            var alert_dgmincur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@DG_CURRENT_MIN`)
            var alert_hgmincur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HG_CURRENT_MIN`)
            var alert_hhgmincur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HHG_CURRENT_MIN`)

            var alert_rgmaxcur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@RG_CURRENT_MAX`)
            var alert_dgmaxcur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@DG_CURRENT_MAX`)
            var alert_hgmaxcur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HG_CURRENT_MAX`)
            var alert_hhgmaxcur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HHG_CURRENT_MAX`)

            var alert_rgminvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@RG_VOLTAGE_MIN`)
            var alert_dgminvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@DG_VOLTAGE_MIN`)
            var alert_hgminvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HG_VOLTAGE_MIN`)
            var alert_hhgminvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HHG_VOLTAGE_MIN`)

            var alert_rgmaxvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@RG_VOLTAGE_MAX`)
            var alert_dgmaxvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@DG_VOLTAGE_MAX`)
            var alert_hgmaxvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HG_VOLTAGE_MAX`)
            var alert_hhgmaxvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HHG_VOLTAGE_MAX`)

            var alert_rgdg_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@RG_DG`)
            var alert_rghg_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@RG_HG`)
            var alert_rghhg_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@RG_HHG`)
            var alert_dghg_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@DG_HG`)
            var alert_dghhg_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@DG_HHG`)
            var alert_hghhg_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HG_HHG`)

            var alert_message_mode = []

            var alert_off_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@SIGNAL_BLANK_ALERT`)
            var alert_on_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@SIGNAL_GLOW_ALERT`)

            data.redvoltage >= parseFloat(alert_minvol_values.value) && data.redvoltage <= parseFloat(alert_maxvol_values.value) && data.redcurrent >= parseFloat(alert_mincur_values.value) && data.redcurrent <= parseFloat(alert_maxcur_values.value)
                ? glow_check.push({ result: true, voltage: data.redvoltage, current: data.redcurrent, gui: 1 }) : ""

            data.greenvoltage >= parseFloat(alert_minvol_values.value) && data.greenvoltage <= parseFloat(alert_maxvol_values.value) && data.greencurrent >= parseFloat(alert_mincur_values.value) && data.greencurrent <= parseFloat(alert_maxcur_values.value)
                ? glow_check.push({ result: true, voltage: data.greenvoltage, current: data.greencurrent, gui: 2 }) : ""

            data.yellowvoltage >= parseFloat(alert_minvol_values.value) && data.yellowvoltage <= parseFloat(alert_maxvol_values.value) && data.yellowcurrent >= parseFloat(alert_mincur_values.value) && data.yellowcurrent <= parseFloat(alert_maxcur_values.value)
                ? glow_check.push({ result: true, voltage: data.yellowvoltage, current: data.yellowcurrent, gui: 3 }) : ""


            if (data.aspecttypeid == 4 || 5 || 6 || 12) {
                data.lightyellowvoltage >= parseFloat(alert_minvol_values.value) && data.lightyellowvoltage <= parseFloat(alert_maxvol_values.value) && data.lightyellowcurrent >= parseFloat(alert_mincur_values.value) && data.lightyellowcurrent <= parseFloat(alert_maxcur_values.value)
                    ? glow_check.push({ result: true, voltage: data.lightyellowvoltage, current: data.lightyellowcurrent, gui: 4 }) : ""
            }

            //check for only current
            //logs.info(`signal cirucit current error check`);
            //console.log(`signal cirucit current error check`);

            data.redvoltage >= parseFloat(alert_minvol_values.value) && data.redvoltage <= parseFloat(alert_maxvol_values.value)
                ? data.redcurrent < parseFloat(alert_mincur_values.value) && alert_rgmincur_values.isactive === true
                    ? error_current_data.push({ message: await combine_mes_val_unit(alert_rgmincur_values.message, data.redcurrent, alert_rgmincur_values.unit), voltage: data.redvoltage, current: data.redcurrent, max_current: data.redcurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: data.redcurrent < parseFloat(alert_mincur_values.value) ? true : false, gui: 1, id: alert_rgmincur_values.id, mode: alert_rgmincur_values.mode })
                    : data.redcurrent > parseFloat(alert_maxcur_values.value) && alert_rgmaxcur_values.isactive === true
                        ? error_current_data.push({ message: await combine_mes_val_unit(alert_rgmaxcur_values.message, data.redcurrent, alert_rgmaxcur_values.unit), voltage: data.redvoltage, current: data.redcurrent, max_current: data.redcurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: false, gui: 1, id: alert_rgmaxcur_values.id, mode: alert_rgmaxcur_values.mode })
                        : "" : ""

            data.greenvoltage >= parseFloat(alert_minvol_values.value) && data.greenvoltage <= parseFloat(alert_maxvol_values.value)
                ? data.greencurrent < parseFloat(alert_mincur_values.value) && alert_dgmincur_values.isactive === true
                    ? error_current_data.push({ message: await combine_mes_val_unit(alert_dgmincur_values.message, data.greencurrent, alert_dgmincur_values.unit), voltage: data.greenvoltage, current: data.greencurrent, max_current: data.greencurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: data.greencurrent < parseFloat(alert_mincur_values.value) ? true : false, gui: 2, id: alert_dgmincur_values.id, mode: alert_dgmincur_values.mode })
                    : data.greencurrent > parseFloat(alert_maxcur_values.value) && alert_dgmaxcur_values.isactive === true
                        ? error_current_data.push({ message: await combine_mes_val_unit(alert_dgmaxcur_values.message, data.greencurrent, alert_dgmaxcur_values.unit), voltage: data.greenvoltage, current: data.greencurrent, max_current: data.greencurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: false, gui: 2, id: alert_dgmaxcur_values.id, mode: alert_dgmaxcur_values.mode })
                        : "" : ""

            data.yellowvoltage >= parseFloat(alert_minvol_values.value) && data.yellowvoltage <= parseFloat(alert_maxvol_values.value)
                ? data.yellowcurrent < parseFloat(alert_mincur_values.value) && alert_hgmincur_values.isactive === true
                    ? error_current_data.push({ message: await combine_mes_val_unit(alert_hgmincur_values.message, data.yellowcurrent, alert_hgmincur_values.unit), voltage: data.yellowvoltage, current: data.yellowcurrent, max_current: data.yellowcurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: data.yellowcurrent < parseFloat(alert_mincur_values.value) ? true : false, gui: 3, id: alert_hgmincur_values.id, mode: alert_hgmincur_values.mode })
                    : data.yellowcurrent > parseFloat(alert_maxcur_values.value) && alert_hgmaxcur_values.isactive === true
                        ? error_current_data.push({ message: await combine_mes_val_unit(alert_hgmaxcur_values.message, data.yellowcurrent, alert_hgmaxcur_values.unit), voltage: data.yellowvoltage, current: data.yellowcurrent, max_current: data.yellowcurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: false, gui: 3, id: alert_hgmaxcur_values.id, mode: alert_hgmaxcur_values.mode })
                        : "" : ""

            if (data.aspecttypeid == 4 || 5 || 6 || 12) {
                data.lightyellowvoltage >= parseFloat(alert_minvol_values.value) && data.lightyellowvoltage <= parseFloat(alert_maxvol_values.value)
                    ? data.lightyellowcurrent < parseFloat(alert_mincur_values.value) && alert_hhgmincur_values.isactive === true
                        ? error_current_data.push({ message: await combine_mes_val_unit(alert_hhgmincur_values.message, data.lightyellowcurrent, alert_hhgmincur_values.unit), voltage: data.lightyellowvoltage, current: data.lightyellowcurrent, max_current: data.lightyellowcurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: data.lightyellowcurrent < parseFloat(alert_mincur_values.value) ? true : false, gui: 3, id: alert_hhgmincur_values.id, mode: alert_hhgmincur_values.mode })
                        : data.lightyellowcurrent > parseFloat(alert_maxcur_values.value) && alert_hhgmaxcur_values.isactive === true
                            ? error_current_data.push({ message: await combine_mes_val_unit(alert_hhgmaxcur_values.message, data.lightyellowcurrent, alert_hhgmaxcur_values.unit), voltage: data.lightyellowvoltage, current: data.lightyellowcurrent, max_current: data.lightyellowcurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: false, gui: 3, id: alert_hhgmaxcur_values.id, mode: alert_hhgmaxcur_values.mode })
                            : "" : ""
            }

            //check for only voltage
            //logs.info(`signal cirucit voltage error check`);
            //console.log(`signal cirucit voltage error check`);

            data.redcurrent >= parseFloat(alert_mincur_values.value) && data.redcurrent <= parseFloat(alert_maxcur_values.value)
                ? data.redvoltage < parseFloat(alert_minvol_values.value) && alert_rgminvol_values.isactive === true
                    ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_rgminvol_values.message, data.redvoltage, alert_rgminvol_values.unit), voltage: data.redvoltage, current: data.redcurrent, max_voltage: data.redvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: data.redvoltage < parseFloat(alert_minvol_values.value) ? true : false, gui: 1, id: alert_rgminvol_values.id, mode: alert_rgminvol_values.mode })
                    : data.redvoltage > parseFloat(alert_maxvol_values.value) && alert_rgmaxvol_values.isactive === true
                        ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_rgmaxvol_values.message, data.redvoltage, alert_rgmaxvol_values.unit), voltage: data.redvoltage, current: data.redcurrent, max_voltage: data.redvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: false, gui: 1, id: alert_rgmaxvol_values.id, mode: alert_rgmaxvol_values.mode })
                        : "" : ""

            data.greencurrent >= parseFloat(alert_mincur_values.value) && data.greencurrent <= parseFloat(alert_maxcur_values.value)
                ? data.greenvoltage < parseFloat(alert_minvol_values.value) && alert_dgminvol_values.isactive === true
                    ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_dgminvol_values.message, data.greenvoltage, alert_dgminvol_values.unit), voltage: data.greenvoltage, current: data.greencurrent, max_voltage: data.greenvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: data.greenvoltage < parseFloat(alert_minvol_values.value) ? true : false, gui: 2, id: alert_dgminvol_values.id, mode: alert_dgminvol_values.mode })
                    : data.greenvoltage > parseFloat(alert_maxvol_values.value) && alert_dgmaxvol_values.isactive === true
                        ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_dgmaxvol_values.message, data.greenvoltage, alert_dgmaxvol_values.unit), voltage: data.greenvoltage, current: data.greencurrent, max_voltage: data.greenvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: false, gui: 2, id: alert_dgmaxvol_values.id, mode: alert_dgmaxvol_values.mode })
                        : "" : ""

            data.yellowcurrent >= parseFloat(alert_mincur_values.value) && data.yellowcurrent <= parseFloat(alert_maxcur_values.value)
                ? data.yellowvoltage < parseFloat(alert_minvol_values.value) && alert_hgminvol_values.isactive === true
                    ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_hgminvol_values.message, data.yellowvoltage, alert_hgminvol_values.unit), voltage: data.yellowvoltage, current: data.yellowcurrent, max_voltage: data.yellowvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: data.yellowvoltage < parseFloat(alert_minvol_values.value) ? true : false, gui: 3, id: alert_hgminvol_values.id, mode: alert_hgminvol_values.mode })
                    : data.yellowvoltage > parseFloat(alert_maxvol_values.value) && alert_hgmaxvol_values.isactive === true
                        ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_hgmaxvol_values.message, data.yellowvoltage, alert_hgmaxvol_values.unit), voltage: data.yellowvoltage, current: data.yellowcurrent, max_voltage: data.yellowvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: false, gui: 3, id: alert_hgmaxvol_values.id, mode: alert_hgmaxvol_values.mode })
                        : "" : ""

            if (data.aspecttypeid == 4 || 5 || 6 || 12) {
                data.lightyellowcurrent >= parseFloat(alert_mincur_values.value) && data.lightyellowcurrent <= parseFloat(alert_maxcur_values.value)
                    ? data.lightyellowvoltage < parseFloat(alert_minvol_values.value) && alert_hhgminvol_values.isactive === true
                        ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_hhgminvol_values.message, data.lightyellowvoltage, alert_hhgminvol_values.unit), voltage: data.lightyellowvoltage, current: data.lightyellowcurrent, max_voltage: data.lightyellowvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: data.lightyellowvoltage < parseFloat(alert_minvol_values.value) ? true : false, gui: 3, id: alert_hhgminvol_values.id, mode: alert_hhgminvol_values.mode })
                        : data.lightyellowvoltage > parseFloat(alert_maxvol_values.value) && alert_hhgmaxvol_values.isactive === true
                            ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_hhgmaxvol_values.message, data.lightyellowvoltage, alert_hhgmaxvol_values.unit), voltage: data.lightyellowvoltage, current: data.lightyellowcurrent, max_voltage: data.lightyellowvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: false, gui: 3, id: alert_hhgmaxvol_values.id, mode: alert_hhgmaxvol_values.mode })
                            : "" : ""
            }

            //check for only relay voltage                
            var result = lodash.filter(glow_check, function (o) { return o.result; });
            var from_date = new Date(new Date().setSeconds(-parseInt(alert_off_values.value)));
            var to_date = new Date(new Date().setSeconds(-parseInt(alert_off_values.value) - parseInt(process.env.GRACE_BLANK_ALERT)));

            if (result.length == 1) // satifies only one condition
            {
                aspectcurrent = result[0].current
                aspectvoltage = result[0].voltage
                gui = result[0].gui

                if (error_voltage_data.length > 0) {
                    var max_voltage_result = lodash.filter(error_voltage_data, function (o) { return o.max_voltage; });
                    if (max_voltage_result.length > 0) {
                        let gui_glow = gui == 1 ? "RG glows and " : gui == 2 ? "DG glows and " : gui == 3 ? "HG glows and " : gui == 4 ? "HHG glows and " : ""
                        for (var element of error_voltage_data) {
                            alert_message_mode.push({ message: gui_glow + element.message, id: element.id, mode: element.mode })
                        }
                    }
                }
                else {
                    if (error_current_data.length > 0) {
                        var max_current_result = lodash.filter(error_current_data, function (o) { return o.max_current; });
                        if (max_current_result.length > 0) {
                            let gui_glow = gui == 1 ? "RG glows and " : gui == 2 ? "DG glows and " : gui == 3 ? "HG glows and " : gui == 4 ? "HHG glows and " : ""
                            for (var element of error_current_data) {
                                alert_message_mode.push({ message: gui_glow + element.message, id: element.id, mode: element.mode })
                            }
                        }
                    }
                }
            }
            else {
                if (result.length == 0) {
                    if (error_voltage_data.length > 0) {
                        var max_voltage_result = lodash.filter(error_voltage_data, function (o) { return o.max_voltage; });
                        if (max_voltage_result.length > 0) {
                            for (var element of error_voltage_data) {
                                alert_message_mode.push({ message: element.message, id: element.id, mode: element.mode })
                            }
                            let check_gui = [1]
                            let get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                            if (get_gui.length == 1) {
                                gui = 1
                                aspectcurrent = get_gui[0].current
                                aspectvoltage = get_gui[0].voltage
                            }
                            else {
                                check_gui = [2]
                                get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                if (get_gui.length == 1) {
                                    gui = 2
                                    aspectcurrent = get_gui[0].current
                                    aspectvoltage = get_gui[0].voltage
                                }
                                else {
                                    check_gui = [3]
                                    get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                    if (get_gui.length == 1) {
                                        gui = 3
                                        aspectcurrent = get_gui[0].current
                                        aspectvoltage = get_gui[0].voltage
                                    }
                                    else {
                                        if (data.aspecttypeid == 4 || 5 || 6 || 12) {
                                            check_gui = [4]
                                            get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                            if (get_gui.length == 1) {
                                                gui = 4
                                                aspectcurrent = get_gui[0].current
                                                aspectvoltage = get_gui[0].voltage
                                            }
                                        }
                                        check_gui = [1, 2]
                                        get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                        if (get_gui.length == 2) {
                                            gui = 5;
                                            aspectcurrent = get_gui[0].current + ';' + get_gui[1].current
                                            aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage
                                        }
                                        else {
                                            check_gui = [1, 3]
                                            get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                            if (get_gui.length == 2) {
                                                gui = 6;
                                                aspectcurrent = get_gui[0].current + ';' + get_gui[1].current
                                                aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage
                                            }
                                            else {
                                                if (data.aspecttypeid == 4 || 5 || 6 || 12) {
                                                    check_gui = [1, 4]
                                                    get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                                    if (get_gui.length == 2) {
                                                        gui = 7
                                                        aspectcurrent = get_gui[0].current + ';' + get_gui[1].current
                                                        aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage
                                                    }
                                                }
                                                check_gui = [2, 3]
                                                get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                                if (get_gui.length == 2) {
                                                    gui = 8;
                                                    aspectcurrent = get_gui[0].current + ';' + get_gui[1].current
                                                    aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage
                                                }
                                                else {
                                                    if (data.aspecttypeid == 4 || 5 || 6 || 12) {
                                                        check_gui = [2, 4]
                                                        get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                                        if (get_gui.length == 2) {
                                                            gui = 9
                                                            aspectcurrent = get_gui[0].current + ';' + get_gui[1].current
                                                            aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage
                                                        }
                                                        else {
                                                            check_gui = [3, 4]
                                                            get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                                            if (get_gui.length == 2) {
                                                                gui = 10
                                                                aspectcurrent = get_gui[0].current + ';' + get_gui[1].current
                                                                aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage
                                                            }
                                                        }
                                                    }
                                                    if (data.aspecttypeid == 4 || 5 || 6 || 12) {
                                                        check_gui = [1, 2, 3, 4]
                                                        get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                                        if (get_gui.length == 4) {
                                                            gui = 11;
                                                            aspectcurrent = get_gui[0].current + ';' + get_gui[1].current + ';' + get_gui[2].current + ';' + get_gui[3].current
                                                            aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage + ';' + get_gui[2].voltage + ';' + get_gui[3].voltage
                                                        }
                                                    }
                                                    else {
                                                        check_gui = [1, 2, 3]
                                                        get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                                        if (get_gui.length == 3) {
                                                            gui = 11;
                                                            aspectcurrent = get_gui[0].current + ';' + get_gui[1].current + ';' + get_gui[2].current 
                                                            aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage + ';' + get_gui[2].voltage 
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else {
                        if (error_current_data.length > 0) {
                            var max_current_result = lodash.filter(error_current_data, function (o) { return o.max_current; });
                            if (max_current_result.length > 0) {
                                for (var element of error_current_data) {
                                    alert_message_mode.push({ message: element.message, id: element.id, mode: element.mode })
                                }
                                let check_gui = [1]
                                let get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                if (get_gui.length == 1) {
                                    gui = 1
                                    aspectcurrent = get_gui[0].current
                                    aspectvoltage = get_gui[0].voltage
                                }
                                else {
                                    check_gui = [2]
                                    get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                    if (get_gui.length == 1) {
                                        gui = 2
                                        aspectcurrent = get_gui[0].current
                                        aspectvoltage = get_gui[0].voltage
                                    }
                                    else {
                                        check_gui = [3]
                                        get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                        if (get_gui.length == 1) {
                                            gui = 3
                                            aspectcurrent = get_gui[0].current
                                            aspectvoltage = get_gui[0].voltage
                                        }
                                        else {
                                            if (data.aspecttypeid == 4 || 5 || 6 || 12) {
                                                check_gui = [4]
                                                get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                if (get_gui.length == 1) {
                                                    gui = 4
                                                    aspectcurrent = get_gui[0].current
                                                    aspectvoltage = get_gui[0].voltage
                                                }
                                            }
                                            check_gui = [1, 2]
                                            get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                            if (get_gui.length == 2) {
                                                gui = 5;
                                                aspectcurrent = get_gui[0].current + ';' + get_gui[1].current 
                                                aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage 
                                            }
                                            else {
                                                check_gui = [1, 3]
                                                get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                if (get_gui.length == 2) {
                                                    gui = 6;
                                                    aspectcurrent = get_gui[0].current + ';' + get_gui[1].current 
                                                    aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage 
                                                }
                                                else {
                                                    if (data.aspecttypeid == 4 || 5 || 6 || 12) {
                                                        check_gui = [1, 4]
                                                        get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                        if (get_gui.length == 2) {
                                                            gui = 7
                                                            aspectcurrent = get_gui[0].current + ';' + get_gui[1].current 
                                                             aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage 
                                                        }
                                                    }
                                                    check_gui = [2, 3]
                                                    get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                    if (get_gui.length == 2) {
                                                        gui = 8;
                                                        aspectcurrent = get_gui[0].current + ';' + get_gui[1].current 
                                                        aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage 
                                                    }
                                                    else {
                                                        if (data.aspecttypeid == 4 || 5 || 6 || 12) {
                                                            check_gui = [2, 4]
                                                            get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                            if (get_gui.length == 2) {
                                                                gui = 9
                                                                aspectcurrent = get_gui[0].current + ';' + get_gui[1].current 
                                                                aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage 
                                                            }
                                                            else {
                                                                check_gui = [3, 4]
                                                                get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                                if (get_gui.length == 2) {
                                                                    gui = 10
                                                                    aspectcurrent = get_gui[0].current + ';' + get_gui[1].current 
                                                                    aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage 
                                                                }
                                                            }
                                                        }
                                                        if (data.aspecttypeid == 4 || 5 || 6 || 12) {
                                                            check_gui = [1, 2, 3, 4]
                                                            get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                            if (get_gui.length == 4) {
                                                                gui = 11;
                                                                aspectcurrent = get_gui[0].current + ';' + get_gui[1].current + ';' + get_gui[2].current + ';' + get_gui[3].current
                                                                aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage + ';' + get_gui[2].voltage + ';' + get_gui[3].voltage
                                                            }
                                                        }
                                                        else {
                                                            check_gui = [1, 2, 3]
                                                            get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                            if (get_gui.length == 3) {
                                                                gui = 11;
                                                                aspectcurrent = get_gui[0].current + ';' + get_gui[1].current + ';' + get_gui[2].current 
                                                                aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage + ';' + get_gui[2].voltage 
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else {
                            var get_off_list = [await SignalCircuitData.findOne({
                                where: {
                                    gui: 12,
                                    isdele: false,
                                    createddate: { [Op.gt]: to_date, [Op.lt]: from_date }
                                },
                                limit: 1,
                                order: [["id", "ASC"]]
                            })]
                            get_off_list = get_off_list[0] !== null ? get_off_list : []

                            if (get_off_list.length == 1) {
                                alert_message_mode.push({ message: await combine_mes_val_unit(alert_off_values.message, alert_off_values.value, alert_off_values.unit), id: [alert_off_values.id], mode: alert_off_values.mode })
                            }
                            gui = 12
                        }
                    }
                }
                else {
                    if (result.length > 0) {
                        let check_gui = []
                        if (data.aspecttypeid == 4 || 5 || 6 || 12) {
                            check_gui = [1, 2, 3]
                        }
                        else {
                            check_gui = [1, 2, 3, 4]
                        }

                        let get_gui = result.filter(e => check_gui.includes(e.gui));
                        if (get_gui.length == 3 || get_gui.length == 4) {
                            gui = 11
                            var get_on_list = [await SignalCircuitData.findOne({
                                where: {
                                    gui: 11,
                                    isdele: false,
                                    createddate: { [Op.gt]: to_date, [Op.lt]: from_date }
                                },
                                limit: 1,
                                order: [["id", "ASC"]]
                            })]
                            get_on_list = get_on_list[0] !== null ? get_on_list : []

                            if (get_on_list.length == 1) {
                                alert_message_mode.push({ message: await combine_mes_val_unit(alert_on_values.message, alert_on_values.value, alert_on_values.unit), id: [alert_on_values.id], mode: alert_on_values.mode })
                            }
                            if (get_gui.length == 3) {
                                aspectcurrent = get_gui[0].current + ';' + get_gui[1].current + ';' + get_gui[2].current 
                                aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage + ';' + get_gui[2].voltage 
                            }
                            else {
                                aspectcurrent = get_gui[0].current + ';' + get_gui[1].current + ';' + get_gui[2].current + ';' + get_gui[3].current
                                aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage + ';' + get_gui[2].voltage + ';' + get_gui[3].voltage
                            }  
                        }
                        else {
                            check_gui = [1, 2]
                            get_gui = result.filter(e => check_gui.includes(e.gui));
                            if (get_gui.length == 2) {
                                gui = 5
                                if (alert_rgdg_values.isactive === true) {
                                    alert_message_mode.push({ message: await combine_mes_val_unit(alert_rgdg_values.message, alert_rgdg_values.value, alert_rgdg_values.unit), id: [alert_rgdg_values.id], mode: alert_rgdg_values.mode })
                                }
                                aspectcurrent = get_gui[0].current + ';' + get_gui[1].current 
                                aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage 
                            }
                            else {
                                check_gui = [1, 3]
                                get_gui = result.filter(e => check_gui.includes(e.gui));
                                if (get_gui.length == 2) {
                                    gui = 6
                                    if (alert_rghg_values.isactive === true) {
                                        alert_message_mode.push({ message: await combine_mes_val_unit(alert_rghg_values.message, alert_rghg_values.value, alert_rghg_values.unit), id: [alert_rghg_values.id], mode: alert_rghg_values.mode })
                                    }
                                    aspectcurrent = get_gui[0].current + ';' + get_gui[1].current 
                                    aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage 
                                }
                                else {
                                    check_gui = [1, 4]
                                    get_gui = result.filter(e => check_gui.includes(e.gui));
                                    if (get_gui.length == 2) {
                                        gui = 7
                                        if (alert_rghhg_values.isactive === true) {
                                            alert_message_mode.push({ message: await combine_mes_val_unit(alert_rghhg_values.message, alert_rghhg_values.value, alert_rghhg_values.unit), id: [alert_rghhg_values.id], mode: alert_rghhg_values.mode })
                                        }
                                        aspectcurrent = get_gui[0].current + ';' + get_gui[1].current 
                                        aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage 
                                    }
                                    else {
                                        check_gui = [2, 3]
                                        get_gui = result.filter(e => check_gui.includes(e.gui));
                                        if (get_gui.length == 2) {
                                            gui = 8
                                            if (alert_dghg_values.isactive === true) {
                                                alert_message_mode.push({ message: await combine_mes_val_unit(alert_dghg_values.message, alert_dghg_values.value, alert_dghg_values.unit), id: [alert_dghg_values.id], mode: alert_dghg_values.mode })
                                            }
                                            aspectcurrent = get_gui[0].current + ';' + get_gui[1].current 
                                            aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage 
                                        }
                                        else {
                                            check_gui = [2, 4]
                                            get_gui = result.filter(e => check_gui.includes(e.gui));
                                            if (get_gui.length == 2) {
                                                gui = 9
                                                if (alert_dghhg_values.isactive === true) {
                                                    alert_message_mode.push({ message: await combine_mes_val_unit(alert_dghhg_values.message, alert_dghhg_values.value, alert_dghhg_values.unit), id: [alert_dghhg_values.id], mode: alert_dghhg_values.mode })
                                                }
                                                aspectcurrent = get_gui[0].current + ';' + get_gui[1].current 
                                                aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage 
                                            }
                                            else {
                                                check_gui = [3, 4]
                                                get_gui = result.filter(e => check_gui.includes(e.gui));
                                                if (get_gui.length == 2) {
                                                    gui = 10
                                                    if (alert_hghhg_values.isactive === true) {
                                                        alert_message_mode.push({ message: await combine_mes_val_unit(alert_hghhg_values.message, alert_hghhg_values.value, alert_hghhg_values.unit), id: [alert_hghhg_values.id], mode: alert_hghhg_values.mode })
                                                    }
                                                    aspectcurrent = get_gui[0].current + ';' + get_gui[1].current 
                                                    aspectvoltage = get_gui[0].voltage + ';' + get_gui[1].voltage 
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (error_voltage_data.length > 0) {
                var min_voltage_result = lodash.filter(error_voltage_data, function (o) { return o.min_voltage; });
                if (min_voltage_result.length > 0) {
                    let gui_glow = gui == 1 ? "RG glows and " : gui == 2 ? "DG glows and " : gui == 3 ? "HG glows and " : gui == 4 ? "HHG glows and " : ""
                    if (gui_glow == "") {
                        for (var element of error_voltage_data) {
                            alert_message_mode.push({ message: element.message, id: element.id, mode: element.mode })
                        }
                        if (min_voltage_result.length == 1) {
                            gui = min_voltage_result[0].gui
                            aspectcurrent = min_voltage_result[0].current
                            aspectvoltage = min_voltage_result[0].voltage
                        }
                    }
                    else {
                        for (var element of error_voltage_data) {
                            alert_message_mode.push({ message: gui_glow + element.message, id: element.id, mode: element.mode })
                        }
                    }
                }
            }
            if (error_current_data.length > 0) {
                var min_current_result = lodash.filter(error_current_data, function (o) { return o.min_current; });
                if (min_current_result.length > 0) {
                    let gui_glow = gui == 1 ? "RG glows and " : gui == 2 ? "DG glows and " : gui == 3 ? "HG glows and " : gui == 4 ? "HHG glows and " : ""
                    if (gui_glow == "") {
                        for (var element of error_current_data) {
                            alert_message_mode.push({ message: element.message, id: element.id, mode: element.mode })
                        }
                        if (min_current_result.length == 1) {
                            gui = min_current_result[0].gui
                            aspectcurrent = min_current_result[0].current
                            aspectvoltage = min_current_result[0].voltage
                        }
                    }
                    else {
                        for (var element of error_current_data) {
                            alert_message_mode.push({ message: gui_glow + element.message, id: element.id, mode: element.mode })
                        }
                    }
                }
            }

            if (gui == 0) {
                gui = 12
            }

            let signal_aspect = gui == 1 ? "RG" : gui == 2 ? "DG" : gui == 3 ? "HG" : gui == 4 ? "HHG" : gui == 5 ? "RG DG" : gui == 6 ? "RG HG"
                : gui == 7 ? "RG HHG" : gui == 8 ? "DG HG" : gui == 9 ? "DG HHG" : gui == 10 ? "HG HHG" : gui == 11 ? "ALL" : gui == 12 ? "OFF" : "OFF"

            let insert_dataid = ""

            const data_insert = await SignalCircuitData.create({
                signalcircuitid: parseInt(data.signalcircuitid),
                terminal: data.terminal,
                greenvoltage: data.greenvoltage,
                greencurrent: data.greencurrent,
                redvoltage: data.redvoltage,
                redcurrent: data.redcurrent,
                yellowvoltage: data.yellowvoltage,
                yellowcurrent: data.yellowcurrent,
                lightyellowvoltage: data.lightyellowvoltage,
                lightyellowcurrent: data.lightyellowcurrent,
                whitevoltage: data.whitevoltage,
                whitecurrent: data.whitecurrent,
                signal_aspect: signal_aspect,
                aspect_current: aspectcurrent,
                aspect_voltage: aspectvoltage,
                index_score: index_score,
                gui: gui,
                createddate: data.createddate,
                isdele: false
            },
                { transaction: transaction }
            ).then(res => insert_dataid = res.id)
            //logs.info('signal_insert_dataid', insert_dataid)

            const cycle_index = signalcircuitdatas.findIndex(obj => { return obj.key === data.signalcircuitid.toString(); });
            if (cycle_index !== -1) {
                signalcircuitdatas[cycle_index].data = data_insert[0]
                signalcircuitdatas[cycle_index].id = insert_dataid
            }
            else {
                signalcircuitdatas.push({ key: data.signalcircuitid.toString(), data: data_insert[0], id: insert_dataid });
            }

            let alert_data = {}
            let alert_logs = []
            let alert_modeid = 0

            let mobile_notification_data = []

            var mode_filtered = lodash.groupBy(alert_message_mode, function (o) { return o.mode })

            if (alert_message_mode.length > 0) {
                for (var property in mode_filtered) {
                    let alertid = ""
                    let modeid = lodash.result(lodash.find(AlertModes, { 'mode': property }), 'id')
                    alert_modeid = alert_modeid == null ? modeid : alert_modeid > modeid ? alert_modeid : modeid

                    alert_data = {
                        signalcircuitid: parseInt(data.signalcircuitid),
                        signalcircuitdataid: insert_dataid,
                        stationid: data.stationid,
                        message: mode_filtered[property].map(i => i.message).join(' ; '),
                        assertsid: data.assertid,
                        modeid: modeid,
                        createddate: data.createddate,
                        isdele: false
                    }
                    alert_logs.push(alert_data)

                    const alertinsert = await SignalCircuitAlert.create(alert_data, { transaction: transaction }).then(res => alertid = res.id)
                    //logs.info(`station signalcircuit alert ended`);
                    //console.log(`station signalcircuit alert ended`); 

                    var get_users = await NotificationControl.findAll({ where: { assertsid: data.assertid, stationid: data.stationid, isdele: false } })
                    var get_users_id = lodash.uniq(get_users.map(item => item.userid))

                    let alert_message_ids = lodash.uniq(mode_filtered[property].map(i => i.id)).sort((a, b) => a - b)

                    for (let i = 0; i < get_users_id.length; i++) {

                        const get_previous_notification = await NotificationSend.findOne({
                            where: { stationid: data.stationid, assertsid: data.assertid, alertmessageids: alert_message_ids, modeid: modeid, userid: get_users_id[i], isseen: false, isdele: false },
                            order: [["id", "DESC"]]
                        })

                        if (get_previous_notification == null) {
                            mobile_notification_data.push({
                                stationid: data.stationid,
                                stationcode: data.stationcode,
                                stationname: data.stationname,
                                assertname: data.assertname,
                                assertsid: data.assertid,
                                assertidname: data.signalname,
                                alertid: alertid,
                                userid: get_users_id[i],
                                message: mode_filtered[property].map(i => i.message),
                                modeid: modeid,
                                mode: property,
                                alertmessageids: alert_message_ids,
                                isseen: false,
                                issend: false,
                                createddate: data.createddate,
                            })
                        }
                    }
                }

                if (mobile_notification_data.length > 0) {
                    const notifiyinsert = await NotificationSend.bulkCreate(mobile_notification_data, { transaction: transaction })
                    Socket.emit('Notification', mobile_notification_data);
                    //socketcloud.emit("Notification", mobile_notification_data)
                }
            }

            let data_logs = {
                id: insert_dataid,
                signalcircuitid: parseInt(data.signalcircuitid),
                signalname: data.signalname,
                terminal: data.terminal,
                aspecttypeid: data.aspecttypeid,
                greenvoltage: data.greenvoltage,
                greencurrent: data.greencurrent,
                redvoltage: data.redvoltage,
                redcurrent: data.redcurrent,
                yellowvoltage: data.yellowvoltage,
                yellowcurrent: data.yellowcurrent,
                lightyellowvoltage: data.lightyellowvoltage,
                lightyellowcurrent: data.lightyellowcurrent,
                whitevoltage: data.whitevoltage,
                whitecurrent: data.whitecurrent,
                signal_aspect: signal_aspect,
                aspect_current: aspectcurrent,
                aspect_voltage: aspectvoltage,
                index_score: index_score,
                gui: gui,
                createddate: data.createddate,
                time: moment(data.createddate).format("HH:mm:ss"),
                isdele: false
            }

            // //commented it out because not using now
            // let signals = []
            // signals.push({
            //     id: parseInt(data.signalcircuitid),
            //     signalname: data.signalname,
            //     signal_aspect: signal_aspect,
            //     aspect_current: aspectcurrent,
            //     aspect_voltage: aspectvoltage,
            //     index_score: index_score,
            //     gui: gui,
            //     createddate: data.createddate,
            // })

            // var signalcircuits = await RegisteredSignalCircuit.findAll({ where: { isdele: false, stationid: data.stationid } })
            // for (let i = 0; i < signalcircuits.length; i++) //for await(const element of signalcircuits)
            // {
            //     let element = signalcircuits[i]
            //     var get_finalsignalcircuit_datas = [await SignalCircuitData.findOne({ limit: 1, where: { isdele: false, signalcircuitid: element.id }, order: [["id", "DESC"]] }, { transaction: transaction })];
            //     get_finalsignalcircuit_datas = get_finalsignalcircuit_datas[0] !== null ? get_finalsignalcircuit_datas : []
            //     if (get_finalsignalcircuit_datas.length > 0 && element.id != parseInt(data.signalcircuitid)) {
            //         signals.push({
            //             id: element.id,
            //             signalname: element.signalname,
            //             signal_aspect: get_finalsignalcircuit_datas[0].signal_aspect,
            //             aspect_current: get_finalsignalcircuit_datas[0].aspect_current,
            //             aspect_voltage: get_finalsignalcircuit_datas[0].aspect_voltage,
            //             index_score: get_finalsignalcircuit_datas[0].index_score,
            //             gui: get_finalsignalcircuit_datas[0].gui,
            //             createddate: get_finalsignalcircuit_datas[0].createddate,
            //         })
            //     }
            // }

            let socket_data = {
                data_logs: data_logs,
                // signals: signals,
                alertmodeid: alert_logs.length > 0 ? alert_modeid : null,
                alerts: alert_logs
            }

            await transaction.commit();
            //logs.info('signalcircuitdata',socket_data )
            Socket.emit("signalcircuitdata", socket_data)
            //socketcloud.emit("Signal", socket_data)
        }
        catch (ex) {
            await transaction.rollback();
            logs.error('station signal circuit data error' + ex);
            //console.log('station signal circuit data error' + ex);
        }
    }

    // Active - Track Circuit Feeder
    async function insert_feedertrack_array(data) {
        logs.info(`station track feeder circuit data started`);
        //console.log(`station track feeder circuit data started`);   
        try {
            alert_value_list = require("./alertvalue").getValues();
            let station_id = data.stationid
            let trackcircuitid = data.trackcircuitid
            let assertname = data.assertname
            let data_insert = []

            var relay_data = {}
            var relay_data_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === data.trackcircuitid.toString(); });
            if (relay_data_index !== -1) {
                relay_data = trackcircuitRelaydatas[relay_data_index].data
            }
            else {
                if (trackcircuitWithoutArray === true) {
                    var RelayDatas = [await TrackCircuitData.findOne({
                        limit: 1,
                        order: [["id", "DESC"]],
                        where: { trackcircuitid: data.trackcircuitid },
                        raw: true
                    })];
                    RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                    if (RelayDatas.length > 0) {
                        relay_data = RelayDatas[0]
                        relay_data.count = relay_data.relay_count
                        trackcircuitRelaydatas.push({ key: data.trackcircuitid.toString(), value: RelayDatas[0].relay_count, data: RelayDatas[0] !== null ? RelayDatas[0] : {} });
                    }
                }
                else {
                    var RelayDatas = [await TrackCircuitRelayData.findOne({
                        limit: 1,
                        order: [["id", "DESC"]],
                        where: { trackcircuitid: data.trackcircuitid },
                        raw: true
                    })];
                    RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                    if (RelayDatas.length > 0) {
                        relay_data = RelayDatas[0]
                        trackcircuitRelaydatas.push({ key: data.trackcircuitid.toString(), value: RelayDatas[0].count, data: RelayDatas[0] !== null ? RelayDatas[0] : {} });
                    }
                }
            }

            if (lodash.isEmpty(relay_data)) {
                let rel_cur = 0
                let fed_cur = data.feeder_current
                data_insert.push({
                    trackcircuitid: parseInt(data.trackcircuitid),
                    feed_count: data.count,
                    feed_current: data.feed_current,
                    feed_voltage: data.feed_voltage,
                    choke_voltage: data.choke_voltage,
                    battery_charger_dc_current: data.battery_charger_dc_current,
                    battery_charger_dc_voltage: data.battery_charger_dc_voltage,
                    battery_charger_ac_current: data.battery_charger_ac_current,
                    battery_charger_ac_voltage: data.battery_charger_ac_voltage,
                    relay_count: 0,
                    relay_current: rel_cur,
                    relay_voltage: 0,
                    trv: 0,
                    index_score: 5,
                    leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                    health: 'OK',
                    track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && 0 < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                    createddate: data.createddate,
                    isdele: false
                })
            }
            else {
                let rel_cur = relay_data.relay_current
                let fed_cur = data.feed_current
                data_insert.push({
                    trackcircuitid: parseInt(data.trackcircuitid),
                    feed_count: data.count,
                    feed_current: fed_cur,
                    feed_voltage: data.feed_voltage,
                    choke_voltage: data.choke_voltage,
                    battery_charger_dc_current: data.battery_charger_dc_current,
                    battery_charger_dc_voltage: data.battery_charger_dc_voltage,
                    battery_charger_ac_current: data.battery_charger_ac_current,
                    battery_charger_ac_voltage: data.battery_charger_ac_voltage,
                    relay_count: relay_data.count,
                    relay_current: rel_cur,
                    relay_voltage: relay_data.relay_voltage,
                    trv: relay_data.trv,
                    index_score: 5,
                    leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                    health: 'OK',
                    track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(relay_data.trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                    createddate: data.createddate,
                    isdele: false
                })
            }

            if (data_insert.length == 1) {
                let transaction = await db.transaction({ autocommit: false });
                try {
                    let insert_data = ""
                    const create_data = await TrackCircuitData
                        .create(data_insert[0], { transaction: transaction }).then(res => insert_data = res)
                    //logs.info('track_feeder_insert_dataid', insert_data.id)
                    // await transaction.commit();
                    // insert_feederrelaytrack_array(data, data_insert[0], insert_data.id);
                    var final_result = false
                    const cycle_index = trackcircuitFeederRelaydatas.findIndex(obj => { return obj.key === data.trackcircuitid.toString(); });
                    if (cycle_index !== -1) {
                        if (lodash.isEqual([trackcircuitFeederRelaydatas[cycle_index].data.feed_count, trackcircuitFeederRelaydatas[cycle_index].data.relay_count], [data_insert[0].feed_count, data_insert[0].relay_count]) === false) {
                            final_result = true
                        }
                        trackcircuitFeederRelaydatas[cycle_index].data = data_insert[0]
                        trackcircuitFeederRelaydatas[cycle_index].id = insert_data.id
                    }
                    else {
                        trackcircuitFeederRelaydatas.push({ key: data.trackcircuitid.toString(), data: data_insert[0], id: insert_data.id });
                        final_result = true
                    }
                    if (final_result) {
                        await transaction.commit();
                        insert_feederrelaytrack_array(data, data_insert[0], insert_data.id);
                    }
                    else {
                        await transaction.rollback();
                    }
                }
                catch (ex) {
                    await transaction.rollback();
                    logs.error('station track circuit feeder data error' + ex);
                    //console.log('station track circuit feeder data error' + ex);
                }
            }
        }
        catch (ex) {
            logs.error('station track circuit feeder data error' + ex);
            //console.log('station track circuit feeder data error' + ex);
        }
    }

    // Active - Track Circuit Relay
    async function insert_relaytrack_array(data) {
        logs.info(`station track relay circuit data started`);
        //console.log(`station track relay circuit data started`);   
        try {
            alert_value_list = require("./alertvalue").getValues();
            let station_id = data.stationid
            let trackcircuitid = data.trackcircuitid
            let assertname = data.assertname
            let data_insert = []

            var feeder_data = {}
            var feeder_data_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === data.trackcircuitid.toString(); });
            if (feeder_data_index !== -1) {
                feeder_data = trackcircuitFeederdatas[feeder_data_index].data
            }
            else {
                if (trackcircuitWithoutArray === true) {
                    var FeederDatas = [await TrackCircuitData.findOne({
                        limit: 1,
                        order: [["id", "DESC"]],
                        where: { trackcircuitid: data.trackcircuitid },
                        raw: true
                    })];
                    FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                    if (FeederDatas.length > 0) {
                        feeder_data = FeederDatas[0]
                        feeder_data.count = feeder_data.feed_count
                        trackcircuitFeederdatas.push({ key: data.trackcircuitid.toString(), value: FeederDatas[0].feed_count, data: FeederDatas[0] !== null ? FeederDatas[0] : {} });
                    }
                }
                else {
                    var FeederDatas = [await TrackCircuitFeederData.findOne({
                        limit: 1,
                        order: [["id", "DESC"]],
                        where: { trackcircuitid: data.trackcircuitid },
                        raw: true
                    })];
                    FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                    if (FeederDatas.length > 0) {
                        feeder_data = FeederDatas[0]
                        trackcircuitFeederdatas.push({ key: data.trackcircuitid.toString(), value: FeederDatas[0].count, data: FeederDatas[0] !== null ? FeederDatas[0] : {} });
                    }
                }
            }

            if (lodash.isEmpty(feeder_data)) {
                let rel_cur = data.relay_current
                let fed_cur = 0
                data_insert.push({
                    trackcircuitid: parseInt(data.trackcircuitid),
                    feed_count: 0,
                    feed_current: fed_cur,
                    feed_voltage: 0,
                    choke_voltage: 0,
                    battery_charger_dc_current: 0,
                    battery_charger_dc_voltage: 0,
                    battery_charger_ac_current: 0,
                    battery_charger_ac_voltage: 0,
                    relay_count: data.count,
                    relay_current: rel_cur,
                    relay_voltage: data.relay_voltage,
                    trv: data.trv,
                    index_score: 5,
                    leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                    health: 'OK',
                    track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(data.trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                    createddate: data.createddate,
                    isdele: false
                })
            }
            else {
                let rel_cur = data.relay_current
                let fed_cur = feeder_data.feed_current
                data_insert.push({
                    trackcircuitid: parseInt(data.trackcircuitid),
                    feed_count: feeder_data.count,
                    feed_current: fed_cur,
                    feed_voltage: feeder_data.feed_voltage,
                    choke_voltage: feeder_data.choke_voltage,
                    battery_charger_dc_current: feeder_data.battery_charger_dc_current,
                    battery_charger_dc_voltage: feeder_data.battery_charger_dc_voltage,
                    battery_charger_ac_current: feeder_data.battery_charger_ac_current,
                    battery_charger_ac_voltage: feeder_data.battery_charger_ac_voltage,
                    relay_count: data.count,
                    relay_current: rel_cur,
                    relay_voltage: data.relay_voltage,
                    trv: data.trv,
                    index_score: 5,
                    leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                    health: 'OK',
                    track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(data.trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                    createddate: data.createddate,
                    isdele: false
                })
            }
            if (data_insert.length == 1) {
                let transaction = await db.transaction({ autocommit: false });
                try {
                    let insert_data = ""
                    const create_data = await TrackCircuitData
                        .create(data_insert[0], { transaction: transaction }).then(res => insert_data = res)
                    //logs.info('track_relay_insert_dataid', insert_data.id)
                    // await transaction.commit();
                    // insert_feederrelaytrack_array(data, data_insert[0], insert_data.id);
                    var final_result = false
                    const cycle_index = trackcircuitFeederRelaydatas.findIndex(obj => { return obj.key === data.trackcircuitid.toString(); });
                    if (cycle_index !== -1) {
                        if (lodash.isEqual([trackcircuitFeederRelaydatas[cycle_index].data.feed_count, trackcircuitFeederRelaydatas[cycle_index].data.relay_count], [data_insert[0].feed_count, data_insert[0].relay_count]) === false) {
                            final_result = true
                        }
                        trackcircuitFeederRelaydatas[cycle_index].data = data_insert[0]
                        trackcircuitFeederRelaydatas[cycle_index].id = insert_data.id
                    }
                    else {
                        trackcircuitFeederRelaydatas.push({ key: data.trackcircuitid.toString(), data: data_insert[0], id: insert_data.id });
                        final_result = true
                    }
                    if (final_result) {
                        await transaction.commit();
                        insert_feederrelaytrack_array(data, data_insert[0], insert_data.id);
                    }
                    else {
                        await transaction.rollback();
                    }
                }
                catch (ex) {
                    await transaction.rollback();
                    logs.error('station track circuit relay data error' + ex);
                    //console.log('station track circuit relay data error' + ex);
                }

            }
        }
        catch (ex) {
            logs.error('station track circuit relay data error' + ex);
            //console.log('station track circuit relay data error' + ex);
        }
    }

    // Active - Track Circuit Data
    async function insert_feederrelaytrack_array(datas, data_insert, dataid) {
        logs.info('insert feederrelay track alert started');
        //console.log('insert feederrelay track alert started');
        let transaction = await db.transaction({ autocommit: false });
        try {
            alert_value_list = require("./alertvalue").getValues();
            let station_id = datas.stationid
            let trackcircuitid = datas.trackcircuitid
            let assertname = datas.assertname

            let data = {
                stationid: datas.stationid,
                stationcode: datas.stationcode,
                stationname: datas.stationname,
                assertid: datas.assertid,
                assertname: datas.assertname,
                trackcircuitid: datas.trackcircuitid,
                trackcircuitterminal: datas.trackcircuitterminal,
                trackname: datas.trackname,
                feed_count: data_insert.feed_count,
                feed_voltage: data_insert.feed_voltage,
                feed_current: data_insert.feed_current,
                choke_voltage: data_insert.choke_voltage,
                battery_charger_dc_current: data_insert.battery_charger_dc_current,
                battery_charger_dc_voltage: data_insert.battery_charger_dc_voltage,
                battery_charger_ac_voltage: data_insert.battery_charger_ac_voltage,
                battery_charger_ac_current: data_insert.battery_charger_ac_current,
                relay_count: data_insert.relay_count,
                relay_voltage: data_insert.relay_voltage,
                relay_current: data_insert.relay_current,
                trv: data_insert.trv,
                index_score: data_insert.index_score,
                leakage_current: data_insert.leakage_current,
                health: data_insert.health,
                track_OC: data_insert.track_OC,
                createddate: data_insert.createddate
            }

            let track_check = [];

            //track_check//
            var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_FEED_CURRENT`)
            data.feed_current < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.feed_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_FEED_CURRENT`)
            data.feed_current > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.feed_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT`)
            data.relay_current < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.relay_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_RELAY_CURRENT`)
            data.relay_current > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.relay_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_FEED_VOLTAGE`)
            data.feed_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.feed_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_FEED_VOLTAGE`)
            data.feed_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.feed_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_VOLTAGE`)
            data.relay_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.relay_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_RELAY_VOLTAGE`)
            data.relay_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.relay_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_CHOKE_VOLTAGE`)
            data.choke_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.choke_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_CHOKE_VOLTAGE`)
            data.choke_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.choke_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_BATTERY_CHARGER_DC_VOLTAGE`)
            data.battery_charger_dc_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_dc_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_BATTERY_CHARGER_DC_VOLTAGE`)
            data.battery_charger_dc_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_dc_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_BATTERY_CHARGER_DC_CURRENT`)
            data.battery_charger_dc_current < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_dc_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_BATTERY_CHARGER_DC_CURRENT`)
            data.battery_charger_dc_current > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_dc_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_BATTERY_CHARGER_AC_VOLTAGE`)
            data.battery_charger_ac_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_ac_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_BATTERY_CHARGER_AC_VOLTAGE`)
            data.battery_charger_ac_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_ac_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_BATTERY_CHARGER_AC_CURRENT`)
            data.battery_charger_ac_current < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_ac_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_BATTERY_CHARGER_AC_CURRENT`)
            data.battery_charger_ac_current > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_ac_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE`)
            data.trv < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.trv, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_TRACK_RELAY_VOLTAGE`)
            data.trv > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.trv, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@CRITICAL_RELAY_VOLTAGE`)
            data.relay_voltage < parseFloat(alert_name_values.value) && data.feed_current > parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@CRITICAL_FEED_CURRENT`) && alert_name_values.isactive) === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.relay_voltage, alert_name_values.unit) + " and " + await get_alert_message(`${station_id}@${trackcircuitid}@${assertname}@CRITICAL_FEED_CURRENT`, data.feed_current), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            var result = lodash.filter(track_check, function (o) { return o.result; });
            var mode_filtered = lodash.groupBy(track_check, function (o) { return o.mode })

            let alert_data = {}
            let alert_logs = []
            let alert_modeid = 0

            let mobile_notification_data = []

            if (result.length > 0) {
                for (var property in mode_filtered) {
                    let alertid = ""
                    let modeid = lodash.result(lodash.find(AlertModes, { 'mode': property }), 'id')
                    alert_modeid = alert_modeid == null ? modeid : alert_modeid > modeid ? alert_modeid : modeid

                    alert_data = {
                        trackcircuitid: parseInt(data.trackcircuitid),
                        trackcircuitdataid: dataid,
                        stationid: data.stationid,
                        message: mode_filtered[property].map(item => item.message).join(' ; '),
                        assertsid: data.assertid,
                        modeid: modeid,
                        mode: property,
                        createddate: data.createddate,
                        isdele: false
                    }
                    alert_logs.push(alert_data)

                    const alertinsert = await TrackCircuitAlert.create(alert_data, { transaction: transaction }).then(res => alertid = res.id)
                    //logs.info(`station trackcircuit alert ended`);
                    //console.log(`station trackcircuit alert ended`); 

                    var get_users = await NotificationControl.findAll({ where: { assertsid: data.assertid, stationid: data.stationid, isdele: false } })
                    var get_users_id = lodash.uniq(get_users.map(item => item.userid))

                    let alert_message_ids = lodash.uniq(mode_filtered[property].map(i => i.id)).sort((a, b) => a - b)

                    for (let i = 0; i < get_users_id.length; i++) {

                        const get_previous_notification = await NotificationSend.findOne({
                            where: { stationid: data.stationid, assertsid: data.assertid, alertmessageids: alert_message_ids, modeid: modeid, userid: get_users_id[i], isseen: false, isdele: false },
                            order: [["id", "DESC"]]
                        })

                        if (get_previous_notification == null) {
                            mobile_notification_data.push({
                                stationid: data.stationid,
                                stationcode: data.stationcode,
                                stationname: data.stationname,
                                assertname: data.assertname,
                                assertsid: data.assertid,
                                assertidname: data.trackname,
                                alertid: alertid,
                                userid: get_users_id[i],
                                message: alert_data.message,
                                modeid: modeid,
                                mode: property,
                                alertmessageids: alert_message_ids,
                                isseen: false,
                                issend: false,
                                createddate: data.createddate,
                            })
                        }
                    }

                }
                if (mobile_notification_data.length > 0) {
                    const notifiyinsert = await NotificationSend.bulkCreate(mobile_notification_data, { transaction: transaction })
                    Socket.emit('Notification', mobile_notification_data);
                    //socketcloud.emit("Notification", mobile_notification_data)
                }
            }

            let data_logs = {
                id: dataid,
                trackcircuitid: parseInt(data.trackcircuitid),
                trackname: data.trackname,
                feed_count: data.feed_count,
                feed_current: data.feed_current,
                feed_voltage: data.feed_voltage,
                choke_voltage: data.choke_voltage,
                battery_charger_dc_current: data.battery_charger_dc_current,
                battery_charger_dc_voltage: data.battery_charger_dc_voltage,
                battery_charger_ac_current: data.battery_charger_ac_current,
                battery_charger_ac_voltage: data.battery_charger_ac_voltage,
                relay_count: data.relay_count,
                relay_current: data.relay_current,
                relay_voltage: data.relay_voltage,
                trv: data.trv,
                index_score: data.index_score,
                leakage_current: data.leakage_current,
                health: data.health,
                track_OC: data.track_OC,
                createddate: data.createddate,
                time: moment(data.createddate).format("HH:mm:ss"),
                isdele: false
            }


            // //commented it out because not using now
            // let tracks = []
            // tracks.push({
            //     id: parseInt(data.trackcircuitid),
            //     trackname: data.trackname,
            //     feed_count: data.feed_count,
            //     feed_current: data.feed_current,
            //     feed_voltage: data.feed_voltage,
            //     choke_voltage: data.choke_voltage,
            //     relay_count: data.relay_count,
            //     battery_charger_dc_current: data.battery_charger_dc_current,
            //     battery_charger_dc_voltage: data.battery_charger_dc_voltage,
            //     battery_charger_ac_current: data.battery_charger_ac_current,
            //     battery_charger_ac_voltage: data.battery_charger_ac_voltage,
            //     relay_current: data.relay_current,
            //     relay_voltage: data.relay_voltage,
            //     trv: data.trv,
            //     index_score: data.index_score,
            //     leakage_current: data.leakage_current,
            //     health: data.health,
            //     track_OC: data.track_OC,
            //     createddate: data.createddate,
            // })

            // var trackcircuits = await RegisteredTrackCircuit.findAll({ where: { isdele: false, stationid: data.stationid } })
            // for (let i = 0; i < trackcircuits.length; i++) {
            //     let element = trackcircuits[i]
            //     var get_finaltrackcircuit_datas = [await TrackCircuitData.findOne({ limit: 1, where: { isdele: false, trackcircuitid: element.id }, order: [["id", "DESC"]] })];
            //     get_finaltrackcircuit_datas = get_finaltrackcircuit_datas[0] !== null ? get_finaltrackcircuit_datas : []
            //     if (get_finaltrackcircuit_datas.length > 0 && element.id != parseInt(data.trackcircuitid)) {
            //         tracks.push({
            //             id: element.id,
            //             trackname: element.trackname,
            //             feed_count: get_finaltrackcircuit_datas[0].feed_count,
            //             feed_current: get_finaltrackcircuit_datas[0].feed_current,
            //             feed_voltage: get_finaltrackcircuit_datas[0].feed_voltage,
            //             choke_voltage: get_finaltrackcircuit_datas[0].choke_voltage,
            //             relay_count: get_finaltrackcircuit_datas[0].relay_count,
            //             battery_charger_dc_current: get_finaltrackcircuit_datas[0].battery_charger_dc_current,
            //             battery_charger_dc_voltage: get_finaltrackcircuit_datas[0].battery_charger_dc_voltage,
            //             battery_charger_ac_current: get_finaltrackcircuit_datas[0].battery_charger_ac_current,
            //             battery_charger_ac_voltage: get_finaltrackcircuit_datas[0].battery_charger_ac_voltage,
            //             relay_current: get_finaltrackcircuit_datas[0].relay_current,
            //             relay_voltage: get_finaltrackcircuit_datas[0].relay_voltage,
            //             trv: get_finaltrackcircuit_datas[0].trv,
            //             index_score: get_finaltrackcircuit_datas[0].index_score,
            //             leakage_current: get_finaltrackcircuit_datas[0].leakage_current,
            //             health: get_finaltrackcircuit_datas[0].health,
            //             track_OC: get_finaltrackcircuit_datas[0].track_OC,
            //             createddate: get_finaltrackcircuit_datas[0].createddate,
            //         })
            //     }
            // }

            let socket_data = {
                data_logs: data_logs,
                // tracks: tracks,
                alertmodeid: alert_logs.length > 0 ? alert_modeid : null,
                alerts: alert_logs
            }
            await transaction.commit();
            //logs.info('track_socket_data',socket_data) 
            Socket.emit("trackcircuitdata", socket_data)
            //socketcloud.emit("Track", socket_data)
        } catch (ex) {
            await transaction.rollback();
            logs.error('station feederrelay track data error' + ex);
            //console.log('station feederrelay track data error' + ex);
        }
    }

    // Active - Track Circuit Feeder & Relay
    async function insert_feederrelaytrack_both(feeder_data, relay_data) {
        logs.info('station feederrelay both track data started');
        try {
            var data = feeder_data != "" ? feeder_data : relay_data
            alert_value_list = require("./alertvalue").getValues();
            let station_id = data.stationid
            let trackcircuitid = data.trackcircuitid
            let assertname = data.assertname
            let data_insert = []

            if (feeder_data && relay_data != "") {
                let rel_cur = relay_data.relay_current
                let fed_cur = feeder_data.feed_current
                data_insert.push({
                    trackcircuitid: parseInt(feeder_data.trackcircuitid),
                    feed_count: feeder_data.count,
                    feed_current: fed_cur,
                    feed_voltage: feeder_data.feed_voltage,
                    choke_voltage: feeder_data.choke_voltage,
                    battery_charger_dc_current: feeder_data.battery_charger_dc_current,
                    battery_charger_dc_voltage: feeder_data.battery_charger_dc_voltage,
                    battery_charger_ac_current: feeder_data.battery_charger_ac_current,
                    battery_charger_ac_voltage: feeder_data.battery_charger_ac_voltage,
                    relay_count: relay_data.count,
                    relay_current: rel_cur,
                    relay_voltage: relay_data.relay_voltage,
                    trv: relay_data.trv,
                    index_score: 5,
                    leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                    health: 'OK',
                    track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(relay_data.trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                    createddate: feeder_data.createddate,
                    isdele: false
                })
            }
            else {
                if (lodash.isEmpty(relay_data)) {
                    var relay_data_index = trackcircuitRelaydatas.findIndex(obj => { return obj.key === data.trackcircuitid.toString(); });
                    if (relay_data_index !== -1) {
                        relay_data = trackcircuitRelaydatas[relay_data_index].data
                    }
                    else {
                        if (trackcircuitWithoutArray === true) {
                            var RelayDatas = [await TrackCircuitData.findOne({
                                limit: 1,
                                order: [["id", "DESC"]],
                                where: { trackcircuitid: data.trackcircuitid },
                                raw: true
                            })];
                            RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                            if (RelayDatas.length > 0) {
                                relay_data = RelayDatas[0]
                                relay_data.count = relay_data.relay_count
                                trackcircuitRelaydatas.push({ key: data.trackcircuitid.toString(), value: RelayDatas[0].relay_count, data: RelayDatas[0] !== null ? RelayDatas[0] : {} });
                            }
                        }
                        else {
                            var RelayDatas = [await TrackCircuitRelayData.findOne({
                                limit: 1,
                                order: [["id", "DESC"]],
                                where: { trackcircuitid: data.trackcircuitid },
                                raw: true
                            })];
                            RelayDatas = RelayDatas[0] !== null ? RelayDatas : []
                            if (RelayDatas.length > 0) {
                                relay_data = RelayDatas[0]
                                trackcircuitRelaydatas.push({ key: data.trackcircuitid.toString(), value: RelayDatas[0].count, data: RelayDatas[0] !== null ? RelayDatas[0] : {} });
                            }
                        }
                    }
                    if (lodash.isEmpty(relay_data)) {
                        let rel_cur = 0
                        let fed_cur = data.feeder_current
                        data_insert.push({
                            trackcircuitid: parseInt(data.trackcircuitid),
                            feed_count: data.count,
                            feed_current: data.feed_current,
                            feed_voltage: data.feed_voltage,
                            choke_voltage: data.choke_voltage,
                            battery_charger_dc_current: data.battery_charger_dc_current,
                            battery_charger_dc_voltage: data.battery_charger_dc_voltage,
                            battery_charger_ac_current: data.battery_charger_ac_current,
                            battery_charger_ac_voltage: data.battery_charger_ac_voltage,
                            relay_count: 0,
                            relay_current: rel_cur,
                            relay_voltage: 0,
                            trv: 0,
                            index_score: 5,
                            leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                            health: 'OK',
                            track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && 0 < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                            createddate: data.createddate,
                            isdele: false
                        })
                    }
                    else {
                        let rel_cur = relay_data.relay_current
                        let fed_cur = data.feed_current
                        data_insert.push({
                            trackcircuitid: parseInt(data.trackcircuitid),
                            feed_count: data.count,
                            feed_current: fed_cur,
                            feed_voltage: data.feed_voltage,
                            choke_voltage: data.choke_voltage,
                            battery_charger_dc_current: data.battery_charger_dc_current,
                            battery_charger_dc_voltage: data.battery_charger_dc_voltage,
                            battery_charger_ac_current: data.battery_charger_ac_current,
                            battery_charger_ac_voltage: data.battery_charger_ac_voltage,
                            relay_count: relay_data.count,
                            relay_current: rel_cur,
                            relay_voltage: relay_data.relay_voltage,
                            trv: relay_data.trv,
                            index_score: 5,
                            leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                            health: 'OK',
                            track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(relay_data.trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                            createddate: data.createddate,
                            isdele: false
                        })
                    }
                }
                else {
                    var feeder_data_index = trackcircuitFeederdatas.findIndex(obj => { return obj.key === data.trackcircuitid.toString(); });
                    if (feeder_data_index !== -1) {
                        feeder_data = trackcircuitFeederdatas[feeder_data_index].data
                    }
                    else {
                        if (trackcircuitWithoutArray === true) {
                            var FeederDatas = [await TrackCircuitData.findOne({
                                limit: 1,
                                order: [["id", "DESC"]],
                                where: { trackcircuitid: data.trackcircuitid },
                                raw: true
                            })];
                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                            if (FeederDatas.length > 0) {
                                feeder_data = FeederDatas[0]
                                feeder_data.count = feeder_data.feed_count
                                trackcircuitFeederdatas.push({ key: data.trackcircuitid.toString(), value: FeederDatas[0].feed_count, data: FeederDatas[0] !== null ? FeederDatas[0] : {} });
                            }
                        }
                        else {
                            var FeederDatas = [await TrackCircuitFeederData.findOne({
                                limit: 1,
                                order: [["id", "DESC"]],
                                where: { trackcircuitid: data.trackcircuitid },
                                raw: true
                            })];
                            FeederDatas = FeederDatas[0] !== null ? FeederDatas : []
                            if (FeederDatas.length > 0) {
                                feeder_data = FeederDatas[0]
                                trackcircuitFeederdatas.push({ key: data.trackcircuitid.toString(), value: FeederDatas[0].count, data: FeederDatas[0] !== null ? FeederDatas[0] : {} });
                            }
                        }
                    }
                    if (lodash.isEmpty(feeder_data)) {
                        let rel_cur = data.relay_current
                        let fed_cur = 0
                        data_insert.push({
                            trackcircuitid: parseInt(data.trackcircuitid),
                            feed_count: 0,
                            feed_current: fed_cur,
                            feed_voltage: 0,
                            choke_voltage: 0,
                            battery_charger_dc_current: 0,
                            battery_charger_dc_voltage: 0,
                            battery_charger_ac_current: 0,
                            battery_charger_ac_voltage: 0,
                            relay_count: data.count,
                            relay_current: rel_cur,
                            relay_voltage: data.relay_voltage,
                            trv: data.trv,
                            index_score: 5,
                            leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                            health: 'OK',
                            track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(data.trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                            createddate: data.createddate,
                            isdele: false
                        })
                    }
                    else {
                        let rel_cur = data.relay_current
                        let fed_cur = feeder_data.feed_current
                        data_insert.push({
                            trackcircuitid: parseInt(data.trackcircuitid),
                            feed_count: feeder_data.count,
                            feed_current: fed_cur,
                            feed_voltage: feeder_data.feed_voltage,
                            choke_voltage: feeder_data.choke_voltage,
                            battery_charger_dc_current: feeder_data.battery_charger_dc_current,
                            battery_charger_dc_voltage: feeder_data.battery_charger_dc_voltage,
                            battery_charger_ac_current: feeder_data.battery_charger_ac_current,
                            battery_charger_ac_voltage: feeder_data.battery_charger_ac_voltage,
                            relay_count: data.count,
                            relay_current: rel_cur,
                            relay_voltage: data.relay_voltage,
                            trv: data.trv,
                            index_score: 5,
                            leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                            health: 'OK',
                            track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(data.trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                            createddate: data.createddate,
                            isdele: false
                        })
                    }
                }
            }

            if (data_insert.length == 1) {
                let transaction = await db.transaction({ autocommit: false });
                try {
                    let insert_data = ""
                    const create_data = await TrackCircuitData
                        .create(data_insert[0], { transaction: transaction }).then(res => insert_data = res)
                    //logs.info('track_feeder_insert_dataid', insert_data.id)
                    // await transaction.commit();
                    // insert_feederrelaytrack_array(data, data_insert[0], insert_data.id);
                    var final_result = false
                    const cycle_index = trackcircuitFeederRelaydatas.findIndex(obj => { return obj.key === data.trackcircuitid.toString(); });
                    if (cycle_index !== -1) {
                        if (lodash.isEqual([trackcircuitFeederRelaydatas[cycle_index].data.feed_count, trackcircuitFeederRelaydatas[cycle_index].data.relay_count], [data_insert[0].feed_count, data_insert[0].relay_count]) === false) {
                            final_result = true
                        }
                        trackcircuitFeederRelaydatas[cycle_index].data = data_insert[0]
                        trackcircuitFeederRelaydatas[cycle_index].id = insert_data.id
                    }
                    else {
                        trackcircuitFeederRelaydatas.push({ key: data.trackcircuitid.toString(), data: data_insert[0], id: insert_data.id });
                        final_result = true
                    }
                    if (final_result) {
                        await transaction.commit();
                        insert_feederrelaytrack_array(data, data_insert[0], insert_data.id);
                    }
                    else {
                        await transaction.rollback();
                    }
                }
                catch (ex) {
                    await transaction.rollback();
                    logs.error('station feederrelay both track data error' + ex);
                    //console.log('station feederrelay both track data error' + ex);
                }
            }
        }
        catch (ex) {
            logs.error('station feederrelay both track data error' + ex);
            //console.log('station feederrelay both track data error' + ex);
        }
    }

    // Active - Axle Counter
    async function insert_axlecounter(data) {
        logs.info(`station axle counter data started`);
        //console.log(`station axle counter data started`);   
        let transaction = await db.transaction({ autocommit: false });
        try {
            alert_value_list = require("./alertvalue").getValues();
            let station_id = data.stationid
            let axlecounterid = data.axlecounterid
            let assertname = data.assertname
            let data_insert = []

            let insert_dataid = ""
            data_insert = await AxleCounterData.create(data, { transaction: transaction }).then(res => insert_dataid = res.id)

            const cycle_index = axlecounterdatas.findIndex(obj => { return obj.key === data.axlecounterid.toString(); });
            if (cycle_index !== -1) {
                axlecounterdatas[cycle_index].data = data_insert[0]
                axlecounterdatas[cycle_index].id = insert_dataid
            }
            else {
                axlecounterdatas.push({ key: data.axlecounterid.toString(), data: data_insert[0], id: insert_dataid });
            }

            let alert_data = {}
            let alert_logs = []
            let alert_modeid = 0

            let data_logs = {
                id: insert_dataid,
                axlecounterid: parseInt(data.axlecounterid),
                axlecountername: data.axlecountername,
                dc_converter_voltage_1: data.dc_converter_voltage_1,
                dc_converter_voltage_2: data.dc_converter_voltage_2,
                preparatory_relay_voltage_1: data.preparatory_relay_voltage_1,
                preparatory_relay_voltage_2: data.preparatory_relay_voltage_2,
                vital_relay_voltage_1: data.vital_relay_voltage_1,
                vital_relay_voltage_2: data.vital_relay_voltage_2,
                reset_relay_voltage: data.reset_relay_voltage,
                createddate: data.createddate,
                time: moment(data.createddate).format("HH:mm:ss"),
                isdele: false
            }

            let socket_data = {
                data_logs: data_logs,
                alertmodeid: alert_logs.length > 0 ? alert_modeid : null,
                alerts: alert_logs
            }

            await transaction.commit();
            logs.info("Axle Counter Data inserted");
            //logs.info('axlecounterdata',socket_data )
            Socket.emit("axlecounterdata", socket_data)
            //socketcloud.emit("Axle", socket_data)
        }
        catch (ex) {
            await transaction.rollback();
            logs.error('station axle counter data error' + ex);
            //console.log('station axle counter data error' + ex);
        }
    }

    // Active - LC Gate Counter
    async function insert_lcgate(data) {
        logs.info(`station lc gate data started`);
        //console.log(`station lc gate  data started`);   
        let transaction = await db.transaction({ autocommit: false });
        try {
            alert_value_list = require("./alertvalue").getValues();
            let station_id = data.stationid
            let lcgateid = data.lcgateid
            let assertname = data.assertname
            let data_insert = []

            let insert_dataid = ""
            data_insert = await LCGateData.create(data, { transaction: transaction }).then(res => insert_dataid = res.id)

            const cycle_index = lcgatedatas.findIndex(obj => { return obj.key === data.lcgateid.toString(); });
            if (cycle_index !== -1) {
                lcgatedatas[cycle_index].data = data_insert[0]
                lcgatedatas[cycle_index].id = insert_dataid
            }
            else {
                lcgatedatas.push({ key: data.lcgateid.toString(), data: data_insert[0], id: insert_dataid });
            }

            let alert_data = {}
            let alert_logs = []
            let alert_modeid = 0

            let data_logs = {
                id: insert_dataid,
                lcgateid: parseInt(data.lcgateid),
                lcgatename: data.lcgatename,
                announciator_relay_voltage: data.announciator_relay_voltage,
                proving_relay_voltage: data.proving_relay_voltage,
                createddate: data.createddate,
                time: moment(data.createddate).format("HH:mm:ss"),
                isdele: false
            }

            let socket_data = {
                data_logs: data_logs,
                alertmodeid: alert_logs.length > 0 ? alert_modeid : null,
                alerts: alert_logs
            }

            await transaction.commit();
            logs.info("LC Gate Data inserted");
            //logs.info('lcgatedata',socket_data )
            Socket.emit("lcgatedata", socket_data)
            //socketcloud.emit("LCGates", socket_data)
        }
        catch (ex) {
            await transaction.rollback();
            logs.error('station lc gate data error' + ex);
            //console.log('station lc gate data error' + ex);
        }
    }



    // Inactive - Track Circuit Feeder Loop
    async function insert_feedertrack(data) {
        logs.info(`station track feeder circuit data started`);
        //console.log(`station track feeder circuit data started`);   
        try {
            alert_value_list = require("./alertvalue").getValues();
            let station_id = data.stationid
            let trackcircuitid = data.trackcircuitid
            let assertname = data.assertname
            let data_insert = []
            var get_finaltrackcircuit_datas = [await TrackCircuitData.findOne({ limit: 1, where: { isdele: false, trackcircuitid: parseInt(data.trackcircuitid) }, order: [["id", "DESC"]] })];
            get_finaltrackcircuit_datas = get_finaltrackcircuit_datas[0] !== null ? get_finaltrackcircuit_datas : []
            const get_feederdata = await TrackCircuitFeederData.findAll({ where: { isdele: false, trackcircuitid: parseInt(data.trackcircuitid) } });
            const get_relaydata = await TrackCircuitRelayData.findAll({ where: { isdele: false, trackcircuitid: parseInt(data.trackcircuitid) } });

            if (get_finaltrackcircuit_datas.length > 0) {
                let finalfeeder = get_finaltrackcircuit_datas[0].feed_count === 0 ? 1 : get_finaltrackcircuit_datas[0].feed_count;
                let finalrelay = get_finaltrackcircuit_datas[0].relay_count === 0 ? 1 : get_finaltrackcircuit_datas[0].relay_count;

                var feederdata = [];
                var Feedercount = [];
                var relaydata = [];
                var Relaycount = [];

                if (get_relaydata.length > 0) {
                    relaydata = lodash.filter(get_relaydata, ({ count }) => count > finalrelay)
                    Relaycount = relaydata.map(a => a.count)
                }

                if (get_feederdata.length > 0) {
                    feederdata = lodash.filter(get_feederdata, ({ count }) => count > finalfeeder)
                    Feedercount = feederdata.map(a => a.count)

                    if (get_feederdata.length === 1 && Relaycount.length === 0 && Feedercount.length === 0) {
                        let rel_cur = get_relaydata[get_relaydata.length - 1].relay_current
                        let fed_cur = get_relaydata[get_relaydata.length - 1].feed_current
                        data_insert.push({
                            trackcircuitid: parseInt(data.trackcircuitid),
                            feed_count: get_feederdata[get_feederdata.length - 1].count,
                            feed_current: fed_cur,
                            feed_voltage: get_relaydata[get_relaydata.length - 1].feed_voltage,
                            choke_voltage: get_feederdata[get_feederdata.length - 1].choke_voltage,
                            battery_charger_dc_current: get_feederdata[get_feederdata.length - 1].battery_charger_dc_current,
                            battery_charger_dc_voltage: get_feederdata[get_feederdata.length - 1].battery_charger_dc_voltage,
                            battery_charger_ac_current: get_feederdata[get_feederdata.length - 1].battery_charger_ac_current,
                            battery_charger_ac_voltage: get_feederdata[get_feederdata.length - 1].battery_charger_ac_voltage,
                            relay_count: get_relaydata[get_relaydata.length - 1].count,
                            relay_current: rel_cur,
                            relay_voltage: get_relaydata[get_relaydata.length - 1].relay_voltage,
                            trv: get_relaydata[get_relaydata.length - 1].trv,
                            index_score: 5,
                            leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                            health: 'OK',
                            track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(get_relaydata[get_relaydata.length - 1].trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                            createddate: get_feederdata[get_feederdata.length - 1].createddate,
                            isdele: false
                        })
                    }
                }

                if (Feedercount.length >= Relaycount.length) {
                    let count = finalrelay
                    for await (const Felement of feederdata) {
                        let rel_cur = get_relaydata.length > count ? get_relaydata[count].relay_current : get_relaydata.length === 0 ? 0 : get_relaydata[get_relaydata.length - 1].relay_current
                        let fed_cur = get_relaydata.length > count ? get_relaydata[count].feed_current : get_relaydata.length === 0 ? 0 : get_relaydata[get_relaydata.length - 1].feed_current
                        data_insert.push({
                            trackcircuitid: parseInt(data.trackcircuitid),
                            feed_count: Felement.count,
                            feed_current: fed_cur,
                            feed_voltage: get_relaydata.length > count ? get_relaydata[count].feed_voltage : get_relaydata.length === 0 ? 0 : get_relaydata[get_relaydata.length - 1].feed_voltage,
                            choke_voltage: Felement.choke_voltage,
                            battery_charger_dc_current: get_feederdata[get_feederdata.length - 1].battery_charger_dc_current,
                            battery_charger_dc_voltage: get_feederdata[get_feederdata.length - 1].battery_charger_dc_voltage,
                            battery_charger_ac_current: get_feederdata[get_feederdata.length - 1].battery_charger_ac_current,
                            battery_charger_ac_voltage: get_feederdata[get_feederdata.length - 1].battery_charger_ac_voltage,
                            relay_count: get_relaydata.length > count ? get_relaydata[count].count : get_relaydata.length === 0 ? 0 : get_relaydata[get_relaydata.length - 1].count,
                            relay_current: rel_cur,
                            relay_voltage: get_relaydata.length > count ? get_relaydata[count].relay_voltage : get_relaydata.length === 0 ? 0 : get_relaydata[get_relaydata.length - 1].relay_voltage,
                            trv: get_relaydata.length > count ? get_relaydata[count].trv : get_relaydata.length === 0 ? 0 : get_relaydata[get_relaydata.length - 1].trv,
                            index_score: 5,
                            leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                            health: 'OK',
                            track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(get_relaydata.length > count ? get_relaydata[count].trv : get_relaydata.length === 0 ? 0 : get_relaydata[get_relaydata.length - 1].trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                            createddate: Felement.createddate,
                            isdele: false
                        })
                        count++
                    }
                }
                else {
                    let count = finalfeeder
                    for await (const Relement of relaydata) {
                        let rel_cur = Relement.relay_current
                        let fed_cur = Relement.feed_current
                        data_insert.push({
                            trackcircuitid: parseInt(data.trackcircuitid),
                            feed_count: get_feederdata.length > count ? get_feederdata[count].count : get_feederdata.length === 0 ? 0 : get_feederdata[get_feederdata.length - 1].count,
                            feed_current: fed_cur,
                            feed_voltage: Relement.feed_voltage,
                            choke_voltage: get_feederdata.length > count ? get_feederdata[count].choke_voltage : get_feederdata.length === 0 ? 0 : get_feederdata[get_feederdata.length - 1].choke_voltage,
                            battery_charger_dc_current: get_feederdata.length > count ? get_feederdata[count].battery_charger_dc_current : get_feederdata.length === 0 ? 0 : get_feederdata[get_feederdata.length - 1].battery_charger_dc_current,
                            battery_charger_dc_voltage: get_feederdata.length > count ? get_feederdata[count].battery_charger_dc_voltage : get_feederdata.length === 0 ? 0 : get_feederdata[get_feederdata.length - 1].battery_charger_dc_voltage,
                            battery_charger_ac_current: get_feederdata.length > count ? get_feederdata[count].battery_charger_ac_current : get_feederdata.length === 0 ? 0 : get_feederdata[get_feederdata.length - 1].battery_charger_ac_current,
                            battery_charger_ac_voltage: get_feederdata.length > count ? get_feederdata[count].battery_charger_ac_voltage : get_feederdata.length === 0 ? 0 : get_feederdata[get_feederdata.length - 1].battery_charger_ac_voltage,
                            relay_count: Relement.count,
                            relay_current: rel_cur,
                            relay_voltage: Relement.relay_voltage,
                            trv: Relement.trv,
                            index_score: 5,
                            leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                            health: 'OK',
                            track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(Relement.trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                            createddate: Relement.createddate,
                            isdele: false
                        })
                        count++
                    }
                }

            }
            else {
                if (get_feederdata.length >= get_relaydata.length) {
                    let count = 1
                    for await (const Felement of get_feederdata) {
                        if (count == 1) {
                            let rel_cur = 0
                            let fed_cur = 0
                            if (get_relaydata.length == 0) {
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: Felement.count,
                                    feed_current: fed_cur,
                                    feed_voltage: 0,
                                    choke_voltage: Felement.choke_voltage,
                                    battery_charger_dc_current: Felement.battery_charger_dc_current,
                                    battery_charger_dc_voltage: Felement.battery_charger_dc_voltage,
                                    battery_charger_ac_current: Felement.battery_charger_ac_current,
                                    battery_charger_ac_voltage: Felement.battery_charger_ac_voltage,
                                    relay_count: 0,
                                    relay_current: rel_cur,
                                    relay_voltage: 0,
                                    trv: 0,
                                    index_score: 5,
                                    leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                                    health: 'OK',
                                    track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && 0 < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                                    createddate: Felement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                let rel_cur = get_relaydata.length > count ? get_relaydata[count - 1].relay_current : get_relaydata[get_relaydata.length - 1].relay_current
                                let fed_cur = get_relaydata.length > count ? get_relaydata[count - 1].feed_current : get_relaydata[get_relaydata.length - 1].feed_current

                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: Felement.count,
                                    feed_current: fed_cur,
                                    feed_voltage: get_relaydata.length > count ? get_relaydata[count - 1].feed_voltage : get_relaydata[get_relaydata.length - 1].feed_voltage,
                                    choke_voltage: Felement.choke_voltage,
                                    battery_charger_dc_current: Felement.battery_charger_dc_current,
                                    battery_charger_dc_voltage: Felement.battery_charger_dc_voltage,
                                    battery_charger_ac_current: Felement.battery_charger_ac_current,
                                    battery_charger_ac_voltage: Felement.battery_charger_ac_voltage,
                                    relay_count: get_relaydata.length > count ? get_relaydata[count - 1].count : get_relaydata[get_relaydata.length - 1].count,
                                    relay_current: rel_cur,
                                    relay_voltage: get_relaydata.length > count ? get_relaydata[count - 1].relay_voltage : get_relaydata[get_relaydata.length - 1].relay_voltage,
                                    trv: get_relaydata.length > count ? get_relaydata[count - 1].trv : get_relaydata[get_relaydata.length - 1].trv,
                                    index_score: 5,
                                    leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                                    health: 'OK',
                                    track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(get_relaydata.length > count ? get_relaydata[count - 1].trv : get_relaydata[get_relaydata.length - 1].trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                                    createddate: Felement.createddate,
                                    isdele: false
                                })
                            }
                        }
                        else {
                            if (get_relaydata.length == 0) {
                                let rel_cur = 0
                                let fed_cur = 0
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: Felement.count,
                                    feed_current: fed_cur,
                                    feed_voltage: 0,
                                    choke_voltage: Felement.choke_voltage,
                                    battery_charger_dc_current: Felement.battery_charger_dc_current,
                                    battery_charger_dc_voltage: Felement.battery_charger_dc_voltage,
                                    battery_charger_ac_current: Felement.battery_charger_ac_current,
                                    battery_charger_ac_voltage: Felement.battery_charger_ac_voltage,
                                    relay_count: 0,
                                    relay_current: rel_cur,
                                    relay_voltage: 0,
                                    trv: 0,
                                    index_score: 5,
                                    leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                                    health: 'OK',
                                    track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && 0 < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                                    createddate: Felement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                let rel_cur = get_relaydata.length > count ? get_relaydata[count - 1].relay_current : get_relaydata[get_relaydata.length - 1].relay_current
                                let fed_cur = get_relaydata.length > count ? get_relaydata[count - 1].feed_current : get_relaydata[get_relaydata.length - 1].feed_current
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: Felement.count,
                                    feed_current: fed_cur,
                                    feed_voltage: get_relaydata.length > count ? get_relaydata[count - 1].feed_voltage : get_relaydata[get_relaydata.length - 1].feed_voltage,
                                    choke_voltage: Felement.choke_voltage,
                                    battery_charger_dc_current: Felement.battery_charger_dc_current,
                                    battery_charger_dc_voltage: Felement.battery_charger_dc_voltage,
                                    battery_charger_ac_current: Felement.battery_charger_ac_current,
                                    battery_charger_ac_voltage: Felement.battery_charger_ac_voltage,
                                    relay_count: get_relaydata.length > count ? get_relaydata[count - 1].count : get_relaydata[get_relaydata.length - 1].count,
                                    relay_current: rel_cur,
                                    relay_voltage: get_relaydata.length > count ? get_relaydata[count - 1].relay_voltage : get_relaydata[get_relaydata.length - 1].relay_voltage,
                                    trv: get_relaydata.length > count ? get_relaydata[count - 1].trv : get_relaydata[get_relaydata.length - 1].trv,
                                    index_score: 5,
                                    leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                                    health: 'OK',
                                    track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(get_relaydata.length > count ? get_relaydata[count - 1].trv : get_relaydata[get_relaydata.length - 1].trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                                    createddate: Felement.createddate,
                                    isdele: false
                                })
                            }
                        }
                        count++;
                    }
                }
                else {
                    let count = 1
                    for await (const Relement of get_relaydata) {
                        if (count == 1) {
                            if (get_feederdata.length == 0) {
                                let rel_cur = Relement.relay_current
                                let fed_cur = Relement.feed_current
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: 0,
                                    feed_current: fed_cur,
                                    feed_voltage: Relement.feed_voltage,
                                    choke_voltage: 0,
                                    battery_charger_dc_current: 0,
                                    battery_charger_dc_voltage: 0,
                                    battery_charger_ac_current: 0,
                                    battery_charger_ac_voltage: 0,
                                    relay_count: Relement.count,
                                    relay_current: rel_cur,
                                    relay_voltage: Relement.relay_voltage,
                                    trv: Relement.trv,
                                    index_score: 5,
                                    leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                                    health: 'OK',
                                    track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(Relement.trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                                    createddate: Relement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                let rel_cur = Relement.relay_current
                                let fed_cur = Relement.feed_current
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: get_feederdata.length > count ? get_feederdata[count - 1].count : get_feederdata[get_feederdata.length - 1].count,
                                    feed_current: fed_cur,
                                    feed_voltage: Relement.feed_voltage,
                                    choke_voltage: get_feederdata.length > count ? get_feederdata[count - 1].choke_voltage : get_feederdata[get_feederdata.length - 1].choke_voltage,
                                    battery_charger_dc_current: get_feederdata.length > count ? get_feederdata[count - 1].battery_charger_dc_current : get_feederdata[get_feederdata.length - 1].battery_charger_dc_current,
                                    battery_charger_dc_voltage: get_feederdata.length > count ? get_feederdata[count - 1].battery_charger_dc_voltage : get_feederdata[get_feederdata.length - 1].battery_charger_dc_voltage,
                                    battery_charger_ac_current: get_feederdata.length > count ? get_feederdata[count - 1].battery_charger_ac_current : get_feederdata[get_feederdata.length - 1].battery_charger_ac_current,
                                    battery_charger_ac_voltage: get_feederdata.length > count ? get_feederdata[count - 1].battery_charger_ac_voltage : get_feederdata[get_feederdata.length - 1].battery_charger_ac_voltage,
                                    relay_count: Relement.count,
                                    relay_current: fed_crel_curur,
                                    relay_voltage: Relement.relay_voltage,
                                    trv: Relement.trv,
                                    index_score: 5,
                                    leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                                    health: 'OK',
                                    track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(Relement.trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                                    createddate: Relement.createddate,
                                    isdele: false
                                })
                            }
                        }
                        else {
                            if (get_feederdata.length == 0) {
                                let rel_cur = Relement.relay_current
                                let fed_cur = Relement.feed_current
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: 0,
                                    feed_current: fed_cur,
                                    feed_voltage: Relement.feed_voltage,
                                    choke_voltage: 0,
                                    battery_charger_dc_current: 0,
                                    battery_charger_dc_voltage: 0,
                                    battery_charger_ac_current: 0,
                                    battery_charger_ac_voltage: 0,
                                    relay_count: Relement.count,
                                    relay_current: rel_cur,
                                    relay_voltage: Relement.relay_voltage,
                                    trv: Relement.trv,
                                    index_score: 5,
                                    leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                                    health: 'OK',
                                    track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(Relement.trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                                    createddate: Relement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                let rel_cur = Relement.relay_current
                                let fed_cur = Relement.feed_current
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: get_feederdata.length > count ? get_feederdata[count - 1].count : get_feederdata[get_feederdata.length - 1].count,
                                    feed_current: fed_cur,
                                    feed_voltage: Relement.feed_voltage,
                                    choke_voltage: get_feederdata.length > count ? get_feederdata[count - 1].choke_voltage : get_feederdata[get_feederdata.length - 1].choke_voltage,
                                    battery_charger_dc_current: get_feederdata.length > count ? get_feederdata[count - 1].battery_charger_dc_current : get_feederdata[get_feederdata.length - 1].battery_charger_dc_current,
                                    battery_charger_dc_voltage: get_feederdata.length > count ? get_feederdata[count - 1].battery_charger_dc_voltage : get_feederdata[get_feederdata.length - 1].battery_charger_dc_voltage,
                                    battery_charger_ac_current: get_feederdata.length > count ? get_feederdata[count - 1].battery_charger_ac_current : get_feederdata[get_feederdata.length - 1].battery_charger_ac_current,
                                    battery_charger_ac_voltage: get_feederdata.length > count ? get_feederdata[count - 1].battery_charger_ac_voltage : get_feederdata[get_feederdata.length - 1].battery_charger_ac_voltage,
                                    relay_count: Relement.count,
                                    relay_current: Relement.relay_current,
                                    relay_voltage: Relement.relay_voltage,
                                    trv: Relement.trv,
                                    index_score: 5,
                                    leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                                    health: 'OK',
                                    track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(Relement.trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                                    createddate: Relement.createddate,
                                    isdele: false
                                })
                            }
                        }
                        count++;
                    }
                }
            }

            if (data_insert.length == 1) {
                logs.info('feeder_data_insert_feedcount', data_insert.map(a => a.feed_count))
                logs.info('feeder_data_insert_relaycount', data_insert.map(a => a.relay_count))

                // let final_result = false
                // const cycle_index = trackfeederrelaycount.findIndex(obj => { return obj.key === data.trackcircuitid; });                        
                // if(cycle_index !== -1)
                // {                
                //     var TrackDatas = [await TrackCircuitData.findOne({
                //         limit : 1,
                //         order: [["id", "DESC"]],
                //         where : { trackcircuitid : data.trackcircuitid}
                //     })];
                //     TrackDatas = TrackDatas[0] !== null ? TrackDatas : []  
                //     let data_insert_count = []
                //     if(TrackDatas.length > 0)
                //     {                    
                //         let track_data_count = []

                //         track_data_count.push(TrackDatas[0].feed_count)
                //         track_data_count.push(TrackDatas[0].relay_count)  

                //         data_insert_count.push(data_insert[0].feed_count)
                //         data_insert_count.push(data_insert[0].relay_count)  

                //         if(lodash.isEqual(track_data_count,data_insert_count) == false)
                //         {
                //             final_result = false
                //             trackfeederrelaycount[cycle_index].value = data_insert_count
                //         }    
                //     }                                
                // }
                // else
                // {
                //     var TrackDatas = [await TrackCircuitData.findOne({
                //         limit : 1,
                //         order: [["id", "DESC"]],
                //         where : { trackcircuitid : data.trackcircuitid}
                //     })];
                //     TrackDatas = TrackDatas[0] !== null ? TrackDatas : []  
                //     let data_insert_count = []
                //     if(TrackDatas.length > 0)
                //     {                    
                //         let track_data_count = []

                //         track_data_count.push(TrackDatas[0].feed_count)
                //         track_data_count.push(TrackDatas[0].relay_count)  

                //         data_insert_count.push(data_insert[0].feed_count)
                //         data_insert_count.push(data_insert[0].relay_count)  

                //         if(lodash.isEqual(track_data_count,data_insert_count) == false)
                //         {
                //             final_result = false
                //         }    
                //     } 
                //     else {
                //         final_result = false
                //         data_insert_count.push(data_insert[0].feed_count)
                //         data_insert_count.push(data_insert[0].relay_count)  
                //     }
                //     trackfeederrelaycount.push({  key: data.trackcircuitid, value: data_insert_count });
                // }

                //if(final_result == false)
                //{
                let transaction = await db.transaction({ autocommit: false });
                try {
                    let insert_dataid = ""
                    const create_data = await TrackCircuitData
                        .create(data_insert[0], { transaction: transaction }).then(res => insert_dataid = res.id)
                    //logs.info('track_feeder_insert_dataid', insert_dataid)
                    await transaction.commit();
                    await insert_feederrelaytrack(data, data_insert[0], insert_dataid);
                }
                catch (ex) {
                    await transaction.rollback();
                    logs.error('station track circuit feeder data error' + ex);
                    //console.log('station track circuit feeder data error' + ex);
                }
                //}

            }
            else if (data_insert.length > 1) {
                logs.info('feeder_data_insert_count', data_insert.map(a => a.feed_count))
                logs.info('relay_data_insert_count', data_insert.map(a => a.relay_count))

                let transaction = await db.transaction({ autocommit: false });
                try {
                    let insert_dataid = []
                    const create_data = await TrackCircuitData
                        .bulkCreate(data_insert, { transaction: transaction }).then(res => insert_dataid = res)
                    await transaction.commit();
                    for await (const insert_element of insert_dataid) {
                        //logs.info('track_feeder_insert_dataid', insert_element.dataValues.id)
                        await insert_feederrelaytrack(data, insert_element.dataValues, insert_element.dataValues.id);
                    }
                }
                catch (ex) {
                    await transaction.rollback();
                    logs.error('station track circuit feeder data error' + ex);
                    //console.log('station track circuit feeder data error' + ex);
                }
            }
        }
        catch (ex) {
            logs.error('station track circuit feeder data error' + ex);
            //console.log('station track circuit feeder data error' + ex);
        }
    }

    // Inactive - Track Circuit Relay Loop
    async function insert_relaytrack(data) {
        logs.info(`station track relay circuit data started`);
        //console.log(`station track relay circuit data started`);   
        try {
            alert_value_list = require("./alertvalue").getValues();
            let station_id = data.stationid
            let trackcircuitid = data.trackcircuitid
            let assertname = data.assertname
            let data_insert = []
            var get_finaltrackcircuit_datas = [await TrackCircuitData.findOne({ limit: 1, where: { isdele: false, trackcircuitid: parseInt(data.trackcircuitid) }, order: [["id", "DESC"]] })];
            get_finaltrackcircuit_datas = get_finaltrackcircuit_datas[0] !== null ? get_finaltrackcircuit_datas : []
            const get_feederdata = await TrackCircuitFeederData.findAll({ where: { isdele: false, trackcircuitid: parseInt(data.trackcircuitid) } });
            const get_relaydata = await TrackCircuitRelayData.findAll({ where: { isdele: false, trackcircuitid: parseInt(data.trackcircuitid) } });

            if (get_finaltrackcircuit_datas.length > 0) {
                let finalfeeder = get_finaltrackcircuit_datas[0].feed_count === 0 ? 1 : get_finaltrackcircuit_datas[0].feed_count;
                let finalrelay = get_finaltrackcircuit_datas[0].relay_count === 0 ? 1 : get_finaltrackcircuit_datas[0].relay_count;

                var feederdata = [];
                var Feedercount = [];
                var relaydata = [];
                var Relaycount = [];

                if (get_feederdata.length > 0) {
                    feederdata = lodash.filter(get_feederdata, ({ count }) => count > finalfeeder)
                    Feedercount = feederdata.map(a => a.count)
                }

                if (get_relaydata.length > 0) {
                    relaydata = lodash.filter(get_relaydata, ({ count }) => count > finalrelay)
                    Relaycount = relaydata.map(a => a.count)
                    if (get_relaydata.length === 1 && Relaycount.length === 0 && Feedercount.length === 0) {
                        let rel_cur = get_relaydata[get_relaydata.length - 1].relay_current
                        let fed_cur = get_relaydata[get_relaydata.length - 1].feed_current
                        data_insert.push({
                            trackcircuitid: parseInt(data.trackcircuitid),
                            feed_count: get_feederdata[get_feederdata.length - 1].count,
                            feed_current: fed_cur,
                            feed_voltage: get_relaydata[get_relaydata.length - 1].feed_voltage,
                            choke_voltage: get_feederdata[get_feederdata.length - 1].choke_voltage,
                            battery_charger_dc_current: get_feederdata[get_feederdata.length - 1].battery_charger_dc_current,
                            battery_charger_dc_voltage: get_feederdata[get_feederdata.length - 1].battery_charger_dc_voltage,
                            battery_charger_ac_current: get_feederdata[get_feederdata.length - 1].battery_charger_ac_current,
                            battery_charger_ac_voltage: get_feederdata[get_feederdata.length - 1].battery_charger_ac_voltage,
                            relay_count: get_relaydata[get_relaydata.length - 1].count,
                            relay_current: rel_cur,
                            relay_voltage: get_relaydata[get_relaydata.length - 1].relay_voltage,
                            trv: get_relaydata[get_relaydata.length - 1].trv,
                            index_score: 5,
                            leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                            health: 'OK',
                            track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(get_relaydata[get_relaydata.length - 1].trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                            createddate: get_feederdata[get_feederdata.length - 1].createddate,
                            isdele: false
                        })
                    }
                }

                if (Feedercount.length >= Relaycount.length) {
                    let count = finalrelay
                    for await (const Felement of feederdata) {
                        let rel_cur = get_relaydata.length > count ? get_relaydata[count].relay_current : get_relaydata.length === 0 ? 0 : get_relaydata[get_relaydata.length - 1].relay_current
                        let fed_cur = get_relaydata.length > count ? get_relaydata[count].feed_current : get_relaydata.length === 0 ? 0 : get_relaydata[get_relaydata.length - 1].feed_current
                        data_insert.push({
                            trackcircuitid: parseInt(data.trackcircuitid),
                            feed_count: Felement.count,
                            feed_current: fed_cur,
                            feed_voltage: get_relaydata.length > count ? get_relaydata[count].feed_voltage : get_relaydata.length === 0 ? 0 : get_relaydata[get_relaydata.length - 1].feed_voltage,
                            choke_voltage: Felement.choke_voltage,
                            battery_charger_dc_current: get_feederdata[get_feederdata.length - 1].battery_charger_dc_current,
                            battery_charger_dc_voltage: get_feederdata[get_feederdata.length - 1].battery_charger_dc_voltage,
                            battery_charger_ac_current: get_feederdata[get_feederdata.length - 1].battery_charger_ac_current,
                            battery_charger_ac_voltage: get_feederdata[get_feederdata.length - 1].battery_charger_ac_voltage,
                            relay_count: get_relaydata.length > count ? get_relaydata[count].count : get_relaydata.length === 0 ? 0 : get_relaydata[get_relaydata.length - 1].count,
                            relay_current: rel_cur,
                            relay_voltage: get_relaydata.length > count ? get_relaydata[count].relay_voltage : get_relaydata.length === 0 ? 0 : get_relaydata[get_relaydata.length - 1].relay_voltage,
                            trv: get_relaydata.length > count ? get_relaydata[count].trv : get_relaydata.length === 0 ? 0 : get_relaydata[get_relaydata.length - 1].trv,
                            index_score: 5,
                            leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                            health: 'OK',
                            track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(get_relaydata.length > count ? get_relaydata[count].trv : get_relaydata.length === 0 ? 0 : get_relaydata[get_relaydata.length - 1].trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                            createddate: Felement.createddate,
                            isdele: false
                        })
                        count++
                    }
                }
                else {
                    let count = finalfeeder
                    for await (const Relement of relaydata) {
                        let rel_cur = Relement.relay_current
                        let fed_cur = Relement.feed_current
                        data_insert.push({
                            trackcircuitid: parseInt(data.trackcircuitid),
                            feed_count: get_feederdata.length > count ? get_feederdata[count].count : get_feederdata.length === 0 ? 0 : get_feederdata[get_feederdata.length - 1].count,
                            feed_current: fed_cur,
                            feed_voltage: Relement.feed_voltage,
                            choke_voltage: get_feederdata.length > count ? get_feederdata[count].choke_voltage : get_feederdata.length === 0 ? 0 : get_feederdata[get_feederdata.length - 1].choke_voltage,
                            battery_charger_dc_current: get_feederdata.length > count ? get_feederdata[count].battery_charger_dc_current : get_feederdata.length === 0 ? 0 : get_feederdata[get_feederdata.length - 1].battery_charger_dc_current,
                            battery_charger_dc_voltage: get_feederdata.length > count ? get_feederdata[count].battery_charger_dc_voltage : get_feederdata.length === 0 ? 0 : get_feederdata[get_feederdata.length - 1].battery_charger_dc_voltage,
                            battery_charger_ac_current: get_feederdata.length > count ? get_feederdata[count].battery_charger_ac_current : get_feederdata.length === 0 ? 0 : get_feederdata[get_feederdata.length - 1].battery_charger_ac_current,
                            battery_charger_ac_voltage: get_feederdata.length > count ? get_feederdata[count].battery_charger_ac_voltage : get_feederdata.length === 0 ? 0 : get_feederdata[get_feederdata.length - 1].battery_charger_ac_voltage,
                            relay_count: Relement.count,
                            relay_current: rel_cur,
                            relay_voltage: Relement.relay_voltage,
                            trv: Relement.trv,
                            index_score: 5,
                            leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                            health: 'OK',
                            track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(Relement.trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                            createddate: Relement.createddate,
                            isdele: false
                        })
                        count++
                    }
                }

            }
            else {
                if (get_feederdata.length >= get_relaydata.length) {
                    let count = 1
                    for await (const Felement of get_feederdata) {

                        if (count == 1) {
                            let rel_cur = 0
                            let fed_cur = 0
                            if (get_relaydata.length == 0) {
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: Felement.count,
                                    feed_current: fed_cur,
                                    feed_voltage: 0,
                                    choke_voltage: Felement.choke_voltage,
                                    battery_charger_dc_current: Felement.battery_charger_dc_current,
                                    battery_charger_dc_voltage: Felement.battery_charger_dc_voltage,
                                    battery_charger_ac_current: Felement.battery_charger_ac_current,
                                    battery_charger_ac_voltage: Felement.battery_charger_ac_voltage,
                                    relay_count: 0,
                                    relay_current: rel_cur,
                                    relay_voltage: 0,
                                    trv: 0,
                                    index_score: 5,
                                    leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                                    health: 'OK',
                                    track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && 0 < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                                    createddate: Felement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                let rel_cur = get_relaydata.length > count ? get_relaydata[count - 1].relay_current : get_relaydata[get_relaydata.length - 1].relay_current
                                let fed_cur = get_relaydata.length > count ? get_relaydata[count - 1].feed_current : get_relaydata[get_relaydata.length - 1].feed_current
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: Felement.count,
                                    feed_current: fed_cur,
                                    feed_voltage: get_relaydata.length > count ? get_relaydata[count - 1].feed_voltage : get_relaydata[get_relaydata.length - 1].feed_voltage,
                                    choke_voltage: Felement.choke_voltage,
                                    battery_charger_dc_current: Felement.battery_charger_dc_current,
                                    battery_charger_dc_voltage: Felement.battery_charger_dc_voltage,
                                    battery_charger_ac_current: Felement.battery_charger_ac_current,
                                    battery_charger_ac_voltage: Felement.battery_charger_ac_voltage,
                                    relay_count: get_relaydata.length > count ? get_relaydata[count - 1].count : get_relaydata[get_relaydata.length - 1].count,
                                    relay_current: rel_cur,
                                    relay_voltage: get_relaydata.length > count ? get_relaydata[count - 1].relay_voltage : get_relaydata[get_relaydata.length - 1].relay_voltage,
                                    trv: get_relaydata.length > count ? get_relaydata[count - 1].trv : get_relaydata[get_relaydata.length - 1].trv,
                                    index_score: 5,
                                    leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                                    health: 'OK',
                                    track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(get_relaydata.length > count ? get_relaydata[count - 1].trv : get_relaydata[get_relaydata.length - 1].trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                                    createddate: Felement.createddate,
                                    isdele: false
                                })
                            }
                        }
                        else {
                            if (get_relaydata.length == 0) {
                                let rel_cur = 0
                                let fed_cur = 0
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: Felement.count,
                                    feed_current: fed_cur,
                                    feed_voltage: 0,
                                    choke_voltage: Felement.choke_voltage,
                                    battery_charger_dc_current: Felement.battery_charger_dc_current,
                                    battery_charger_dc_voltage: Felement.battery_charger_dc_voltage,
                                    battery_charger_ac_current: Felement.battery_charger_ac_current,
                                    battery_charger_ac_voltage: Felement.battery_charger_ac_voltage,
                                    relay_count: 0,
                                    relay_current: rel_cur,
                                    relay_voltage: 0,
                                    trv: 0,
                                    index_score: 5,
                                    leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                                    health: 'OK',
                                    track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && 0 < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                                    createddate: Felement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                let rel_cur = get_relaydata.length > count ? get_relaydata[count - 1].relay_current : get_relaydata[get_relaydata.length - 1].relay_current
                                let fed_cur = get_relaydata.length > count ? get_relaydata[count - 1].feed_current : get_relaydata[get_relaydata.length - 1].feed_current
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: Felement.count,
                                    feed_current: fed_cur,
                                    feed_voltage: get_relaydata.length > count ? get_relaydata[count - 1].feed_voltage : get_relaydata[get_relaydata.length - 1].feed_voltage,
                                    choke_voltage: Felement.choke_voltage,
                                    battery_charger_dc_current: Felement.battery_charger_dc_current,
                                    battery_charger_dc_voltage: Felement.battery_charger_dc_voltage,
                                    battery_charger_ac_current: Felement.battery_charger_ac_current,
                                    battery_charger_ac_voltage: Felement.battery_charger_ac_voltage,
                                    relay_count: get_relaydata.length > count ? get_relaydata[count - 1].count : get_relaydata[get_relaydata.length - 1].count,
                                    relay_current: rel_cur,
                                    relay_voltage: get_relaydata.length > count ? get_relaydata[count - 1].relay_voltage : get_relaydata[get_relaydata.length - 1].relay_voltage,
                                    trv: get_relaydata.length > count ? get_relaydata[count - 1].trv : get_relaydata[get_relaydata.length - 1].trv,
                                    index_score: 5,
                                    leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                                    health: 'OK',
                                    track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(get_relaydata.length > count ? get_relaydata[count - 1].trv : get_relaydata[get_relaydata.length - 1].trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                                    createddate: Felement.createddate,
                                    isdele: false
                                })
                            }
                        }
                        count++;
                    }
                }
                else {
                    let count = 1
                    for await (const Relement of get_relaydata) {
                        if (count == 1) {
                            if (get_feederdata.length == 0) {
                                let rel_cur = Relement.relay_current
                                let fed_cur = Relement.feed_current
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: 0,
                                    feed_current: fed_cur,
                                    feed_voltage: Relement.feed_voltage,
                                    choke_voltage: 0,
                                    battery_charger_dc_current: 0,
                                    battery_charger_dc_voltage: 0,
                                    battery_charger_ac_current: 0,
                                    battery_charger_ac_voltage: 0,
                                    relay_count: Relement.count,
                                    relay_current: rel_cur,
                                    relay_voltage: Relement.relay_voltage,
                                    trv: Relement.trv,
                                    index_score: 5,
                                    leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                                    health: 'OK',
                                    track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(Relement.trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                                    createddate: Relement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                let rel_cur = Relement.relay_current
                                let fed_cur = Relement.feed_current
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: get_feederdata.length > count ? get_feederdata[count - 1].count : get_feederdata[get_feederdata.length - 1].count,
                                    feed_current: fed_cur,
                                    feed_voltage: Relement.feed_voltage,
                                    choke_voltage: get_feederdata.length > count ? get_feederdata[count - 1].choke_voltage : get_feederdata[get_feederdata.length - 1].choke_voltage,
                                    battery_charger_dc_current: get_feederdata.length > count ? get_feederdata[count - 1].battery_charger_dc_current : get_feederdata[get_feederdata.length - 1].battery_charger_dc_current,
                                    battery_charger_dc_voltage: get_feederdata.length > count ? get_feederdata[count - 1].battery_charger_dc_voltage : get_feederdata[get_feederdata.length - 1].battery_charger_dc_voltage,
                                    battery_charger_ac_current: get_feederdata.length > count ? get_feederdata[count - 1].battery_charger_ac_current : get_feederdata[get_feederdata.length - 1].battery_charger_ac_current,
                                    battery_charger_ac_voltage: get_feederdata.length > count ? get_feederdata[count - 1].battery_charger_ac_voltage : get_feederdata[get_feederdata.length - 1].battery_charger_ac_voltage,
                                    relay_count: Relement.count,
                                    relay_current: rel_cur,
                                    relay_voltage: Relement.relay_voltage,
                                    trv: Relement.trv,
                                    index_score: 5,
                                    leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                                    health: 'OK',
                                    track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(Relement.trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                                    createddate: Relement.createddate,
                                    isdele: false
                                })
                            }
                        }
                        else {
                            if (get_feederdata.length == 0) {
                                let rel_cur = Relement.relay_current
                                let fed_cur = Relement.feed_current
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: 0,
                                    feed_current: fed_cur,
                                    feed_voltage: Relement.feed_voltage,
                                    choke_voltage: 0,
                                    battery_charger_dc_current: 0,
                                    battery_charger_dc_voltage: 0,
                                    battery_charger_ac_current: 0,
                                    battery_charger_ac_voltage: 0,
                                    relay_count: Relement.count,
                                    relay_current: rel_cur,
                                    relay_voltage: Relement.relay_voltage,
                                    trv: Relement.trv,
                                    index_score: 5,
                                    leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                                    health: 'OK',
                                    track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(Relement.trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                                    createddate: Relement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                let rel_cur = Relement.relay_current
                                let fed_cur = Relement.feed_current
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: get_feederdata.length > count ? get_feederdata[count - 1].count : get_feederdata[get_feederdata.length - 1].count,
                                    feed_current: fed_cur,
                                    feed_voltage: Relement.feed_voltage,
                                    choke_voltage: get_feederdata.length > count ? get_feederdata[count - 1].choke_voltage : get_feederdata[get_feederdata.length - 1].choke_voltage,
                                    battery_charger_dc_current: get_feederdata.length > count ? get_feederdata[count - 1].battery_charger_dc_current : get_feederdata[get_feederdata.length - 1].battery_charger_dc_current,
                                    battery_charger_dc_voltage: get_feederdata.length > count ? get_feederdata[count - 1].battery_charger_dc_voltage : get_feederdata[get_feederdata.length - 1].battery_charger_dc_voltage,
                                    battery_charger_ac_current: get_feederdata.length > count ? get_feederdata[count - 1].battery_charger_ac_current : get_feederdata[get_feederdata.length - 1].battery_charger_ac_current,
                                    battery_charger_ac_voltage: get_feederdata.length > count ? get_feederdata[count - 1].battery_charger_ac_voltage : get_feederdata[get_feederdata.length - 1].battery_charger_ac_voltage,
                                    relay_count: Relement.count,
                                    relay_current: Relement.relay_current,
                                    relay_voltage: Relement.relay_voltage,
                                    trv: Relement.trv,
                                    index_score: 5,
                                    leakage_current: (Math.abs(parseFloat(fed_cur) - parseFloat(rel_cur)) * 1000).toFixed(parseFloat(process.env.CURRENT_DECIMAL_POINT)),
                                    health: 'OK',
                                    track_OC: parseFloat(rel_cur) <= parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT_TRACK_OC`)) && parseFloat(Relement.trv) < parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE_TRACK_OC`)) ? 'O' : 'C',
                                    createddate: Relement.createddate,
                                    isdele: false
                                })
                            }
                        }
                        count++;
                    }
                }
            }

            if (data_insert.length == 1) {
                logs.info('relay_data_insert_feedcount', data_insert.map(a => a.feed_count))
                logs.info('relay_data_insert_relaycount', data_insert.map(a => a.relay_count))

                //let final_result = false
                // const cycle_index = trackfeederrelaycount.findIndex(obj => { return obj.key === data.trackcircuitid; });    
                // if(cycle_index !== -1)
                // {                
                //     var TrackDatas = [await TrackCircuitData.findOne({
                //         limit : 1,
                //         order: [["id", "DESC"]],
                //         where : { trackcircuitid : data.trackcircuitid}
                //     })];
                //     TrackDatas = TrackDatas[0] !== null ? TrackDatas : []
                //     let data_insert_count = []
                //     if(TrackDatas.length > 0)
                //     {                    
                //         let track_data_count = []

                //         track_data_count.push(TrackDatas[0].feed_count)
                //         track_data_count.push(TrackDatas[0].relay_count)  

                //         data_insert_count.push(data_insert[0].feed_count)
                //         data_insert_count.push(data_insert[0].relay_count)  

                //         if(lodash.isEqual(track_data_count,data_insert_count) == false)
                //         {
                //             final_result = false
                //             trackfeederrelaycount[cycle_index].value = data_insert_count
                //         }    
                //     }                            
                // }
                // else
                // {
                //     var TrackDatas = [await TrackCircuitData.findOne({
                //         limit : 1,
                //         order: [["id", "DESC"]],
                //         where : { trackcircuitid : data.trackcircuitid}
                //     })];
                //     TrackDatas = TrackDatas[0] !== null ? TrackDatas : []
                //     let data_insert_count = []
                //     if(TrackDatas.length > 0)
                //     {                    
                //         let track_data_count = []

                //         track_data_count.push(TrackDatas[0].feed_count)
                //         track_data_count.push(TrackDatas[0].relay_count)  

                //         data_insert_count.push(data_insert[0].feed_count)
                //         data_insert_count.push(data_insert[0].relay_count)  

                //         if(lodash.isEqual(track_data_count,data_insert_count) == false)
                //         {
                //             final_result = false
                //         }    
                //     } 
                //     else {
                //         final_result = false
                //         data_insert_count.push(data_insert[0].feed_count)
                //         data_insert_count.push(data_insert[0].relay_count)  
                //     }
                //     trackfeederrelaycount.push({  key: data.trackcircuitid, value: data_insert_count });
                // }

                //if(final_result == false)
                //{
                let transaction = await db.transaction({ autocommit: false });
                try {
                    let insert_dataid = ""
                    const create_data = await TrackCircuitData
                        .create(data_insert[0], { transaction: transaction }).then(res => insert_dataid = res.id)
                    //logs.info('track_relay_insert_dataid', insert_dataid)
                    await transaction.commit();
                    await insert_feederrelaytrack(data, data_insert[0], insert_dataid);
                }
                catch (ex) {
                    await transaction.rollback();
                    logs.error('station track circuit relay data error' + ex);
                    //console.log('station track circuit relay data error' + ex);
                }
                //}            
            }
            else if (data_insert.length > 1) {
                logs.info('feeder_data_insert_count', data_insert.map(a => a.feed_count))
                logs.info('relay_data_insert_count', data_insert.map(a => a.relay_count))

                let transaction = await db.transaction({ autocommit: false });
                try {
                    let insert_dataid = []
                    const create_data = await TrackCircuitData
                        .bulkCreate(data_insert, { transaction: transaction }).then(res => insert_dataid = res)
                    await transaction.commit();
                    for await (const insert_element of insert_dataid) {
                        //logs.info('track_relay_insert_dataid', insert_element.dataValues.id)
                        await insert_feederrelaytrack(data, insert_element.dataValues, insert_element.dataValues.id);
                    }
                }
                catch (ex) {
                    await transaction.rollback();
                    logs.error('station track circuit relay data error' + ex);
                    //console.log('station track circuit relay data error' + ex);
                }
            }
        }
        catch (ex) {
            logs.error('station track circuit relay data error' + ex);
            //console.log('station track circuit relay data error' + ex);
        }
    }

    // Inactive - Track Circuit Data
    async function insert_feederrelaytrack(datas, data_insert, dataid) {
        logs.info('insert feederrelay track alert started');
        //console.log('insert feederrelay track alert started');
        let transaction = await db.transaction({ autocommit: false });
        try {
            alert_value_list = require("./alertvalue").getValues();
            let station_id = datas.stationid
            let trackcircuitid = datas.trackcircuitid
            let assertname = datas.assertname

            let data = {
                stationid: datas.stationid,
                stationcode: datas.stationcode,
                stationname: datas.stationname,
                assertid: datas.assertid,
                assertname: datas.assertname,
                trackcircuitid: datas.trackcircuitid,
                trackcircuitterminal: datas.trackcircuitterminal,
                trackname: datas.trackname,
                feed_count: data_insert.feed_count,
                feed_voltage: data_insert.feed_voltage,
                feed_current: data_insert.feed_current,
                choke_voltage: data_insert.choke_voltage,
                battery_charger_dc_current: data_insert.battery_charger_dc_current,
                battery_charger_dc_voltage: data_insert.battery_charger_dc_voltage,
                battery_charger_ac_voltage: data_insert.battery_charger_ac_voltage,
                battery_charger_ac_current: data_insert.battery_charger_ac_current,
                relay_count: data_insert.relay_count,
                relay_voltage: data_insert.relay_voltage,
                relay_current: data_insert.relay_current,
                trv: data_insert.trv,
                index_score: data_insert.index_score,
                leakage_current: data_insert.leakage_current,
                health: data_insert.health,
                track_OC: data_insert.track_OC,
                createddate: data_insert.createddate
            }

            let track_check = [];

            //track_check//
            var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_FEED_CURRENT`)
            data.feed_current < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.feed_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_FEED_CURRENT`)
            data.feed_current > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.feed_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT`)
            data.relay_current < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.relay_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_RELAY_CURRENT`)
            data.relay_current > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.relay_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_FEED_VOLTAGE`)
            data.feed_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.feed_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_FEED_VOLTAGE`)
            data.feed_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.feed_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_VOLTAGE`)
            data.relay_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.relay_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_RELAY_VOLTAGE`)
            data.relay_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.relay_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_CHOKE_VOLTAGE`)
            data.choke_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.choke_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_CHOKE_VOLTAGE`)
            data.choke_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.choke_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_BATTERY_CHARGER_DC_VOLTAGE`)
            data.battery_charger_dc_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_dc_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_BATTERY_CHARGER_DC_VOLTAGE`)
            data.battery_charger_dc_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_dc_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_BATTERY_CHARGER_DC_CURRENT`)
            data.battery_charger_dc_current < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_dc_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_BATTERY_CHARGER_DC_CURRENT`)
            data.battery_charger_dc_current > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_dc_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_BATTERY_CHARGER_AC_VOLTAGE`)
            data.battery_charger_ac_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_ac_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_BATTERY_CHARGER_AC_VOLTAGE`)
            data.battery_charger_ac_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_ac_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_BATTERY_CHARGER_AC_CURRENT`)
            data.battery_charger_ac_current < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_ac_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_BATTERY_CHARGER_AC_CURRENT`)
            data.battery_charger_ac_current > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_ac_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE`)
            data.trv < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.trv, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_TRACK_RELAY_VOLTAGE`)
            data.trv > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.trv, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@CRITICAL_RELAY_VOLTAGE`)
            data.relay_voltage < parseFloat(alert_name_values.value) && data.feed_current > parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@CRITICAL_FEED_CURRENT`) && alert_name_values.isactive) === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.relay_voltage, alert_name_values.unit) + " and " + await get_alert_message(`${station_id}@${trackcircuitid}@${assertname}@CRITICAL_FEED_CURRENT`, data.feed_current), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            var result = lodash.filter(track_check, function (o) { return o.result; });
            var mode_filtered = lodash.groupBy(track_check, function (o) { return o.mode })

            let alert_data = {}
            let alert_logs = []
            let alert_modeid = 0

            let mobile_notification_data = []

            if (result.length > 0) {
                for (var property in mode_filtered) {
                    let alertid = ""
                    let modeid = lodash.result(lodash.find(AlertModes, { 'mode': property }), 'id')
                    alert_modeid = alert_modeid == null ? modeid : alert_modeid > modeid ? alert_modeid : modeid

                    alert_data = {
                        trackcircuitid: parseInt(data.trackcircuitid),
                        trackcircuitdataid: dataid,
                        stationid: data.stationid,
                        message: mode_filtered[property].map(item => item.message).join(' ; '),
                        assertsid: data.assertid,
                        modeid: modeid,
                        mode: property,
                        createddate: data.createddate,
                        isdele: false
                    }
                    alert_logs.push(alert_data)

                    const alertinsert = await TrackCircuitAlert.create(alert_data, { transaction: transaction }).then(res => alertid = res.id)
                    //logs.info(`station trackcircuit alert ended`);
                    //console.log(`station trackcircuit alert ended`); 

                    var get_users = await NotificationControl.findAll({ where: { assertsid: data.assertid, stationid: data.stationid, isdele: false } })
                    var get_users_id = lodash.uniq(get_users.map(item => item.userid))

                    let alert_message_ids = lodash.uniq(mode_filtered[property].map(i => i.id)).sort((a, b) => a - b)

                    for (let i = 0; i < get_users_id.length; i++) {

                        const get_previous_notification = await NotificationSend.findOne({
                            where: { stationid: data.stationid, assertsid: data.assertid, alertmessageids: alert_message_ids, modeid: modeid, userid: get_users_id[i], isseen: false, isdele: false },
                            order: [["id", "DESC"]]
                        })

                        if (get_previous_notification == null) {
                            mobile_notification_data.push({
                                stationid: data.stationid,
                                stationcode: data.stationcode,
                                stationname: data.stationname,
                                assertname: data.assertname,
                                assertsid: data.assertid,
                                assertidname: data.trackname,
                                alertid: alertid,
                                userid: get_users_id[i],
                                message: alert_data.message,
                                modeid: modeid,
                                mode: property,
                                alertmessageids: alert_message_ids,
                                isseen: false,
                                issend: false,
                                createddate: data.createddate,
                            })
                        }
                    }

                }
                if (mobile_notification_data.length > 0) {
                    const notifiyinsert = await NotificationSend.bulkCreate(mobile_notification_data, { transaction: transaction })
                    Socket.emit('Notification', mobile_notification_data);
                    //socketcloud.emit("Notification", mobile_notification_data)
                }
            }

            let data_logs = {
                id: dataid,
                trackcircuitid: parseInt(data.trackcircuitid),
                trackname: data.trackname,
                feed_count: data.feed_count,
                feed_current: data.feed_current,
                feed_voltage: data.feed_voltage,
                choke_voltage: data.choke_voltage,
                battery_charger_dc_current: data.battery_charger_dc_current,
                battery_charger_dc_voltage: data.battery_charger_dc_voltage,
                battery_charger_ac_current: data.battery_charger_ac_current,
                battery_charger_ac_voltage: data.battery_charger_ac_voltage,
                relay_count: data.relay_count,
                relay_current: data.relay_current,
                relay_voltage: data.relay_voltage,
                trv: data.trv,
                index_score: data.index_score,
                leakage_current: data.leakage_current,
                health: data.health,
                track_OC: data.track_OC,
                createddate: data.createddate,
                time: moment(data.createddate).format("HH:mm:ss"),
                isdele: false
            }

            // //commented it out because not using now
            // let tracks = []
            // tracks.push({
            //     id: parseInt(data.trackcircuitid),
            //     trackname: data.trackname,
            //     feed_count: data.feed_count,
            //     feed_current: data.feed_current,
            //     feed_voltage: data.feed_voltage,
            //     choke_voltage: data.choke_voltage,
            //     relay_count: data.relay_count,
            //     battery_charger_dc_current: data.battery_charger_dc_current,
            //     battery_charger_dc_voltage: data.battery_charger_dc_voltage,
            //     battery_charger_ac_current: data.battery_charger_ac_current,
            //     battery_charger_ac_voltage: data.battery_charger_ac_voltage,
            //     relay_current: data.relay_current,
            //     relay_voltage: data.relay_voltage,
            //     trv: data.trv,
            //     index_score: data.index_score,
            //     leakage_current: data.leakage_current,
            //     health: data.health,
            //     track_OC: data.track_OC,
            //     createddate: data.createddate,
            // })

            // var trackcircuits = await RegisteredTrackCircuit.findAll({ where: { isdele: false, stationid: data.stationid } })
            // for (let i = 0; i < trackcircuits.length; i++) {
            //     let element = trackcircuits[i]
            //     var get_finaltrackcircuit_datas = [await TrackCircuitData.findOne({ limit: 1, where: { isdele: false, trackcircuitid: element.id }, order: [["id", "DESC"]] })];
            //     get_finaltrackcircuit_datas = get_finaltrackcircuit_datas[0] !== null ? get_finaltrackcircuit_datas : []
            //     if (get_finaltrackcircuit_datas.length > 0 && element.id != parseInt(data.trackcircuitid)) {
            //         tracks.push({
            //             id: element.id,
            //             trackname: element.trackname,
            //             feed_count: get_finaltrackcircuit_datas[0].feed_count,
            //             feed_current: get_finaltrackcircuit_datas[0].feed_current,
            //             feed_voltage: get_finaltrackcircuit_datas[0].feed_voltage,
            //             choke_voltage: get_finaltrackcircuit_datas[0].choke_voltage,
            //             relay_count: get_finaltrackcircuit_datas[0].relay_count,
            //             battery_charger_dc_current: get_finaltrackcircuit_datas[0].battery_charger_dc_current,
            //             battery_charger_dc_voltage: get_finaltrackcircuit_datas[0].battery_charger_dc_voltage,
            //             battery_charger_ac_current: get_finaltrackcircuit_datas[0].battery_charger_ac_current,
            //             battery_charger_ac_voltage: get_finaltrackcircuit_datas[0].battery_charger_ac_voltage,
            //             relay_current: get_finaltrackcircuit_datas[0].relay_current,
            //             relay_voltage: get_finaltrackcircuit_datas[0].relay_voltage,
            //             trv: get_finaltrackcircuit_datas[0].trv,
            //             index_score: get_finaltrackcircuit_datas[0].index_score,
            //             leakage_current: get_finaltrackcircuit_datas[0].leakage_current,
            //             health: get_finaltrackcircuit_datas[0].health,
            //             track_OC: get_finaltrackcircuit_datas[0].track_OC,
            //             createddate: get_finaltrackcircuit_datas[0].createddate,
            //         })
            //     }
            // }

            let socket_data = {
                data_logs: data_logs,
                // tracks: tracks,
                alertmodeid: alert_logs.length > 0 ? alert_modeid : null,
                alerts: alert_logs
            }
            await transaction.commit();
            //logs.info('track_socket_data',socket_data) 
            Socket.emit("trackcircuitdata", socket_data)
            //socketcloud.emit("Track", socket_data)
        } catch (ex) {
            await transaction.rollback();
            logs.error('station feederrelay track data error' + ex);
            //console.log('station feederrelay track data error' + ex);
        }
    }

    // Inactive - Track Circuit Feeder 
    async function insert_feedertracknotification(data) {
        logs.info(`station track feeder circuit data started`);
        //console.log(`station track feeder circuit data started`);   
        try {
            alert_value_list = require("./alertvalue").getValues();
            let station_id = data.stationid
            let data_insert = []
            var get_finaltrackcircuit_datas = [await TrackCircuitData.findOne({ limit: 1, where: { isdele: false, trackcircuitid: parseInt(data.trackcircuitid) }, order: [["id", "DESC"]] })];
            get_finaltrackcircuit_datas = get_finalpointmachine_datas[0] !== null ? get_finaltrackcircuit_datas : []
            const get_feederdata = await TrackCircuitFeederData.findAll({ where: { isdele: false, trackcircuitid: parseInt(data.trackcircuitid) } });
            const get_relaydata = await TrackCircuitRelayData.findAll({ where: { isdele: false, trackcircuitid: parseInt(data.trackcircuitid) } });

            if (get_finaltrackcircuit_datas.length > 0) {
                let finalfeeder = get_finaltrackcircuit_datas[0].feed_count === 0 ? 1 : get_finaltrackcircuit_datas[0].feed_count;
                let finalrelay = get_finaltrackcircuit_datas[0].relay_count === 0 ? 1 : get_finaltrackcircuit_datas[0].relay_count;

                var feederdata = [];
                var Feedercount = [];
                var relaydata = [];
                var Relaycount = [];

                if (get_relaydata.length > 0) {
                    relaydata = lodash.filter(get_relaydata, ({ count }) => count > finalrelay)
                    Relaycount = relaydata.map(a => a.count)
                }

                if (get_feederdata.length > 0) {
                    feederdata = lodash.filter(get_feederdata, ({ count }) => count > finalfeeder)
                    Feedercount = feederdata.map(a => a.count)

                    if (get_feederdata.length === 1 && Relaycount.length === 0 && Feedercount.length === 0) {
                        data_insert.push({
                            trackcircuitid: parseInt(data.trackcircuitid),
                            feed_count: get_feederdata[get_feederdata.length - 1].count,
                            feed_current: get_feederdata[get_feederdata.length - 1].feederendcurrent,
                            feed_voltage: get_feederdata[get_feederdata.length - 1].feederendvoltage,
                            choke_voltage: get_feederdata[get_feederdata.length - 1].chokevoltage,
                            charger: get_feederdata[get_feederdata.length - 1].charger,
                            relay_count: get_relaydata[get_relaydata.length - 1].count,
                            relay_current: get_relaydata[get_relaydata.length - 1].relayendcurrent,
                            relay_voltage: get_relaydata[get_relaydata.length - 1].relayendvoltage,
                            trv: get_relaydata[get_relaydata.length - 1].trackvoltage,
                            index_score: 5,
                            leakage_current: 0,
                            health: 'OK',
                            track_OC: 'O',
                            createddate: get_feederdata[get_feederdata.length - 1].createddate,
                            isdele: false
                        })
                    }
                }

                if (Feedercount.length >= Relaycount.length) {
                    let count = finalrelay
                    for await (const Felement of feederdata) {
                        data_insert.push({
                            trackcircuitid: parseInt(data.trackcircuitid),
                            feed_count: Felement.count,
                            feed_current: Felement.feederendcurrent,
                            feed_voltage: Felement.feederendvoltage,
                            choke_voltage: Felement.chokevoltage,
                            charger: Felement.charger,
                            relay_count: get_relaydata.length > count ? get_relaydata[count].count : get_relaydata.length === 0 ? 0 : get_relaydata[get_relaydata.length - 1].count,
                            relay_current: get_relaydata.length > count ? get_relaydata[count].relayendcurrent : get_relaydata.length === 0 ? 0 : get_relaydata[get_relaydata.length - 1].relayendcurrent,
                            relay_voltage: get_relaydata.length > count ? get_relaydata[count].relayendvoltage : get_relaydata.length === 0 ? 0 : get_relaydata[get_relaydata.length - 1].relayendvoltage,
                            trv: get_relaydata.length > count ? get_relaydata[count].trackvoltage : get_relaydata.length === 0 ? 0 : get_relaydata[get_relaydata.length - 1].trackvoltage,
                            index_score: 5,
                            leakage_current: 0,
                            health: 'OK',
                            track_OC: 'O',
                            createddate: Felement.createddate,
                            isdele: false
                        })
                        count++
                    }
                }
                else {
                    let count = finalfeeder
                    for await (const Relement of relaydata) {
                        data_insert.push({
                            trackcircuitid: parseInt(data.trackcircuitid),
                            feed_count: get_feederdata.length > count ? get_feederdata[count].count : get_feederdata.length === 0 ? 0 : get_feederdata[get_feederdata.length - 1].count,
                            feed_current: get_feederdata.length > count ? get_feederdata[count].feederendcurrent : get_feederdata.length === 0 ? 0 : get_feederdata[get_feederdata.length - 1].feederendcurrent,
                            feed_voltage: get_feederdata.length > count ? get_feederdata[count].feederendvoltage : get_feederdata.length === 0 ? 0 : get_feederdata[get_feederdata.length - 1].feederendvoltage,
                            choke_voltage: get_feederdata.length > count ? get_feederdata[count].chokevoltage : get_feederdata.length === 0 ? 0 : get_feederdata[get_feederdata.length - 1].chokevoltage,
                            charger: get_feederdata.charger > count ? get_feederdata[count].charger : get_feederdata.length === 0 ? 0 : get_feederdata[get_feederdata.length - 1].charger,
                            relay_count: Relement.count,
                            relay_current: Relement.relayendcurrent,
                            relay_voltage: Relement.relayendvoltage,
                            trv: Relement.trackvoltage,
                            index_score: 5,
                            leakage_current: 0,
                            health: 'OK',
                            track_OC: 'O',
                            createddate: Relement.createddate,
                            isdele: false
                        })
                        count++
                    }
                }

            }
            else {
                if (get_feederdata.length >= get_relaydata.length) {
                    let count = 1
                    for await (const Felement of get_feederdata) {
                        if (count == 1) {
                            if (get_relaydata.length == 0) {
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: Felement.count,
                                    feed_current: Felement.feederendcurrent,
                                    feed_voltage: Felement.feederendvoltage,
                                    choke_voltage: Felement.chokevoltage,
                                    charger: Felement.charger,
                                    relay_count: 0,
                                    relay_current: 0,
                                    relay_voltage: 0,
                                    trv: 0,
                                    index_score: 5,
                                    leakage_current: 0,
                                    health: 'OK',
                                    track_OC: 'O',
                                    createddate: Felement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: Felement.count,
                                    feed_current: Felement.feederendcurrent,
                                    feed_voltage: Felement.feederendvoltage,
                                    choke_voltage: Felement.chokevoltage,
                                    charger: Felement.charger,
                                    relay_count: get_relaydata.length > count ? get_relaydata[count - 1].count : get_relaydata[get_relaydata.length - 1].count,
                                    relay_current: get_relaydata.length > count ? get_relaydata[count - 1].relayendcurrent : get_relaydata[get_relaydata.length - 1].relayendcurrent,
                                    relay_voltage: get_relaydata.length > count ? get_relaydata[count - 1].relayendvoltage : get_relaydata[get_relaydata.length - 1].relayendvoltage,
                                    trv: get_relaydata.length > count ? get_relaydata[count - 1].trackvoltage : get_relaydata[get_relaydata.length - 1].trackvoltage,
                                    index_score: 5,
                                    leakage_current: 0,
                                    health: 'OK',
                                    track_OC: 'O',
                                    createddate: Felement.createddate,
                                    isdele: false
                                })
                            }
                        }
                        else {
                            if (get_relaydata.length == 0) {
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: Felement.count,
                                    feed_current: Felement.feederendcurrent,
                                    feed_voltage: Felement.feederendvoltage,
                                    choke_voltage: Felement.chokevoltage,
                                    charger: Felement.charger,
                                    relay_count: 0,
                                    relay_current: 0,
                                    relay_voltage: 0,
                                    trv: 0,
                                    index_score: 5,
                                    leakage_current: 0,
                                    health: 'OK',
                                    track_OC: 'O',
                                    createddate: Felement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: Felement.count,
                                    feed_current: Felement.feederendcurrent,
                                    feed_voltage: Felement.feederendvoltage,
                                    choke_voltage: Felement.chokevoltage,
                                    charger: Felement.charger,
                                    relay_count: get_relaydata.length > count ? get_relaydata[count - 1].count : get_relaydata[get_relaydata.length - 1].count,
                                    relay_current: get_relaydata.length > count ? get_relaydata[count - 1].relayendcurrent : get_relaydata[get_relaydata.length - 1].relayendcurrent,
                                    relay_voltage: get_relaydata.length > count ? get_relaydata[count - 1].relayendvoltage : get_relaydata[get_relaydata.length - 1].relayendvoltage,
                                    trv: get_relaydata.length > count ? get_relaydata[count - 1].trackvoltage : get_relaydata[get_relaydata.length - 1].trackvoltage,
                                    index_score: 5,
                                    leakage_current: 0,
                                    health: 'OK',
                                    track_OC: 'O',
                                    createddate: Felement.createddate,
                                    isdele: false
                                })
                            }

                        }
                        count++;
                    }
                }
                else {
                    let count = 1
                    for await (const Relement of get_relaydata) {
                        if (count == 1) {
                            if (get_feederdata.length == 0) {
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: 0,
                                    feed_current: 0,
                                    feed_voltage: 0,
                                    choke_voltage: 0,
                                    charger: 0,
                                    relay_count: Relement.count,
                                    relay_current: Relement.relayendcurrent,
                                    relay_voltage: Relement.relayendvoltage,
                                    trv: Relement.trackvoltage,
                                    index_score: 5,
                                    leakage_current: 0,
                                    health: 'OK',
                                    track_OC: 'O',
                                    createddate: Relement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: get_feederdata.length > count ? get_feederdata[count - 1].count : get_feederdata[get_feederdata.length - 1].count,
                                    feed_current: get_feederdata.length > count ? get_feederdata[count - 1].feederendcurrent : get_feederdata[get_feederdata.length - 1].feederendcurrent,
                                    feed_voltage: get_feederdata.length > count ? get_feederdata[count - 1].feederendvoltage : get_feederdata[get_feederdata.length - 1].feederendvoltage,
                                    choke_voltage: get_feederdata.length > count ? get_feederdata[count - 1].chokevoltage : get_feederdata[get_feederdata.length - 1].chokevoltage,
                                    charger: get_feederdata.length > count ? get_feederdata[count - 1].charger : get_feederdata[get_feederdata.length - 1].charger,
                                    relay_count: Relement.count,
                                    relay_current: Relement.relayendcurrent,
                                    relay_voltage: Relement.relayendvoltage,
                                    trv: Relement.trackvoltage,
                                    index_score: 5,
                                    leakage_current: 0,
                                    health: 'OK',
                                    track_OC: 'O',
                                    createddate: Relement.createddate,
                                    isdele: false
                                })
                            }
                        }
                        else {
                            if (get_feederdata.length == 0) {
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: 0,
                                    feed_current: 0,
                                    feed_voltage: 0,
                                    choke_voltage: 0,
                                    charger: 0,
                                    relay_count: Relement.count,
                                    relay_current: Relement.relayendcurrent,
                                    relay_voltage: Relement.relayendvoltage,
                                    trv: Relement.trackvoltage,
                                    index_score: 5,
                                    leakage_current: 0,
                                    health: 'OK',
                                    track_OC: 'O',
                                    createddate: Relement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: get_feederdata.length > count ? get_feederdata[count - 1].count : get_feederdata[get_feederdata.length - 1].count,
                                    feed_current: get_feederdata.length > count ? get_feederdata[count - 1].feederendcurrent : get_feederdata[get_feederdata.length - 1].feederendcurrent,
                                    feed_voltage: get_feederdata.length > count ? get_feederdata[count - 1].feederendvoltage : get_feederdata[get_feederdata.length - 1].feederendvoltage,
                                    choke_voltage: get_feederdata.length > count ? get_feederdata[count - 1].chokevoltage : get_feederdata[get_feederdata.length - 1].chokevoltage,
                                    charger: get_feederdata.length > count ? get_feederdata[count - 1].charger : get_feederdata[get_feederdata.length - 1].charger,
                                    relay_count: Relement.count,
                                    relay_current: Relement.relayendcurrent,
                                    relay_voltage: Relement.relayendvoltage,
                                    trv: Relement.trackvoltage,
                                    index_score: 5,
                                    leakage_current: 0,
                                    health: 'OK',
                                    track_OC: 'O',
                                    createddate: Relement.createddate,
                                    isdele: false
                                })
                            }

                        }
                        count++;
                    }
                }
            }

            if (data_insert.length > 0) {
                logs.info('feeder_data_insert_feedcount', data_insert.map(a => a.feed_count))
                logs.info('feeder_data_insert_relaycount', data_insert.map(a => a.relay_count))

                let transaction = await db.transaction({ autocommit: false });
                try {
                    let insert_dataid = ""
                    const create_data = await TrackCircuitData
                        .create(data_insert[0], { transaction: transaction }).then(res => insert_dataid = res.id)
                    await transaction.commit();
                    insert_feederrelaytrackcircuit(data, data_insert[0], insert_dataid);
                }
                catch (ex) {
                    await transaction.rollback();
                    logs.error('station track circuit feeder data error' + ex);
                    //console.log('station track circuit feeder data error' + ex);
                }
            }
        }
        catch (ex) {
            logs.error('station track circuit feeder data error' + ex);
            //console.log('station track circuit feeder data error' + ex);
        }
    }

    // Inactive - Track Circuit Relay
    async function insert_relaytracknotification(data) {
        logs.info(`station track relay circuit data started`);
        //console.log(`station track relay circuit data started`);   
        try {
            alert_value_list = require("./alertvalue").getValues();

            let data_insert = []
            let station_id = data.stationid
            var get_finaltrackcircuit_datas = [await TrackCircuitData.findOne({ limit: 1, where: { isdele: false, trackcircuitid: parseInt(data.trackcircuitid) }, order: [["id", "DESC"]] })];
            get_finaltrackcircuit_datas = get_finalpointmachine_datas[0] !== null ? get_finaltrackcircuit_datas : []
            const get_feederdata = await TrackCircuitFeederData.findAll({ where: { isdele: false, trackcircuitid: parseInt(data.trackcircuitid) } });
            const get_relaydata = await TrackCircuitRelayData.findAll({ where: { isdele: false, trackcircuitid: parseInt(data.trackcircuitid) } });

            if (get_finaltrackcircuit_datas.length > 0) {
                let finalfeeder = get_finaltrackcircuit_datas[0].feed_count === 0 ? 1 : get_finaltrackcircuit_datas[0].feed_count;
                let finalrelay = get_finaltrackcircuit_datas[0].relay_count === 0 ? 1 : get_finaltrackcircuit_datas[0].relay_count;

                var feederdata = [];
                var Feedercount = [];
                var relaydata = [];
                var Relaycount = [];

                if (get_feederdata.length > 0) {
                    feederdata = lodash.filter(get_feederdata, ({ count }) => count > finalfeeder)
                    Feedercount = feederdata.map(a => a.count)
                }

                if (get_relaydata.length > 0) {
                    relaydata = lodash.filter(get_relaydata, ({ count }) => count > finalrelay)
                    Relaycount = relaydata.map(a => a.count)
                    if (get_relaydata.length === 1 && Relaycount.length === 0 && Feedercount.length === 0) {
                        data_insert.push({
                            trackcircuitid: parseInt(data.trackcircuitid),
                            feed_count: get_feederdata[get_feederdata.length - 1].count,
                            feed_current: get_feederdata[get_feederdata.length - 1].feederendcurrent,
                            feed_voltage: get_feederdata[get_feederdata.length - 1].feederendvoltage,
                            choke_voltage: get_feederdata[get_feederdata.length - 1].chokevoltage,
                            charger: get_feederdata[get_feederdata.length - 1].charger,
                            relay_count: get_relaydata[get_relaydata.length - 1].count,
                            relay_current: get_relaydata[get_relaydata.length - 1].relayendcurrent,
                            relay_voltage: get_relaydata[get_relaydata.length - 1].relayendvoltage,
                            trv: get_relaydata[get_relaydata.length - 1].trackvoltage,
                            index_score: 5,
                            leakage_current: 0,
                            health: 'OK',
                            track_OC: 'O',
                            createddate: get_feederdata[get_feederdata.length - 1].createddate,
                            isdele: false
                        })
                    }
                }

                if (Feedercount.length >= Relaycount.length) {
                    let count = finalrelay
                    for await (const Felement of feederdata) {
                        data_insert.push({
                            trackcircuitid: parseInt(data.trackcircuitid),
                            feed_count: Felement.count,
                            feed_current: Felement.feederendcurrent,
                            feed_voltage: Felement.feederendvoltage,
                            choke_voltage: Felement.chokevoltage,
                            charger: Felement.charger,
                            relay_count: get_relaydata.length > count ? get_relaydata[count].count : get_relaydata.length === 0 ? 0 : get_relaydata[get_relaydata.length - 1].count,
                            relay_current: get_relaydata.length > count ? get_relaydata[count].relayendcurrent : get_relaydata.length === 0 ? 0 : get_relaydata[get_relaydata.length - 1].relayendcurrent,
                            relay_voltage: get_relaydata.length > count ? get_relaydata[count].relayendvoltage : get_relaydata.length === 0 ? 0 : get_relaydata[get_relaydata.length - 1].relayendvoltage,
                            trv: get_relaydata.length > count ? get_relaydata[count].trackvoltage : get_relaydata.length === 0 ? 0 : get_relaydata[get_relaydata.length - 1].trackvoltage,
                            index_score: 5,
                            leakage_current: 0,
                            health: 'OK',
                            track_OC: 'O',
                            createddate: Felement.createddate,
                            isdele: false
                        })
                        count++
                    }
                }
                else {
                    let count = finalfeeder
                    for await (const Relement of relaydata) {
                        data_insert.push({
                            trackcircuitid: parseInt(data.trackcircuitid),
                            feed_count: get_feederdata.length > count ? get_feederdata[count].count : get_feederdata.length === 0 ? 0 : get_feederdata[get_feederdata.length - 1].count,
                            feed_current: get_feederdata.length > count ? get_feederdata[count].feederendcurrent : get_feederdata.length === 0 ? 0 : get_feederdata[get_feederdata.length - 1].feederendcurrent,
                            feed_voltage: get_feederdata.length > count ? get_feederdata[count].feederendvoltage : get_feederdata.length === 0 ? 0 : get_feederdata[get_feederdata.length - 1].feederendvoltage,
                            choke_voltage: get_feederdata.length > count ? get_feederdata[count].chokevoltage : get_feederdata.length === 0 ? 0 : get_feederdata[get_feederdata.length - 1].chokevoltage,
                            charger: get_feederdata.charger > count ? get_feederdata[count].charger : get_feederdata.length === 0 ? 0 : get_feederdata[get_feederdata.length - 1].charger,
                            relay_count: Relement.count,
                            relay_current: Relement.relayendcurrent,
                            relay_voltage: Relement.relayendvoltage,
                            trv: Relement.trackvoltage,
                            index_score: 5,
                            leakage_current: 0,
                            health: 'OK',
                            track_OC: 'O',
                            createddate: Relement.createddate,
                            isdele: false
                        })
                        count++
                    }
                }

            }
            else {
                if (get_feederdata.length >= get_relaydata.length) {
                    let count = 1
                    for await (const Felement of get_feederdata) {
                        if (count == 1) {
                            if (get_relaydata.length == 0) {
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: Felement.count,
                                    feed_current: Felement.feederendcurrent,
                                    feed_voltage: Felement.feederendvoltage,
                                    choke_voltage: Felement.chokevoltage,
                                    charger: Felement.charger,
                                    relay_count: 0,
                                    relay_current: 0,
                                    relay_voltage: 0,
                                    trv: 0,
                                    index_score: 5,
                                    leakage_current: 0,
                                    health: 'OK',
                                    track_OC: 'O',
                                    createddate: Felement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: Felement.count,
                                    feed_current: Felement.feederendcurrent,
                                    feed_voltage: Felement.feederendvoltage,
                                    choke_voltage: Felement.chokevoltage,
                                    charger: Felement.charger,
                                    relay_count: get_relaydata.length > count ? get_relaydata[count - 1].count : get_relaydata[get_relaydata.length - 1].count,
                                    relay_current: get_relaydata.length > count ? get_relaydata[count - 1].relayendcurrent : get_relaydata[get_relaydata.length - 1].relayendcurrent,
                                    relay_voltage: get_relaydata.length > count ? get_relaydata[count - 1].relayendvoltage : get_relaydata[get_relaydata.length - 1].relayendvoltage,
                                    trv: get_relaydata.length > count ? get_relaydata[count - 1].trackvoltage : get_relaydata[get_relaydata.length - 1].trackvoltage,
                                    index_score: 5,
                                    leakage_current: 0,
                                    health: 'OK',
                                    track_OC: 'O',
                                    createddate: Felement.createddate,
                                    isdele: false
                                })
                            }
                        }
                        else {
                            if (get_relaydata.length == 0) {
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: Felement.count,
                                    feed_current: Felement.feederendcurrent,
                                    feed_voltage: Felement.feederendvoltage,
                                    choke_voltage: Felement.chokevoltage,
                                    charger: Felement.charger,
                                    relay_count: 0,
                                    relay_current: 0,
                                    relay_voltage: 0,
                                    trv: 0,
                                    index_score: 5,
                                    leakage_current: 0,
                                    health: 'OK',
                                    track_OC: 'O',
                                    createddate: Felement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: Felement.count,
                                    feed_current: Felement.feederendcurrent,
                                    feed_voltage: Felement.feederendvoltage,
                                    choke_voltage: Felement.chokevoltage,
                                    charger: Felement.charger,
                                    relay_count: get_relaydata.length > count ? get_relaydata[count - 1].count : get_relaydata[get_relaydata.length - 1].count,
                                    relay_current: get_relaydata.length > count ? get_relaydata[count - 1].relayendcurrent : get_relaydata[get_relaydata.length - 1].relayendcurrent,
                                    relay_voltage: get_relaydata.length > count ? get_relaydata[count - 1].relayendvoltage : get_relaydata[get_relaydata.length - 1].relayendvoltage,
                                    trv: get_relaydata.length > count ? get_relaydata[count - 1].trackvoltage : get_relaydata[get_relaydata.length - 1].trackvoltage,
                                    index_score: 5,
                                    leakage_current: 0,
                                    health: 'OK',
                                    track_OC: 'O',
                                    createddate: Felement.createddate,
                                    isdele: false
                                })
                            }

                        }
                        count++;
                    }
                }
                else {
                    let count = 1
                    for await (const Relement of get_relaydata) {
                        if (count == 1) {
                            if (get_feederdata.length == 0) {
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: 0,
                                    feed_current: 0,
                                    feed_voltage: 0,
                                    choke_voltage: 0,
                                    charger: 0,
                                    relay_count: Relement.count,
                                    relay_current: Relement.relayendcurrent,
                                    relay_voltage: Relement.relayendvoltage,
                                    trv: Relement.trackvoltage,
                                    index_score: 5,
                                    leakage_current: 0,
                                    health: 'OK',
                                    track_OC: 'O',
                                    createddate: Relement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: get_feederdata.length > count ? get_feederdata[count - 1].count : get_feederdata[get_feederdata.length - 1].count,
                                    feed_current: get_feederdata.length > count ? get_feederdata[count - 1].feederendcurrent : get_feederdata[get_feederdata.length - 1].feederendcurrent,
                                    feed_voltage: get_feederdata.length > count ? get_feederdata[count - 1].feederendvoltage : get_feederdata[get_feederdata.length - 1].feederendvoltage,
                                    choke_voltage: get_feederdata.length > count ? get_feederdata[count - 1].chokevoltage : get_feederdata[get_feederdata.length - 1].chokevoltage,
                                    charger: get_feederdata.length > count ? get_feederdata[count - 1].charger : get_feederdata[get_feederdata.length - 1].charger,
                                    relay_count: Relement.count,
                                    relay_current: Relement.relayendcurrent,
                                    relay_voltage: Relement.relayendvoltage,
                                    trv: Relement.trackvoltage,
                                    index_score: 5,
                                    leakage_current: 0,
                                    health: 'OK',
                                    track_OC: 'O',
                                    createddate: Relement.createddate,
                                    isdele: false
                                })
                            }
                        }
                        else {
                            if (get_feederdata.length == 0) {
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: 0,
                                    feed_current: 0,
                                    feed_voltage: 0,
                                    choke_voltage: 0,
                                    charger: 0,
                                    relay_count: Relement.count,
                                    relay_current: Relement.relayendcurrent,
                                    relay_voltage: Relement.relayendvoltage,
                                    trv: Relement.trackvoltage,
                                    index_score: 5,
                                    leakage_current: 0,
                                    health: 'OK',
                                    track_OC: 'O',
                                    createddate: Relement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                data_insert.push({
                                    trackcircuitid: parseInt(data.trackcircuitid),
                                    feed_count: get_feederdata.length > count ? get_feederdata[count - 1].count : get_feederdata[get_feederdata.length - 1].count,
                                    feed_current: get_feederdata.length > count ? get_feederdata[count - 1].feederendcurrent : get_feederdata[get_feederdata.length - 1].feederendcurrent,
                                    feed_voltage: get_feederdata.length > count ? get_feederdata[count - 1].feederendvoltage : get_feederdata[get_feederdata.length - 1].feederendvoltage,
                                    choke_voltage: get_feederdata.length > count ? get_feederdata[count - 1].chokevoltage : get_feederdata[get_feederdata.length - 1].chokevoltage,
                                    charger: get_feederdata.length > count ? get_feederdata[count - 1].charger : get_feederdata[get_feederdata.length - 1].charger,
                                    relay_count: Relement.count,
                                    relay_current: Relement.relayendcurrent,
                                    relay_voltage: Relement.relayendvoltage,
                                    trv: Relement.trackvoltage,
                                    index_score: 5,
                                    leakage_current: 0,
                                    health: 'OK',
                                    track_OC: 'O',
                                    createddate: Relement.createddate,
                                    isdele: false
                                })
                            }

                        }
                        count++;
                    }
                }
            }

            if (data_insert.length > 0) {
                logs.info('relay_data_insert_feedcount', data_insert.map(a => a.feed_count))
                logs.info('relay_data_insert_relaycount', data_insert.map(a => a.relay_count))

                let transaction = await db.transaction({ autocommit: false });
                try {
                    await transaction.commit();
                    insert_feederrelaytrackcircuit(data, data_insert[0], insert_dataid);
                }
                catch (ex) {
                    await transaction.rollback();
                    logs.error('station track circuit feeder data error' + ex);
                    //console.log('station track circuit feeder data error' + ex);
                }
            }
        }
        catch (ex) {
            logs.error('station track circuit feeder data error' + ex);
            //console.log('station track circuit feeder data error' + ex);
        }
    }

    // Inactive - Track Circuit Feeder & Relay
    async function insert_feederrelaytrackcircuit(datas, data, dataid) {
        logs.info('insert track circuit alert started');
        //console.log('insert track circuit alert started');
        let transaction = await db.transaction({ autocommit: false });
        try {
            alert_value_list = require("./alertvalue").getValues();
            let station_id = datas.stationid
            let trackcircuitid = datas.trackcircuitid
            let assertname = datas.assertname
            let alert_message = "";
            let track_check = [];

            //track_check
            var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_FEED_CURRENT`)
            data.feed_current < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.feed_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_FEED_CURRENT`)
            data.feed_current > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.feed_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT`)
            data.relay_current < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.relay_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_RELAY_CURRENT`)
            data.relay_current > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.relay_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_FEED_VOLTAGE`)
            data.feed_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.feed_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_FEED_VOLTAGE`)
            data.feed_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.feed_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_VOLTAGE`)
            data.relay_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.relay_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_RELAY_VOLTAGE`)
            data.relay_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.relay_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_CHOKE_VOLTAGE`)
            data.choke_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.choke_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_CHOKE_VOLTAGE`)
            data.choke_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.choke_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_BATTERY_CHARGER_DC_VOLTAGE`)
            data.battery_charger_dc_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_dc_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_BATTERY_CHARGER_DC_VOLTAGE`)
            data.battery_charger_dc_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_dc_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_BATTERY_CHARGER_DC_CURRENT`)
            data.battery_charger_dc_current < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_dc_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_BATTERY_CHARGER_DC_CURRENT`)
            data.battery_charger_dc_current > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_dc_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_BATTERY_CHARGER_AC_VOLTAGE`)
            data.battery_charger_ac_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_ac_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_BATTERY_CHARGER_AC_VOLTAGE`)
            data.battery_charger_ac_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_ac_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_BATTERY_CHARGER_AC_CURRENT`)
            data.battery_charger_ac_current < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_ac_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_BATTERY_CHARGER_AC_CURRENT`)
            data.battery_charger_ac_current > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_ac_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE`)
            data.trv < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.trv, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_TRACK_RELAY_VOLTAGE`)
            data.trv > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.trv, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@CRITICAL_RELAY_VOLTAGE`)
            data.relay_voltage < parseFloat(alert_name_values.value) && data.feed_current > parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@CRITICAL_FEED_CURRENT`) && alert_name_values.isactive) === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.relay_voltage, alert_name_values.unit) + " and " + await get_alert_message(`${station_id}@${trackcircuitid}@${assertname}@CRITICAL_FEED_CURRENT`, data.feed_current), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            var result = lodash.filter(track_check, function (o) { return o.result; });
            var mode_filtered = lodash.groupBy(track_check, function (o) { return o.mode })

            let alert_data = {}
            let alert_logs = []
            let alert_modeid = 0

            let mobile_notification_data = []

            if (result.length > 0) {
                for (var property in mode_filtered) {
                    let alertid = ""
                    let modeid = lodash.result(lodash.find(AlertModes, { 'mode': property }), 'id')
                    alert_modeid = alert_modeid == null ? modeid : alert_modeid > modeid ? alert_modeid : modeid

                    alert_data = {
                        trackcircuitid: parseInt(data.trackcircuitid),
                        trackcircuitdataid: dataid,
                        stationid: datas.stationid,
                        message: mode_filtered[property].map(item => item.message).join(' ; '),
                        assertsid: datas.assertid,
                        modeid: modeid,
                        mode: property,
                        createddate: datas.createddate,
                        isdele: false
                    }
                    alert_logs.push(alert_data)

                    const alertinsert = await TrackCircuitAlert.create(alert_data, { transaction: transaction }).then(res => alertid = res.id)
                    //logs.info(`station trackcircuit alert ended`);
                    //console.log(`station trackcircuit alert ended`); 

                    var get_users = await NotificationControl.findAll({ where: { assertsid: datas.assertid, stationid: datas.stationid, isdele: false } })
                    var get_users_id = lodash.uniq(get_users.map(item => item.userid))

                    let alert_message_ids = lodash.uniq(mode_filtered[property].map(i => i.id)).sort((a, b) => a - b)

                    for (let i = 0; i < get_users_id.length; i++) {

                        const get_previous_notification = await NotificationSend.findOne({
                            where: { stationid: datas.stationid, assertsid: datas.assertid, alertmessageids: alert_message_ids, modeid: modeid, userid: get_users_id[i], isseen: false, isdele: false },
                            order: [["id", "DESC"]]
                        })

                        if (get_previous_notification == null) {
                            mobile_notification_data.push({
                                stationid: datas.stationid,
                                stationcode: datas.stationcode,
                                stationname: datas.stationname,
                                assertname: datas.assertname,
                                assertsid: datas.assertid,
                                assertidname: datas.trackname,
                                alertid: alertid,
                                userid: get_users_id[i],
                                message: alert_data.message,
                                modeid: modeid,
                                mode: property,
                                alertmessageids: alert_message_ids,
                                isseen: false,
                                issend: false,
                                createddate: datas.createddate,
                            })
                        }
                    }

                }
                if (mobile_notification_data.length > 0) {
                    const notifiyinsert = await NotificationSend.bulkCreate(mobile_notification_data, { transaction: transaction })
                    Socket.emit('Notification', mobile_notification_data);
                    //socketcloud.emit("Notification", mobile_notification_data)
                }
            }

            let data_logs = {
                id: dataid,
                trackcircuitid: parseInt(data.trackcircuitid),
                trackname: data.trackname,
                feed_count: data.feed_count,
                feed_current: data.feed_current,
                feed_voltage: data.feed_voltage,
                choke_voltage: data.choke_voltage,
                battery_charger_dc_current: data.battery_charger_dc_current,
                battery_charger_dc_voltage: data.battery_charger_dc_voltage,
                battery_charger_ac_current: data.battery_charger_ac_current,
                battery_charger_ac_voltage: data.battery_charger_ac_voltage,
                relay_count: data.relay_count,
                relay_current: data.relay_current,
                relay_voltage: data.relay_voltage,
                trv: data.trv,
                index_score: data.index_score,
                leakage_current: data.leakage_current,
                health: data.health,
                track_OC: data.track_OC,
                createddate: data.createddate,
                time: moment(data.createddate).format("HH:mm:ss"),
                isdele: false
            }

            // //commented it out because not using now
            // let tracks = []
            // tracks.push({
            //     id: parseInt(data.trackcircuitid),
            //     trackname: datas.trackname,
            //     feed_count: data.feed_count,
            //     feed_current: data.feed_current,
            //     feed_voltage: data.feed_voltage,
            //     choke_voltage: data.choke_voltage,
            //     relay_count: data.relay_count,
            //     battery_charger_dc_current: data.battery_charger_dc_current,
            //     battery_charger_dc_voltage: data.battery_charger_dc_voltage,
            //     battery_charger_ac_current: data.battery_charger_ac_current,
            //     battery_charger_ac_voltage: data.battery_charger_ac_voltage,
            //     relay_current: data.relay_current,
            //     relay_voltage: data.relay_voltage,
            //     trv: data.trv,
            //     index_score: data.index_score,
            //     leakage_current: data.leakage_current,
            //     health: data.health,
            //     track_OC: data.track_OC,
            //     createddate: data.createddate,
            // })

            // var trackcircuits = await RegisteredTrackCircuit.findAll({ where: { isdele: false, stationid: datas.stationid } })
            // for (let i = 0; i < trackcircuits.length; i++) {
            //     let element = trackcircuits[i]
            //     var get_finaltrackcircuit_datas = [await TrackCircuitData.findOne({ limit: 1, where: { isdele: false, trackcircuitid: element.id }, order: [["id", "DESC"]] })];
            //     get_finaltrackcircuit_datas = get_finalpointmachine_datas[0] !== null ? get_finaltrackcircuit_datas : []
            //     if (get_finaltrackcircuit_datas.length > 0 && element.id != parseInt(data.trackcircuitid)) {
            //         tracks.push({
            //             id: element.id,
            //             trackname: element.trackname,
            //             feed_count: get_finaltrackcircuit_datas[0].feed_count,
            //             feed_current: get_finaltrackcircuit_datas[0].feed_current,
            //             feed_voltage: get_finaltrackcircuit_datas[0].feed_voltage,
            //             choke_voltage: get_finaltrackcircuit_datas[0].choke_voltage,
            //             relay_count: get_finaltrackcircuit_datas[0].relay_count,
            //             battery_charger_dc_current: get_finaltrackcircuit_datas[0].battery_charger_dc_current,
            //             battery_charger_dc_voltage: get_finaltrackcircuit_datas[0].battery_charger_dc_voltage,
            //             battery_charger_ac_current: get_finaltrackcircuit_datas[0].battery_charger_ac_current,
            //             battery_charger_ac_voltage: get_finaltrackcircuit_datas[0].battery_charger_ac_voltage,
            //             relay_current: get_finaltrackcircuit_datas[0].relay_current,
            //             relay_voltage: get_finaltrackcircuit_datas[0].relay_voltage,
            //             trv: get_finaltrackcircuit_datas[0].trv,
            //             index_score: get_finaltrackcircuit_datas[0].index_score,
            //             leakage_current: get_finaltrackcircuit_datas[0].leakage_current,
            //             health: get_finaltrackcircuit_datas[0].health,
            //             track_OC: get_finaltrackcircuit_datas[0].track_OC,
            //             createddate: get_finaltrackcircuit_datas[0].createddate,
            //         })
            //     }
            // }

            let socket_data = {
                data_logs: data_logs,
                // tracks: tracks,
                alertmodeid: alert_logs.length > 0 ? alert_modeid : null,
                alerts: alert_logs
            }
            await transaction.commit();
            //logs.info('track_socket_data',socket_data) 
            Socket.emit("trackcircuitdata", socket_data)
            //socketcloud.emit("Track", socket_data)
        } catch (ex) {
            await transaction.rollback();
            logs.error('station track circuit data error' + ex);
            //console.log('station track circuit data error' + ex);
        }
    }

    // Inactive - Track Circuit Feeder & Relay
    async function insert_trackcircuit(data, dataid) {
        logs.info('insert track circuit alert started');
        //console.log('insert track circuit alert started');
        let transaction = await db.transaction({ autocommit: false });
        try {
            alert_value_list = require("./alertvalue").getValues();
            let alert_message = "";
            let track_check = [];
            let station_id = data.stationid
            let trackcircuitid = data.trackcircuitid
            let assertname = data.assertname

            //track_check//
            var alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_FEED_CURRENT`)
            data.feed_current < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.feed_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_FEED_CURRENT`)
            data.feed_current > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.feed_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_CURRENT`)
            data.relay_current < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.relay_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_RELAY_CURRENT`)
            data.relay_current > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.relay_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_FEED_VOLTAGE`)
            data.feed_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.feed_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_FEED_VOLTAGE`)
            data.feed_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.feed_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_RELAY_VOLTAGE`)
            data.relay_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.relay_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_RELAY_VOLTAGE`)
            data.relay_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.relay_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_CHOKE_VOLTAGE`)
            data.choke_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.choke_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_CHOKE_VOLTAGE`)
            data.choke_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.choke_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_BATTERY_CHARGER_DC_VOLTAGE`)
            data.battery_charger_dc_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_dc_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_BATTERY_CHARGER_DC_VOLTAGE`)
            data.battery_charger_dc_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_dc_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_BATTERY_CHARGER_DC_CURRENT`)
            data.battery_charger_dc_current < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_dc_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_BATTERY_CHARGER_DC_CURRENT`)
            data.battery_charger_dc_current > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_dc_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_BATTERY_CHARGER_AC_VOLTAGE`)
            data.battery_charger_ac_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_ac_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_BATTERY_CHARGER_AC_VOLTAGE`)
            data.battery_charger_ac_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_ac_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_BATTERY_CHARGER_AC_CURRENT`)
            data.battery_charger_ac_current < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_ac_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_BATTERY_CHARGER_AC_CURRENT`)
            data.battery_charger_ac_current > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.battery_charger_ac_current, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MIN_TRACK_RELAY_VOLTAGE`)
            data.trv < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.trv, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@MAX_TRACK_RELAY_VOLTAGE`)
            data.trv > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.trv, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${trackcircuitid}@${assertname}@CRITICAL_RELAY_VOLTAGE`)
            data.relay_voltage < parseFloat(alert_name_values.value) && data.feed_current > parseFloat(await get_alert_value(`${station_id}@${trackcircuitid}@${assertname}@CRITICAL_FEED_CURRENT`) && alert_name_values.isactive) === true ?
                track_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.relay_voltage, alert_name_values.unit) + " and " + await get_alert_message(`${station_id}@${trackcircuitid}@${assertname}@CRITICAL_FEED_CURRENT`, data.feed_current), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            var result = lodash.filter(track_check, function (o) { return o.result; });
            let alert_data = {}

            if (result.length > 0) {
                alert_message = result.map(item => item.message).join(' ; ')
            }

            if (alert_message != "") {
                let alertid = ""
                alert_data = {
                    trackcircuitid: parseInt(data.trackcircuitid),
                    trackcircuitdataid: dataid,
                    stationid: data.stationid,
                    message: alert_message,
                    assertid: data.assertid,
                    createddate: data.createddate,
                    isdele: false
                }

                const alertinsert = await TrackCircuitAlert.create(alert_data, { transaction: transaction }).then(res => alertid = res.id)
                //logs.info(`station trackcircuit alert ended`);
                //console.log(`station trackcircuit alert ended`); 

                var get_users = await NotificationControl.findAll({ where: { assertsid: data.assertid, stationid: data.stationid, isdele: false } })
                var get_users_id = lodash.uniq(get_users.map(item => item.userid))

                let notification_data = []
                let mobile_notification_data = []

                for (let i = 0; i < get_users_id.length; i++) {

                    const get_previous_notification = await NotificationSend.findOne({
                        where: { stationid: data.stationid, assertsid: data.assertid, userid: get_users_id[i], isseen: false, isdele: false },
                        order: [["id", "DESC"]]
                    })

                    if (get_previous_notification == null) {
                        notification_data.push({
                            stationid: data.stationid,
                            assertsid: data.assertid,
                            alertid: alertid,
                            userid: get_users_id[i],
                            isseen: false,
                            issend: false,
                            createddate: data.createddate,
                            isdele: false
                        })

                        mobile_notification_data.push({
                            stationid: data.stationid,
                            stationcode: data.stationcode,
                            stationname: data.stationname,
                            assertname: data.assertname,
                            assertidname: data.trackname,
                            message: alert_data.message,
                            alertid: alertid,
                            userid: get_users_id[i],
                            isseen: false,
                            issend: false,
                            createddate: data.createddate,
                        })
                    }
                    else {
                        const get_previous_alert = await TrackCircuitAlert.findOne({
                            where: { id: get_previous_notification.alertid, isdele: false },
                        })

                        if (get_previous_alert != null) {
                            let alert_check = false
                            if (alert_data.message.indexOf(';') == 1 && get_previous_alert.message.indexOf(';') == -1 || alert_data.message.indexOf(';') == -1 && get_previous_alert.message.indexOf(';') == 1) {
                                alert_check = false
                            }
                            else {

                                alert_check = get_previous_alert.message.includes("Over Voltage in TF(Vdc)-") === true
                                    && alert_data.message.includes("Over Voltage in TF(Vdc)-") === true
                                    ? true :
                                    get_previous_alert.message.includes("Under Voltage in TF(Vdc)-") === true
                                        && alert_data.message.includes("Under Voltage in TF(Vdc)-") === true
                                        ? true :

                                        get_previous_alert.message.includes("Over Current in TF(Idc)-") === true
                                            && alert_data.message.includes("Over Current in TF(Idc)-") === true
                                            ? true :
                                            get_previous_alert.message.includes("Under Current in TF(Idc)-") === true
                                                && alert_data.message.includes("Under Current in TF(Idc)-") === true
                                                ? true :

                                                get_previous_alert.message.includes("Over Voltage in TF Choke(Vdc)-") === true
                                                    && alert_data.message.includes("Over Voltage in TF Choke(Vdc)-") === true
                                                    ? true :
                                                    get_previous_alert.message.includes("Under Voltage in TF Choke(Vdc)-") === true
                                                        && alert_data.message.includes("Under Voltage in TF Choke(Vdc)-") === true
                                                        ? true :

                                                        get_previous_alert.message.includes("Over Current in Charger-") === true
                                                            && alert_data.message.includes("Over Current in Charger-") === true
                                                            ? true :
                                                            get_previous_alert.message.includes("Under Current in Charger-") === true
                                                                && alert_data.message.includes("Under Current in Charger-") === true
                                                                ? true :

                                                                get_previous_alert.message.includes("Over Voltage in TR(Vdc)-") === true
                                                                    && alert_data.message.includes("Over Voltage in TR(Vdc)-") === true
                                                                    ? true :
                                                                    get_previous_alert.message.includes("Under Voltage in TR(Vdc)-") === true
                                                                        && alert_data.message.includes("Under Voltage in TR(Vdc)-") === true
                                                                        ? true :

                                                                        get_previous_alert.message.includes("Over Current in TR(Idc)-") === true
                                                                            && alert_data.message.includes("Over Current in TR(Idc)-") === true
                                                                            ? true :
                                                                            get_previous_alert.message.includes("Under Current in TR(Idc)-") === true
                                                                                && alert_data.message.includes("Under Current in TR(Idc)-") === true
                                                                                ? true :

                                                                                get_previous_alert.message.includes("Over Voltage in TRV Voltage-") === true
                                                                                    && alert_data.message.includes("Over Voltage in TRV Voltage-") === true
                                                                                    ? true :
                                                                                    get_previous_alert.message.includes("Under Voltage in TRV Voltage-") === true
                                                                                        && alert_data.message.includes("Under Voltage in TRV Voltage-") === true
                                                                                        ? true :

                                                                                        get_previous_alert.message.includes("Critical Alert For Index Score-") === true
                                                                                            && alert_data.message.includes("Critical Alert For Index Score-") === true
                                                                                            ? true : false

                            }


                            if (alert_check === false) {
                                notification_data.push({
                                    stationid: data.stationid,
                                    assertsid: data.assertid,
                                    alertid: alertid,
                                    userid: get_users_id[i],
                                    isseen: false,
                                    issend: false,
                                    createddate: data.createddate,
                                    isdele: false
                                })

                                mobile_notification_data.push({
                                    stationid: data.stationid,
                                    stationcode: data.stationcode,
                                    stationname: data.stationname,
                                    assertname: data.assertname,
                                    assertidname: data.trackname,
                                    message: alert_data.message,
                                    alertid: alertid,
                                    userid: get_users_id[i],
                                    isseen: false,
                                    issend: false,
                                    createddate: data.createddate,
                                })

                            }
                        }
                    }
                }
                if (notification_data.length > 0) {
                    const notifiyinsert = await NotificationSend.bulkCreate(notification_data, { transaction: transaction })
                    Socket.emit('Notification', notification_data);
                    //socketcloud.emit("Notification", mobile_notification_data)
                }
            }

            let data_logs = {
                id: dataid,
                trackcircuitid: parseInt(data.trackcircuitid),
                trackname: data.trackname,
                feed_count: data.feed_count,
                feed_current: data.feed_current,
                feed_voltage: data.feed_voltage,
                choke_voltage: data.choke_voltage,
                charger: data.charger,
                relay_count: data.relay_count,
                relay_current: data.relay_current,
                relay_voltage: data.relay_voltage,
                trv: data.trv,
                index_score: data.index_score,
                leakage_current: data.leakage_current,
                health: data.health,
                track_OC: data.track_OC,
                createddate: data.createddate,
                time: moment(data.createddate).format("HH:mm:ss"),
                isdele: false
            }

            // //commented it out because not using now
            // let tracks = []
            // tracks.push({
            //     id: parseInt(data.trackcircuitid),
            //     trackname: data.trackname,
            //     feed_count: data.feed_count,
            //     feed_current: data.feed_current,
            //     feed_voltage: data.feed_voltage,
            //     choke_voltage: data.choke_voltage,
            //     relay_count: data.relay_count,
            //     charger: data.charger,
            //     relay_current: data.relay_current,
            //     relay_voltage: data.relay_voltage,
            //     trv: data.trv,
            //     index_score: data.index_score,
            //     leakage_current: data.leakage_current,
            //     health: data.health,
            //     track_OC: data.track_OC,
            //     createddate: data.createddate,
            // })

            // var trackcircuits = await RegisteredTrackCircuit.findAll({ where: { isdele: false, stationid: data.stationid } })
            // for (let i = 0; i < trackcircuits.length; i++) {
            //     let element = trackcircuits[i]
            //     var get_finaltrackcircuit_datas = [await TrackCircuitData.findOne({ limit: 1, where: { isdele: false, trackcircuitid: element.id }, order: [["id", "DESC"]] })];
            //     get_finaltrackcircuit_datas = get_finaltrackcircuit_datas[0] !== null ? get_finaltrackcircuit_datas : []
            //     if (get_finaltrackcircuit_datas.length > 0 && element.id != parseInt(data.trackcircuitid)) {
            //         tracks.push({
            //             id: element.id,
            //             trackname: element.trackname,
            //             feed_count: get_finaltrackcircuit_datas[0].feed_count,
            //             feed_current: get_finaltrackcircuit_datas[0].feed_current,
            //             feed_voltage: get_finaltrackcircuit_datas[0].feed_voltage,
            //             choke_voltage: get_finaltrackcircuit_datas[0].choke_voltage,
            //             relay_count: get_finaltrackcircuit_datas[0].relay_count,
            //             charger: get_finaltrackcircuit_datas[0].charger,
            //             relay_current: get_finaltrackcircuit_datas[0].relay_current,
            //             relay_voltage: get_finaltrackcircuit_datas[0].relay_voltage,
            //             trv: get_finaltrackcircuit_datas[0].trv,
            //             index_score: get_finaltrackcircuit_datas[0].index_score,
            //             leakage_current: get_finaltrackcircuit_datas[0].leakage_current,
            //             health: get_finaltrackcircuit_datas[0].health,
            //             track_OC: get_finaltrackcircuit_datas[0].track_OC,
            //             createddate: get_finaltrackcircuit_datas[0].createddate,
            //         })
            //     }
            // }

            let socket_data = {
                data_logs: data_logs,
                // tracks: tracks,
                alerts: [alert_data]
            }
            await transaction.commit();
            //logs.info('track_socket_data',socket_data) 
            Socket.emit("trackcircuitdata", socket_data)
            //socketcloud.emit("Track", socket_data)

        } catch (ex) {
            await transaction.rollback();
            logs.error('station track circuit data error' + ex);
            //console.log('station track circuit data error' + ex);
        }
    }

    // Inactive - Point Machine 1AB Data
    async function insert_pointmachine1(datas, data, dataid) {
        logs.info('insert point machine alert started');
        //console.log('insert point machine alert started');
        let transaction = await db.transaction({ autocommit: false });
        try {
            alert_value_list = require("./alertvalue").getValues();
            let point_check = [];
            let station_id = datas.stationid
            let pointmachineid = datas.pointmachineid
            let assertname = datas.assertname

            //point_check
            var alert_name_values = data.a_direction == 'Normal' ? await get_alerts(`${station_id}@${pointmachineid}@${assertname}@NORMAL_DIRECTION`) : data.b_direction == 'Reverse' ? await get_alerts(`${station_id}@${pointmachineid}@${assertname}@REVERSE_DIRECTION`) : null
            if (alert_name_values != null) {
                data.a_cyclecount > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                    point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.a_cyclecount, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""
            }

            alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_A_CURRENT_MAX`)
            data.a_current_max < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.a_current_max, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_A_CURRENT_MAX`)
            data.a_current_max > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.a_current_max, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_A_CURRENT_AVG`)
            data.a_current_avg < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.a_current_avg, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_A_CURRENT_AVG`)
            data.a_current_avg > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.a_current_avg, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_A_VOLTAGE`)
            data.a_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.a_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_A_VOLTAGE`)
            data.a_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.a_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_INDICATION_A_VOLTAGE`)
            data.a_indication_voltage < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.a_indication_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_INDICATION_A_VOLTAGE`)
            data.a_indication_voltage > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.a_indication_voltage, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""

            alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_A_TIME`)
            data.a_time < parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.a_time, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) :

                alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_A_TIME`)
            data.a_time > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ?
                point_check.push({ result: true, message: await combine_mes_val_unit(alert_name_values.message, data.a_time, alert_name_values.unit), mode: alert_name_values.mode, id: alert_name_values.id }) : ""


            // Currently only one pointmachine present //
            // alert_name_values = data.a_direction == 'Normal' ? await get_alerts(`${station_id}@${pointmachineid}@${assertname}@NORMAL_DIRECTION`) : data.b_direction == 'Reverse' ? await get_alerts(`${station_id}@${pointmachineid}@${assertname}@REVERSE_DIRECTION`) : null
            // if(alert_name_values != null)
            // {
            //     data.b_cyclecount > parseFloat(alert_name_values.value) && alert_name_values.isactive === true ? 
            //     point_check.push({result : true, message: await combine_mes_val_unit(alert_name_values.message, data.b_cyclecount, alert_name_values.unit), mode : alert_name_values.mode, id: alert_name_values.id}) : ""
            // }

            // alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_B_CURRENT_MAX`)
            // data.b_current_max <  parseFloat(alert_name_values.value) && alert_name_values.isactive === true ? 
            // point_check.push({result : true,  message: await combine_mes_val_unit(alert_name_values.message, data.b_current_max, alert_name_values.unit), mode : alert_name_values.mode, id: alert_name_values.id}) :

            // alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_B_CURRENT_MAX`)
            // data.b_current_max >  parseFloat(alert_name_values.value) && alert_name_values.isactive === true ? 
            // point_check.push({result : true,  message: await combine_mes_val_unit(alert_name_values.message, data.b_current_max, alert_name_values.unit), mode : alert_name_values.mode, id: alert_name_values.id}) : ""

            // alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_B_CURRENT_AVG`)
            // data.b_current_avg <  parseFloat(alert_name_values.value) && alert_name_values.isactive === true ? 
            // point_check.push({result : true,  message: await combine_mes_val_unit(alert_name_values.message, data.b_current_avg, alert_name_values.unit), mode : alert_name_values.mode, id: alert_name_values.id}) :        

            // alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_B_CURRENT_AVG`)
            // data.b_current_avg >  parseFloat(alert_name_values.value) && alert_name_values.isactive === true ? 
            // point_check.push({result : true,  message: await combine_mes_val_unit(alert_name_values.message, data.b_current_avg, alert_name_values.unit), mode : alert_name_values.mode, id: alert_name_values.id}) :""

            // alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_B_VOLTAGE`)
            // data.b_voltage <  parseFloat(alert_name_values.value) && alert_name_values.isactive === true ? 
            // point_check.push({result : true,  message: await combine_mes_val_unit(alert_name_values.message, data.b_voltage, alert_name_values.unit),mode : alert_name_values.mode, id: alert_name_values.id}) :       

            // alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_B_VOLTAGE`)
            // data.b_voltage >  parseFloat(alert_name_values.value) && alert_name_values.isactive === true ? 
            // point_check.push({result : true,  message: await combine_mes_val_unit(alert_name_values.message, data.b_voltage, alert_name_values.unit), mode : alert_name_values.mode, id: alert_name_values.id}) :""            

            // alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_INDICATION_B_VOLTAGE`)
            // data.b_indication_voltage <  parseFloat(alert_name_values.value) && alert_name_values.isactive === true ? 
            // point_check.push({result : true,  message: await combine_mes_val_unit(alert_name_values.message, data.b_indication_voltage, alert_name_values.unit),mode : alert_name_values.mode, id: alert_name_values.id}) :

            // alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_INDICATION_B_VOLTAGE`)
            // data.b_indication_voltage >  parseFloat(alert_name_values.value) && alert_name_values.isactive === true ? 
            // point_check.push({result : true,  message: await combine_mes_val_unit(alert_name_values.message, data.b_indication_voltage, alert_name_values.unit),mode : alert_name_values.mode, id: alert_name_values.id}) :""

            // alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MIN_OPERATING_B_TIME`)
            // data.b_time <  parseFloat(alert_name_values.value) && alert_name_values.isactive === true ? 
            // point_check.push({result : true,  message: await combine_mes_val_unit(alert_name_values.message, data.b_time, alert_name_values.unit), mode : alert_name_values.mode, id: alert_name_values.id}) :

            // alert_name_values = await get_alerts(`${station_id}@${pointmachineid}@${assertname}@MAX_OPERATING_B_TIME`)
            // data.b_time >  parseFloat(alert_name_values.value) && alert_name_values.isactive === true ? 
            // point_check.push({result : true,  message: await combine_mes_val_unit(alert_name_values.message, data.b_time, alert_name_values.unit), mode : alert_name_values.mode, id: alert_name_values.id}) :""

            var result = lodash.filter(point_check, function (o) { return o.result; });
            var mode_filtered = lodash.groupBy(point_check, function (o) { return o.mode });

            let alert_data = {}
            let alert_logs = []
            let alert_modeid = 0

            let mobile_notification_data = []

            if (result.length > 0) {
                for (var property in mode_filtered) {
                    let alertid = ""
                    let modeid = lodash.result(lodash.find(AlertModes, { 'mode': property }), 'id')
                    alert_modeid = alert_modeid == null ? modeid : alert_modeid > modeid ? alert_modeid : modeid

                    alert_data = {
                        pointmachineid: parseInt(data.pointmachineid),
                        pointmachinedataid: dataid,
                        stationid: datas.stationid,
                        message: mode_filtered[property].map(item => item.message).join(' ; '),
                        assertid: datas.assertid,
                        modeid: modeid,
                        mode: property,
                        createddate: datas.createddate,
                        isdele: false
                    }
                    alert_logs.push(alert_data)

                    const alertinsert = await PointMachineAlert.create(alert_data, { transaction: transaction }).then(res => alertid = res.id)
                    //logs.info(`station pointmachine alert ended`);
                    //console.log(`station pointmachine alert ended`); 

                    var get_users = await NotificationControl.findAll({ where: { assertsid: datas.assertid, stationid: datas.stationid, isdele: false } })
                    var get_users_id = lodash.uniq(get_users.map(item => item.userid))

                    let alert_message_ids = lodash.uniq(mode_filtered[property].map(i => i.id)).sort((a, b) => a - b)
                    for (let i = 0; i < get_users_id.length; i++) {
                        const get_previous_notification = await NotificationSend.findOne({
                            where: { stationid: datas.stationid, assertsid: datas.assertid, alertmessageids: alert_message_ids, modeid: modeid, userid: get_users_id[i], isseen: false, isdele: false },
                            order: [["id", "DESC"]]
                        })

                        if (get_previous_notification == null) {

                            mobile_notification_data.push({
                                stationid: datas.stationid,
                                stationcode: datas.stationcode,
                                stationname: datas.stationname,
                                assertname: datas.assertname,
                                assertsid: datas.assertid,
                                assertidname: datas.pointmachinename,
                                alertid: alertid,
                                userid: get_users_id[i],
                                message: alert_data.message,
                                modeid: modeid,
                                mode: property,
                                alertmessageids: alert_message_ids,
                                isseen: false,
                                issend: false,
                                createddate: datas.createddate,
                            })
                        }
                    }
                }

                if (mobile_notification_data.length > 0) {
                    const notifiyinsert = await NotificationSend.bulkCreate(mobile_notification_data, { transaction: transaction })
                    Socket.emit('Notification', mobile_notification_data);
                    //socketcloud.emit("Notification", mobile_notification_data)
                }
            }

            let data_logs = {
                id: dataid,
                pointmachineid: parseInt(datas.pointmachineid),
                pointmachinename: datas.pointmachinename,
                direction: data.direction,
                pointcyclecount: data.pointcyclecount,
                a_direction: data.a_direction,
                a_cyclecount: data.a_cyclecount,
                a_indication_voltage: data.a_indication_voltage,
                a_current_max: data.a_current_max,
                a_current_avg: data.a_current_avg,
                a_voltage: data.a_voltage,
                a_time: data.a_time,
                a_vibration_x: data.a_vibration_x,
                a_vibration_y: data.a_vibration_y,
                a_vibration_z: data.a_vibration_z,
                b_direction: data.b_direction,
                b_cyclecount: data.b_cyclecount,
                b_indication_voltage: data.b_indication_voltage,
                b_current_max: data.b_current_max,
                b_current_avg: data.b_current_avg,
                b_voltage: data.b_voltage,
                b_time: data.b_time,
                b_vibration_x: data.b_vibration_x,
                b_vibration_y: data.b_vibration_y,
                b_vibration_z: data.b_vibration_z,
                log: data.log,
                createddate: data.createddate,
                time: moment(data.createddate).format("HH:mm:ss"),
                isdele: data.isdele
            }

            //commented it out because not using now
            // let points = []
            // points.push({
            //     id : parseInt(data.pointmachineid),
            //     pointmachinename : datas.pointmachinename,
            //     direction : data.direction,
            //     pointcyclecount : data.pointcyclecount,
            //     a_direction : data.a_direction,
            //     a_cyclecount : data.a_cyclecount,
            //     a_indication_voltage : data.a_indication_voltage,
            //     a_current_max :  data.a_current_max,
            //     a_current_avg : data.a_current_avg,
            //     a_voltage :  data.a_voltage,
            //     a_time :  data.a_time,
            //     a_vibration_x : data.a_vibration_x,
            //     a_vibration_y : data.a_vibration_y,
            //     a_vibration_z : data.a_vibration_z,
            //     b_direction : data.b_direction,
            //     b_cyclecount : data.b_cyclecount,
            //     b_indication_voltage : data.b_indication_voltage,
            //     b_current_max : data.b_current_max,
            //     b_current_avg : data.b_current_avg,
            //     b_voltage : data.b_voltage,
            //     b_time : data.b_time,
            //     b_vibration_x : data.b_vibration_x,
            //     b_vibration_y : data.b_vibration_y,
            //     b_vibration_z: data.b_vibration_z,
            //     log : data.log,
            //     createddate : data.createddate,
            //     isdele : data.isdele
            // })        
            // var pointmachines = await RegisteredPointMachine.findAll({where:{isdele:false, stationid:datas.stationid}})            
            // for(let i=0 ; i < pointmachines.length;i++ )
            // {
            //     let element =  pointmachines[i]
            //   var get_finalpointmachines_datas = [await PointMachineData.findOne({limit : 1, where :{isdele : false, pointmachineid:element.id}, order : [["id","DESC"]]})];
            //   get_finalpointmachines_datas = get_finalpointmachines_datas[0] !== null ? get_finalpointmachines_datas : []
            //   if(get_finalpointmachines_datas.length > 0 && element.id != parseInt(datas.pointmachineid))
            //   {
            //     points.push({
            //       id : element.id,
            //       pointmachinename : element.pointmachinename,
            //       direction : get_finalpointmachines_datas[0].direction,
            //       pointcyclecount : get_finalpointmachines_datas[0].pointcyclecount,
            //       a_direction : get_finalpointmachines_datas[0].a_direction,
            //       a_cyclecount : get_finalpointmachines_datas[0].a_cyclecount,
            //       a_indication_voltage : get_finalpointmachines_datas[0].a_indication_voltage,
            //       a_current_max :  get_finalpointmachines_datas[0].a_current_max,
            //       a_current_avg : get_finalpointmachines_datas[0].a_current_avg,
            //       a_voltage :  get_finalpointmachines_datas[0].a_voltage,
            //       a_time :  get_finalpointmachines_datas[0].a_time,
            //       a_vibration_x : get_finalpointmachines_datas[0].a_vibration_x,
            //       a_vibration_y : get_finalpointmachines_datas[0].a_vibration_y,
            //       a_vibration_z : get_finalpointmachines_datas[0].a_vibration_z,
            //       b_direction : get_finalpointmachines_datas[0].b_direction,
            //       b_cyclecount : get_finalpointmachines_datas[0].b_cyclecount,
            //       b_indication_voltage : get_finalpointmachines_datas[0].b_indication_voltage,
            //       b_current_max : get_finalpointmachines_datas[0].b_current_max,
            //       b_current_avg : get_finalpointmachines_datas[0].b_current_avg,
            //       b_voltage : get_finalpointmachines_datas[0].b_voltage,
            //       b_time : get_finalpointmachines_datas[0].b_time,
            //       b_vibration_x : get_finalpointmachines_datas[0].b_vibration_x,
            //       b_vibration_y : get_finalpointmachines_datas[0].b_vibration_y,
            //       b_vibration_z: get_finalpointmachines_datas[0].b_vibration_z,
            //       log : get_finalpointmachines_datas[0].log,
            //       createddate : get_finalpointmachines_datas[0].createddate,
            //       isdele : get_finalpointmachines_datas[0].isdele
            //   })
            //   }   
            // }

            let socket_data = {
                data_logs: data_logs,
                // points : points,  
                alertmodeid: alert_logs.length > 0 ? alert_modeid : null,
                alerts: alert_logs
            }
            await transaction.commit();
            //logs.info('point_machine_socket_data',socket_data)
            Socket.emit("pointmachinedata", socket_data)
            //socketcloud.emit("Point", socket_data)

        } catch (ex) {
            await transaction.rollback();
            logs.error('station point machine data error' + ex);
            //console.log('station point machine data error' + ex);
        }
    }

    // InActive - old - Signal Circuit Data
    async function insert_signalcircuit1(data) {
        logs.info(`station signalcircuit alert started`);
        //console.log(`station signalcircuit alert started`);
        let transaction = await db.transaction({ autocommit: false });
        try {

            alert_value_list = require("./alertvalue").getValues();
            let station_id = data.stationid
            let signalcircuitid = data.signalcircuitid
            let aspecttypeid = data.aspecttypeid
            let assertname = data.assertname
            let aspectcurrent = 0
            let aspectvoltage = 0
            let gui = 0
            let index_score = 5

            let glow_check = []
            let error_voltage_data = []
            let error_current_data = []

            //get for only one light glows based on min and max conditions
            //logs.info(`signal cirucit glow result check`);
            //console.log(`signal cirucit glow result check`);

            var alert_minvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@MIN_ASPECT_VOLTAGE`)
            var alert_maxvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@MAX_ASPECT_VOLTAGE`)
            var alert_mincur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@MIN_ASPECT_CURRENT`)
            var alert_maxcur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@MAX_ASPECT_CURRENT`)

            var alert_rgmincur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@RG_CURRENT_MIN`)
            var alert_dgmincur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@DG_CURRENT_MIN`)
            var alert_hgmincur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HG_CURRENT_MIN`)
            var alert_hhgmincur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HHG_CURRENT_MIN`)

            var alert_rgmaxcur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@RG_CURRENT_MAX`)
            var alert_dgmaxcur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@DG_CURRENT_MAX`)
            var alert_hgmaxcur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HG_CURRENT_MAX`)
            var alert_hhgmaxcur_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HHG_CURRENT_MAX`)

            var alert_rgminvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@RG_VOLTAGE_MIN`)
            var alert_dgminvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@DG_VOLTAGE_MIN`)
            var alert_hgminvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HG_VOLTAGE_MIN`)
            var alert_hhgminvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HHG_VOLTAGE_MIN`)

            var alert_rgmaxvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@RG_VOLTAGE_MAX`)
            var alert_dgmaxvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@DG_VOLTAGE_MAX`)
            var alert_hgmaxvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HG_VOLTAGE_MAX`)
            var alert_hhgmaxvol_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HHG_VOLTAGE_MAX`)

            var alert_rgdg_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@RG_DG`)
            var alert_rghg_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@RG_HG`)
            var alert_rghhg_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@RG_HHG`)
            var alert_dghg_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@DG_HG`)
            var alert_dghhg_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@DG_HHG`)
            var alert_hghhg_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@HG_HHG`)

            var alert_message_mode = []

            var alert_off_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@SIGNAL_BLANK_ALERT`)
            var alert_on_values = await get_alerts(`${station_id}@${signalcircuitid}@${assertname}@SIGNAL_GLOW_ALERT`)

            data.redvoltage >= parseFloat(alert_minvol_values.value) && data.redvoltage <= parseFloat(alert_maxvol_values.value) && data.redcurrent >= parseFloat(alert_mincur_values.value) && data.redcurrent <= parseFloat(alert_maxcur_values.value)
                ? glow_check.push({ result: true, voltage: data.redvoltage, current: data.redcurrent, gui: 1 }) : ""

            data.greenvoltage >= parseFloat(alert_minvol_values.value) && data.greenvoltage <= parseFloat(alert_maxvol_values.value) && data.greencurrent >= parseFloat(alert_mincur_values.value) && data.greencurrent <= parseFloat(alert_maxcur_values.value)
                ? glow_check.push({ result: true, voltage: data.greenvoltage, current: data.greencurrent, gui: 2 }) : ""

            data.yellowvoltage >= parseFloat(alert_minvol_values.value) && data.yellowvoltage <= parseFloat(alert_maxvol_values.value) && data.yellowcurrent >= parseFloat(alert_mincur_values.value) && data.yellowcurrent <= parseFloat(alert_maxcur_values.value)
                ? glow_check.push({ result: true, voltage: data.yellowvoltage, current: data.yellowcurrent, gui: 3 }) : ""

            if (data.terminal === 'B') {
                data.lightyellowvoltage >= parseFloat(alert_minvol_values.value) && data.lightyellowvoltage <= parseFloat(alert_maxvol_values.value) && data.lightyellowcurrent >= parseFloat(alert_mincur_values.value) && data.lightyellowcurrent <= parseFloat(alert_maxcur_values.value)
                    ? glow_check.push({ result: true, voltage: data.lightyellowvoltage, current: data.lightyellowcurrent, gui: 4 }) : ""
            }

            //check for only current
            //logs.info(`signal cirucit current error check`);
            //console.log(`signal cirucit current error check`);

            data.redvoltage >= parseFloat(alert_minvol_values.value) && data.redvoltage <= parseFloat(alert_maxvol_values.value)
                ? data.redcurrent < parseFloat(alert_mincur_values.value) && alert_rgmincur_values.isactive === true
                    ? error_current_data.push({ message: await combine_mes_val_unit(alert_rgmincur_values.message, data.redcurrent, alert_rgmincur_values.unit), voltage: data.redvoltage, current: data.redcurrent, max_current: data.redcurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: data.redcurrent < parseFloat(alert_mincur_values.value) ? true : false, gui: 1, id: alert_rgmincur_values.id, mode: alert_rgmincur_values.mode })
                    : data.redcurrent > parseFloat(alert_maxcur_values.value) && alert_rgmaxcur_values.isactive === true
                        ? error_current_data.push({ message: await combine_mes_val_unit(alert_rgmaxcur_values.message, data.redcurrent, alert_rgmaxcur_values.unit), voltage: data.redvoltage, current: data.redcurrent, max_current: data.redcurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: false, gui: 1, id: alert_rgmaxcur_values.id, mode: alert_rgmaxcur_values.mode })
                        : "" : ""

            data.greenvoltage >= parseFloat(alert_minvol_values.value) && data.greenvoltage <= parseFloat(alert_maxvol_values.value)
                ? data.greencurrent < parseFloat(alert_mincur_values.value) && alert_dgmincur_values.isactive === true
                    ? error_current_data.push({ message: await combine_mes_val_unit(alert_dgmincur_values.message, data.greencurrent, alert_dgmincur_values.unit), voltage: data.greenvoltage, current: data.greencurrent, max_current: data.greencurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: data.greencurrent < parseFloat(alert_mincur_values.value) ? true : false, gui: 2, id: alert_dgmincur_values.id, mode: alert_dgmincur_values.mode })
                    : data.greencurrent > parseFloat(alert_maxcur_values.value) && alert_dgmaxcur_values.isactive === true
                        ? error_current_data.push({ message: await combine_mes_val_unit(alert_dgmaxcur_values.message, data.greencurrent, alert_dgmaxcur_values.unit), voltage: data.greenvoltage, current: data.greencurrent, max_current: data.greencurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: false, gui: 2, id: alert_dgmaxcur_values.id, mode: alert_dgmaxcur_values.mode })
                        : "" : ""

            data.yellowvoltage >= parseFloat(alert_minvol_values.value) && data.yellowvoltage <= parseFloat(alert_maxvol_values.value)
                ? data.yellowcurrent < parseFloat(alert_mincur_values.value) && alert_hgmincur_values.isactive === true
                    ? error_current_data.push({ message: await combine_mes_val_unit(alert_hgmincur_values.message, data.yellowcurrent, alert_hgmincur_values.unit), voltage: data.yellowvoltage, current: data.yellowcurrent, max_current: data.yellowcurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: data.yellowcurrent < parseFloat(alert_mincur_values.value) ? true : false, gui: 3, id: alert_hgmincur_values.id, mode: alert_hgmincur_values.mode })
                    : data.yellowcurrent > parseFloat(alert_maxcur_values.value) && alert_hgmaxcur_values.isactive === true
                        ? error_current_data.push({ message: await combine_mes_val_unit(alert_hgmaxcur_values.message, data.yellowcurrent, alert_hgmaxcur_values.unit), voltage: data.yellowvoltage, current: data.yellowcurrent, max_current: data.yellowcurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: false, gui: 3, id: alert_hgmaxcur_values.id, mode: alert_hgmaxcur_values.mode })
                        : "" : ""

            if (data.terminal === 'B') {
                data.lightyellowvoltage >= parseFloat(alert_minvol_values.value) && data.lightyellowvoltage <= parseFloat(alert_maxvol_values.value)
                    ? data.lightyellowcurrent < parseFloat(alert_mincur_values.value) && alert_hhgmincur_values.isactive === true
                        ? error_current_data.push({ message: await combine_mes_val_unit(alert_hhgmincur_values.message, data.lightyellowcurrent, alert_hhgmincur_values.unit), voltage: data.lightyellowvoltage, current: data.lightyellowcurrent, max_current: data.lightyellowcurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: data.lightyellowcurrent < parseFloat(alert_mincur_values.value) ? true : false, gui: 3, id: alert_hhgmincur_values.id, mode: alert_hhgmincur_values.mode })
                        : data.lightyellowcurrent > parseFloat(alert_maxcur_values.value) && alert_hhgmaxcur_values.isactive === true
                            ? error_current_data.push({ message: await combine_mes_val_unit(alert_hhgmaxcur_values.message, data.lightyellowcurrent, alert_hhgmaxcur_values.unit), voltage: data.lightyellowvoltage, current: data.lightyellowcurrent, max_current: data.lightyellowcurrent > parseFloat(alert_maxcur_values.value) ? true : false, min_current: false, gui: 3, id: alert_hhgmaxcur_values.id, mode: alert_hhgmaxcur_values.mode })
                            : "" : ""
            }

            //check for only voltage
            //logs.info(`signal cirucit voltage error check`);
            //console.log(`signal cirucit voltage error check`);

            data.redcurrent >= parseFloat(alert_mincur_values.value) && data.redcurrent <= parseFloat(alert_maxcur_values.value)
                ? data.redvoltage < parseFloat(alert_minvol_values.value) && alert_rgminvol_values.isactive === true
                    ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_rgminvol_values.message, data.redvoltage, alert_rgminvol_values.unit), voltage: data.redvoltage, current: data.redcurrent, max_voltage: data.redvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: data.redvoltage < parseFloat(alert_minvol_values.value) ? true : false, gui: 1, id: alert_rgminvol_values.id, mode: alert_rgminvol_values.mode })
                    : data.redvoltage > parseFloat(alert_maxvol_values.value) && alert_rgmaxvol_values.isactive === true
                        ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_rgmaxvol_values.message, data.redvoltage, alert_rgmaxvol_values.unit), voltage: data.redvoltage, current: data.redcurrent, max_voltage: data.redvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: false, gui: 1, id: alert_rgmaxvol_values.id, mode: alert_rgmaxvol_values.mode })
                        : "" : ""

            data.greencurrent >= parseFloat(alert_mincur_values.value) && data.greencurrent <= parseFloat(alert_maxcur_values.value)
                ? data.greenvoltage < parseFloat(alert_minvol_values.value) && alert_dgminvol_values.isactive === true
                    ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_dgminvol_values.message, data.greenvoltage, alert_dgminvol_values.unit), voltage: data.greenvoltage, current: data.greencurrent, max_voltage: data.greenvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: data.greenvoltage < parseFloat(alert_minvol_values.value) ? true : false, gui: 2, id: alert_dgminvol_values.id, mode: alert_dgminvol_values.mode })
                    : data.greenvoltage > parseFloat(alert_maxvol_values.value) && alert_dgmaxvol_values.isactive === true
                        ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_dgmaxvol_values.message, data.greenvoltage, alert_dgmaxvol_values.unit), voltage: data.greenvoltage, current: data.greencurrent, max_voltage: data.greenvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: false, gui: 2, id: alert_dgmaxvol_values.id, mode: alert_dgmaxvol_values.mode })
                        : "" : ""

            data.yellowcurrent >= parseFloat(alert_mincur_values.value) && data.yellowcurrent <= parseFloat(alert_maxcur_values.value)
                ? data.yellowvoltage < parseFloat(alert_minvol_values.value) && alert_hgminvol_values.isactive === true
                    ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_hgminvol_values.message, data.yellowvoltage, alert_hgminvol_values.unit), voltage: data.yellowvoltage, current: data.yellowcurrent, max_voltage: data.yellowvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: data.yellowvoltage < parseFloat(alert_minvol_values.value) ? true : false, gui: 3, id: alert_hgminvol_values.id, mode: alert_hgminvol_values.mode })
                    : data.yellowvoltage > parseFloat(alert_maxvol_values.value) && alert_hgmaxvol_values.isactive === true
                        ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_hgmaxvol_values.message, data.yellowvoltage, alert_hgmaxvol_values.unit), voltage: data.yellowvoltage, current: data.yellowcurrent, max_voltage: data.yellowvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: false, gui: 3, id: alert_hgmaxvol_values.id, mode: alert_hgmaxvol_values.mode })
                        : "" : ""

            if (data.terminal === 'B') {
                data.lightyellowcurrent >= parseFloat(alert_mincur_values.value) && data.lightyellowcurrent <= parseFloat(alert_maxcur_values.value)
                    ? data.lightyellowvoltage < parseFloat(alert_minvol_values.value) && alert_hhgminvol_values.isactive === true
                        ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_hhgminvol_values.message, data.lightyellowvoltage, alert_hhgminvol_values.unit), voltage: data.lightyellowvoltage, current: data.lightyellowcurrent, max_voltage: data.lightyellowvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: data.lightyellowvoltage < parseFloat(alert_minvol_values.value) ? true : false, gui: 3, id: alert_hhgminvol_values.id, mode: alert_hhgminvol_values.mode })
                        : data.lightyellowvoltage > parseFloat(alert_maxvol_values.value) && alert_hhgmaxvol_values.isactive === true
                            ? error_voltage_data.push({ message: await combine_mes_val_unit(alert_hhgmaxvol_values.message, data.lightyellowvoltage, alert_hhgmaxvol_values.unit), voltage: data.lightyellowvoltage, current: data.lightyellowcurrent, max_voltage: data.lightyellowvoltage > parseFloat(alert_maxvol_values.value) ? true : false, min_voltage: false, gui: 3, id: alert_hhgmaxvol_values.id, mode: alert_hhgmaxvol_values.mode })
                            : "" : ""
            }

            //check for only relay voltage                
            var result = lodash.filter(glow_check, function (o) { return o.result; });
            var from_date = new Date(new Date().setSeconds(-parseInt(alert_off_values.value)));
            var to_date = new Date(new Date().setSeconds(-parseInt(alert_off_values.value) - parseInt(process.env.GRACE_BLANK_ALERT)));

            if (result.length == 1) // satifies only one condition
            {
                aspectcurrent = result[0].current
                aspectvoltage = result[0].voltage
                gui = result[0].gui

                if (error_voltage_data.length > 0) {
                    var max_voltage_result = lodash.filter(error_voltage_data, function (o) { return o.max_voltage; });
                    if (max_voltage_result.length > 0) {
                        let gui_glow = gui == 1 ? "RG glows and " : gui == 2 ? "DG glows and " : gui == 3 ? "HG glows and " : gui == 4 ? "HHG glows and " : ""
                        for (var element of error_voltage_data) {
                            alert_message_mode.push({ message: gui_glow + element.message, id: element.id, mode: element.mode })
                        }
                    }
                }
                else {
                    if (error_current_data.length > 0) {
                        var max_current_result = lodash.filter(error_current_data, function (o) { return o.max_current; });
                        if (max_current_result.length > 0) {
                            let gui_glow = gui == 1 ? "RG glows and " : gui == 2 ? "DG glows and " : gui == 3 ? "HG glows and " : gui == 4 ? "HHG glows and " : ""
                            for (var element of error_current_data) {
                                alert_message_mode.push({ message: gui_glow + element.message, id: element.id, mode: element.mode })
                            }
                        }
                    }
                }
            }
            else {
                if (result.length == 0) {
                    if (error_voltage_data.length > 0) {
                        var max_voltage_result = lodash.filter(error_voltage_data, function (o) { return o.max_voltage; });
                        if (max_voltage_result.length > 0) {
                            for (var element of error_voltage_data) {
                                alert_message_mode.push({ message: element.message, id: element.id, mode: element.mode })
                            }
                            let check_gui = [1]
                            let get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                            if (get_gui.length == 1) {
                                gui = 1
                                aspectcurrent = get_gui[0].current
                                aspectvoltage = get_gui[0].voltage
                            }
                            else {
                                check_gui = [2]
                                get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                if (get_gui.length == 1) {
                                    gui = 2
                                    aspectcurrent = get_gui[0].current
                                    aspectvoltage = get_gui[0].voltage
                                }
                                else {
                                    check_gui = [3]
                                    get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                    if (get_gui.length == 1) {
                                        gui = 3
                                        aspectcurrent = get_gui[0].current
                                        aspectvoltage = get_gui[0].voltage
                                    }
                                    else {
                                        if (data.terminal === 'B') {
                                            check_gui = [4]
                                            get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                            if (get_gui.length == 1) {
                                                gui = 4
                                                aspectcurrent = get_gui[0].current
                                                aspectvoltage = get_gui[0].voltage
                                            }
                                        }
                                        check_gui = [1, 2]
                                        get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                        if (get_gui.length == 2) {
                                            gui = 5;
                                        }
                                        else {
                                            check_gui = [1, 3]
                                            get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                            if (get_gui.length == 2) {
                                                gui = 6;
                                            }
                                            else {
                                                if (data.terminal === 'B') {
                                                    check_gui = [1, 4]
                                                    get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                                    if (get_gui.length == 2) {
                                                        gui = 7
                                                        aspectcurrent = get_gui[0].current
                                                        aspectvoltage = get_gui[0].voltage
                                                    }
                                                }
                                                check_gui = [2, 3]
                                                get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                                if (get_gui.length == 2) {
                                                    gui = 8;
                                                }
                                                else {
                                                    if (data.terminal === 'B') {
                                                        check_gui = [2, 4]
                                                        get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                                        if (get_gui.length == 2) {
                                                            gui = 9
                                                            aspectcurrent = get_gui[0].current
                                                            aspectvoltage = get_gui[0].voltage
                                                        }
                                                        else {
                                                            check_gui = [3, 4]
                                                            get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                                            if (get_gui.length == 2) {
                                                                gui = 10
                                                                aspectcurrent = get_gui[0].current
                                                                aspectvoltage = get_gui[0].voltage
                                                            }
                                                        }
                                                    }
                                                    if (data.terminal === 'B') {
                                                        check_gui = [1, 2, 3, 4]
                                                        get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                                        if (get_gui.length == 4) {
                                                            gui = 11;
                                                        }
                                                    }
                                                    else {
                                                        check_gui = [1, 2, 3]
                                                        get_gui = error_voltage_data.filter(e => check_gui.includes(e.gui));
                                                        if (get_gui.length == 3) {
                                                            gui = 11;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    else {
                        if (error_current_data.length > 0) {
                            var max_current_result = lodash.filter(error_current_data, function (o) { return o.max_current; });
                            if (max_current_result.length > 0) {
                                for (var element of error_current_data) {
                                    alert_message_mode.push({ message: element.message, id: element.id, mode: element.mode })
                                }
                                let check_gui = [1]
                                let get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                if (get_gui.length == 1) {

                                    gui = 1
                                    aspectcurrent = get_gui[0].current
                                    aspectvoltage = get_gui[0].voltage
                                }
                                else {
                                    check_gui = [2]
                                    get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                    if (get_gui.length == 1) {
                                        gui = 2
                                        aspectcurrent = get_gui[0].current
                                        aspectvoltage = get_gui[0].voltage
                                    }
                                    else {
                                        check_gui = [3]
                                        get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                        if (get_gui.length == 1) {
                                            gui = 3
                                            aspectcurrent = get_gui[0].current
                                            aspectvoltage = get_gui[0].voltage
                                        }
                                        else {
                                            if (data.terminal === 'B') {
                                                check_gui = [4]
                                                get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                if (get_gui.length == 1) {
                                                    gui = 4
                                                    aspectcurrent = get_gui[0].current
                                                    aspectvoltage = get_gui[0].voltage
                                                }
                                            }
                                            check_gui = [1, 2]
                                            get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                            if (get_gui.length == 2) {
                                                gui = 5;
                                            }
                                            else {
                                                check_gui = [1, 3]
                                                get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                if (get_gui.length == 2) {
                                                    gui = 6;
                                                }
                                                else {
                                                    if (data.terminal === 'B') {
                                                        check_gui = [1, 4]
                                                        get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                        if (get_gui.length == 2) {
                                                            gui = 7
                                                            aspectcurrent = get_gui[0].current
                                                            aspectvoltage = get_gui[0].voltage
                                                        }
                                                    }
                                                    check_gui = [2, 3]
                                                    get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                    if (get_gui.length == 2) {
                                                        gui = 8;
                                                    }
                                                    else {
                                                        if (data.terminal === 'B') {
                                                            check_gui = [2, 4]
                                                            get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                            if (get_gui.length == 2) {
                                                                gui = 9
                                                                aspectcurrent = get_gui[0].current
                                                                aspectvoltage = get_gui[0].voltage
                                                            }
                                                            else {
                                                                check_gui = [3, 4]
                                                                get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                                if (get_gui.length == 2) {
                                                                    gui = 10
                                                                    aspectcurrent = get_gui[0].current
                                                                    aspectvoltage = get_gui[0].voltage
                                                                }
                                                            }
                                                        }
                                                        if (data.terminal === 'B') {
                                                            check_gui = [1, 2, 3, 4]
                                                            get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                            if (get_gui.length == 4) {
                                                                gui = 11;
                                                            }
                                                        }
                                                        else {
                                                            check_gui = [1, 2, 3]
                                                            get_gui = error_current_data.filter(e => check_gui.includes(e.gui));
                                                            if (get_gui.length == 3) {
                                                                gui = 11;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        else {
                            var get_off_list = [await SignalCircuitData.findOne({
                                where: {
                                    gui: 12,
                                    isdele: false,
                                    createddate: { [Op.gt]: to_date, [Op.lt]: from_date }
                                },
                                limit: 1,
                                order: [["id", "ASC"]]
                            })]
                            get_off_list = get_off_list[0] !== null ? get_off_list : []

                            if (get_off_list.length == 1) {
                                alert_message_mode.push({ message: await combine_mes_val_unit(alert_off_values.message, alert_off_values.value, alert_off_values.unit), id: [alert_off_values.id], mode: alert_off_values.mode })
                            }
                            gui = 12
                        }
                    }
                }
                else {
                    if (result.length > 0) {
                        let check_gui = []
                        if (data.terminal === 'A') {
                            check_gui = [1, 2, 3]
                        }
                        else {
                            check_gui = [1, 2, 3, 4]
                        }

                        let get_gui = result.filter(e => check_gui.includes(e.gui));
                        if (get_gui.length == 3 || get_gui.length == 4) {
                            gui = 11
                            var get_on_list = [await SignalCircuitData.findOne({
                                where: {
                                    gui: 11,
                                    isdele: false,
                                    createddate: { [Op.gt]: to_date, [Op.lt]: from_date }
                                },
                                limit: 1,
                                order: [["id", "ASC"]]
                            })]
                            get_on_list = get_on_list[0] !== null ? get_on_list : []

                            if (get_on_list.length == 1) {
                                alert_message_mode.push({ message: await combine_mes_val_unit(alert_on_values.message, alert_on_values.value, alert_on_values.unit), id: [alert_on_values.id], mode: alert_on_values.mode })
                            }
                        }
                        else {
                            check_gui = [1, 2]
                            get_gui = result.filter(e => check_gui.includes(e.gui));
                            if (get_gui.length == 2) {
                                gui = 5
                                alert_message_mode.push({ message: await combine_mes_val_unit(alert_rgdg_values.message, alert_rgdg_values.value, alert_rgdg_values.unit), id: [alert_rgdg_values.id], mode: alert_rgdg_values.mode })
                            }
                            else {
                                check_gui = [1, 3]
                                get_gui = result.filter(e => check_gui.includes(e.gui));
                                if (get_gui.length == 2) {
                                    gui = 6
                                    alert_message_mode.push({ message: await combine_mes_val_unit(alert_rghg_values.message, alert_rghg_values.value, alert_rghg_values.unit), id: [alert_rghg_values.id], mode: alert_rghg_values.mode })
                                }
                                else {
                                    check_gui = [1, 4]
                                    get_gui = result.filter(e => check_gui.includes(e.gui));
                                    if (get_gui.length == 2) {
                                        gui = 7
                                        alert_message_mode.push({ message: await combine_mes_val_unit(alert_rghhg_values.message, alert_rghhg_values.value, alert_rghhg_values.unit), id: [alert_rghhg_values.id], mode: alert_rghhg_values.mode })
                                    }
                                    else {
                                        check_gui = [2, 3]
                                        get_gui = result.filter(e => check_gui.includes(e.gui));
                                        if (get_gui.length == 2) {
                                            gui = 8
                                            alert_message_mode.push({ message: await combine_mes_val_unit(alert_dghg_values.message, alert_dghg_values.value, alert_dghg_values.unit), id: [alert_dghg_values.id], mode: alert_dghg_values.mode })
                                        }
                                        else {
                                            check_gui = [2, 4]
                                            get_gui = result.filter(e => check_gui.includes(e.gui));
                                            if (get_gui.length == 2) {
                                                gui = 9
                                                alert_message_mode.push({ message: await combine_mes_val_unit(alert_dghhg_values.message, alert_dghhg_values.value, alert_dghhg_values.unit), id: [alert_dghhg_values.id], mode: alert_dghhg_values.mode })
                                            }
                                            else {
                                                check_gui = [3, 4]
                                                get_gui = result.filter(e => check_gui.includes(e.gui));
                                                if (get_gui.length == 2) {
                                                    gui = 10
                                                    alert_message_mode.push({ message: await combine_mes_val_unit(alert_hghhg_values.message, alert_hghhg_values.value, alert_hghhg_values.unit), id: [alert_hghhg_values.id], mode: alert_hghhg_values.mode })
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (error_voltage_data.length > 0) {
                var min_voltage_result = lodash.filter(error_voltage_data, function (o) { return o.min_voltage; });
                if (min_voltage_result.length > 0) {
                    let gui_glow = gui == 1 ? "RG glows and " : gui == 2 ? "DG glows and " : gui == 3 ? "HG glows and " : gui == 4 ? "HHG glows and " : ""
                    if (gui_glow == "") {
                        for (var element of error_voltage_data) {
                            alert_message_mode.push({ message: element.message, id: element.id, mode: element.mode })
                        }
                        if (min_voltage_result.length == 1) {
                            gui = min_voltage_result[0].gui
                            aspectcurrent = min_voltage_result[0].current
                            aspectvoltage = min_voltage_result[0].voltage
                        }
                    }
                    else {
                        for (var element of error_voltage_data) {
                            alert_message_mode.push({ message: gui_glow + element.message, id: element.id, mode: element.mode })
                        }
                    }
                }
            }
            if (error_current_data.length > 0) {
                var min_current_result = lodash.filter(error_current_data, function (o) { return o.min_current; });
                if (min_current_result.length > 0) {
                    let gui_glow = gui == 1 ? "RG glows and " : gui == 2 ? "DG glows and " : gui == 3 ? "HG glows and " : gui == 4 ? "HHG glows and " : ""
                    if (gui_glow == "") {
                        for (var element of error_current_data) {
                            alert_message_mode.push({ message: element.message, id: element.id, mode: element.mode })
                        }
                        if (min_current_result.length == 1) {
                            gui = min_current_result[0].gui
                            aspectcurrent = min_current_result[0].current
                            aspectvoltage = min_current_result[0].voltage
                        }
                    }
                    else {
                        for (var element of error_current_data) {
                            alert_message_mode.push({ message: gui_glow + element.message, id: element.id, mode: element.mode })
                        }
                    }
                }
            }

            if (gui == 0) {
                gui = 12
            }

            let signal_aspect = gui == 1 ? "RG" : gui == 2 ? "DG" : gui == 3 ? "HG" : gui == 4 ? "HHG" : gui == 5 ? "RG DG" : gui == 6 ? "RG HG"
                : gui == 7 ? "RG HHG" : gui == 8 ? "DG HG" : gui == 9 ? "DG HHG" : gui == 10 ? "HG HHG" : gui == 11 ? "ALL" : gui == 12 ? "OFF" : "OFF"

            let insert_dataid = ""

            const data_insert = await SignalCircuitData.create({
                signalcircuitid: parseInt(data.signalcircuitid),
                terminal: data.terminal,
                greenvoltage: data.greenvoltage,
                greencurrent: data.greencurrent,
                redvoltage: data.redvoltage,
                redcurrent: data.redcurrent,
                yellowvoltage: data.yellowvoltage,
                yellowcurrent: data.yellowcurrent,
                lightyellowvoltage: data.lightyellowvoltage,
                lightyellowcurrent: data.lightyellowcurrent,
                signal_aspect: signal_aspect,
                aspect_current: aspectcurrent,
                aspect_voltage: aspectvoltage,
                index_score: index_score,
                gui: gui,
                createddate: data.createddate,
                isdele: false
            },
                { transaction: transaction }
            ).then(res => insert_dataid = res.id)
            //logs.info('signal_insert_dataid', insert_dataid)

            const cycle_index = signalcircuitdatas.findIndex(obj => { return obj.key === data.signalcircuitid.toString(); });
            if (cycle_index !== -1) {
                signalcircuitdatas[cycle_index].data = data_insert[0]
                signalcircuitdatas[cycle_index].id = insert_dataid
            }
            else {
                signalcircuitdatas.push({ key: data.signalcircuitid.toString(), data: data_insert[0], id: insert_dataid });
            }

            let alert_data = {}
            let alert_logs = []
            let alert_modeid = 0

            let mobile_notification_data = []

            var mode_filtered = lodash.groupBy(alert_message_mode, function (o) { return o.mode })

            if (alert_message_mode.length > 0) {
                for (var property in mode_filtered) {
                    let alertid = ""
                    let modeid = lodash.result(lodash.find(AlertModes, { 'mode': property }), 'id')
                    alert_modeid = alert_modeid == null ? modeid : alert_modeid > modeid ? alert_modeid : modeid

                    alert_data = {
                        signalcircuitid: parseInt(data.signalcircuitid),
                        signalcircuitdataid: insert_dataid,
                        stationid: data.stationid,
                        message: mode_filtered[property].map(i => i.message).join(' ; '),
                        assertsid: data.assertid,
                        modeid: modeid,
                        createddate: data.createddate,
                        isdele: false
                    }
                    alert_logs.push(alert_data)

                    const alertinsert = await SignalCircuitAlert.create(alert_data, { transaction: transaction }).then(res => alertid = res.id)
                    //logs.info(`station signalcircuit alert ended`);
                    //console.log(`station signalcircuit alert ended`); 

                    var get_users = await NotificationControl.findAll({ where: { assertsid: data.assertid, stationid: data.stationid, isdele: false } })
                    var get_users_id = lodash.uniq(get_users.map(item => item.userid))

                    let alert_message_ids = lodash.uniq(mode_filtered[property].map(i => i.id)).sort((a, b) => a - b)

                    for (let i = 0; i < get_users_id.length; i++) {

                        const get_previous_notification = await NotificationSend.findOne({
                            where: { stationid: data.stationid, assertsid: data.assertid, alertmessageids: alert_message_ids, modeid: modeid, userid: get_users_id[i], isseen: false, isdele: false },
                            order: [["id", "DESC"]]
                        })

                        if (get_previous_notification == null) {
                            mobile_notification_data.push({
                                stationid: data.stationid,
                                stationcode: data.stationcode,
                                stationname: data.stationname,
                                assertname: data.assertname,
                                assertsid: data.assertid,
                                assertidname: data.signalname,
                                alertid: alertid,
                                userid: get_users_id[i],
                                message: mode_filtered[property].map(i => i.message),
                                modeid: modeid,
                                mode: property,
                                alertmessageids: alert_message_ids,
                                isseen: false,
                                issend: false,
                                createddate: data.createddate,
                            })
                        }
                    }
                }

                if (mobile_notification_data.length > 0) {
                    const notifiyinsert = await NotificationSend.bulkCreate(mobile_notification_data, { transaction: transaction })
                    Socket.emit('Notification', mobile_notification_data);
                    //.emit("Notification", mobile_notification_data)
                }
            }

            let data_logs = {
                id: insert_dataid,
                signalcircuitid: parseInt(data.signalcircuitid),
                signalname: data.signalname,
                terminal: data.terminal,
                aspecttypeid: data.aspecttypeid,
                greenvoltage: data.greenvoltage,
                greencurrent: data.greencurrent,
                redvoltage: data.redvoltage,
                redcurrent: data.redcurrent,
                yellowvoltage: data.yellowvoltage,
                yellowcurrent: data.yellowcurrent,
                lightyellowvoltage: data.lightyellowvoltage,
                lightyellowcurrent: data.lightyellowcurrent,
                signal_aspect: signal_aspect,
                aspect_current: aspectcurrent,
                aspect_voltage: aspectvoltage,
                index_score: index_score,
                gui: gui,
                createddate: data.createddate,
                isdele: false
            }

            // //commented it out because not using now
            // let signals = []
            // signals.push({
            //     id: parseInt(data.signalcircuitid),
            //     signalname: data.signalname,
            //     signal_aspect: signal_aspect,
            //     aspect_current: aspectcurrent,
            //     aspect_voltage: aspectvoltage,
            //     index_score: index_score,
            //     gui: gui,
            //     createddate: data.createddate,
            // })

            // var signalcircuits = await RegisteredSignalCircuit.findAll({ where: { isdele: false, stationid: data.stationid } })
            // for (let i = 0; i < signalcircuits.length; i++) //for await(const element of signalcircuits)
            // {
            //     let element = signalcircuits[i]
            //     var get_finalsignalcircuit_datas = [await SignalCircuitData.findOne({ limit: 1, where: { isdele: false, signalcircuitid: element.id }, order: [["id", "DESC"]] }, { transaction: transaction })];
            //     get_finalsignalcircuit_datas = get_finalsignalcircuit_datas[0] !== null ? get_finalsignalcircuit_datas : []
            //     if (get_finalsignalcircuit_datas.length > 0 && element.id != parseInt(data.signalcircuitid)) {
            //         signals.push({
            //             id: element.id,
            //             signalname: element.signalname,
            //             signal_aspect: get_finalsignalcircuit_datas[0].signal_aspect,
            //             aspect_current: get_finalsignalcircuit_datas[0].aspect_current,
            //             aspect_voltage: get_finalsignalcircuit_datas[0].aspect_voltage,
            //             index_score: get_finalsignalcircuit_datas[0].index_score,
            //             gui: get_finalsignalcircuit_datas[0].gui,
            //             createddate: get_finalsignalcircuit_datas[0].createddate,
            //         })
            //     }
            // }

            let socket_data = {
                data_logs: data_logs,
                // signals: signals,
                alertmodeid: alert_logs.length > 0 ? alert_modeid : null,
                alerts: alert_logs
            }

            await transaction.commit();
            //logs.info('signalcircuitdata',socket_data )
            Socket.emit("signalcircuitdata", socket_data)
            //socketcloud.emit("Signal", socket_data)
        }
        catch (ex) {
            await transaction.rollback();
            logs.error('station signal circuit data error' + ex);
            //console.log('station signal circuit data error' + ex);
        }
    }

    // InActive - old - Point Machine 1A
    async function insert_Apointnotification1(data) {
        logs.info(`insert station pointmachine 1A data started`);
        //console.log(`insert station pointmachine A data started`);   
        try {
            alert_value_list = require("./alertvalue").getValues();
            let station_id = data.stationid
            let data_insert = []
            var get_finalpointmachine_datas = [await PointMachineData.findOne({ limit: 1, where: { isdele: false, pointmachineid: parseInt(data.pointmachineid) }, order: [["id", "DESC"]] })];
            get_finalpointmachine_datas = get_finalpointmachine_datas[0] !== null ? get_finalpointmachine_datas : []
            const get_1Adata = await PointmachineAdata.findAll({ where: { isdele: false, pointmachineid: parseInt(data.pointmachineid) } });
            const get_1Bdata = await PointmachineBdata.findAll({ where: { isdele: false, pointmachineid: parseInt(data.pointmachineid) } });

            if (get_finalpointmachine_datas.length > 0) {
                let finalacycle = get_finalpointmachine_datas[0].a_cyclecount === 0 ? 1 : get_finalpointmachine_datas[0].a_cyclecount;
                let finalbcycle = get_finalpointmachine_datas[0].b_cyclecount === 0 ? 1 : get_finalpointmachine_datas[0].b_cyclecount;

                var a_pointmachinedata = [];
                var b_pointmachinedata = [];
                var Apointcyle = [];
                var Bpointcyle = [];

                if (get_1Bdata.length > 0) {
                    b_pointmachinedata = lodash.filter(get_1Bdata, ({ cyclecount }) => cyclecount > finalbcycle)
                    Bpointcyle = b_pointmachinedata.map(a => a.cyclecount)
                }

                if (get_1Adata.length > 0) {
                    a_pointmachinedata = lodash.filter(get_1Adata, ({ cyclecount }) => cyclecount > finalacycle)
                    Apointcyle = a_pointmachinedata.map(a => a.cyclecount)

                    if (get_1Adata.length === 1 && Bpointcyle.length === 0 && Apointcyle.length === 0) {

                        data_insert.push({
                            pointmachineid: parseInt(data.pointmachineid),
                            direction: 'Normal',
                            pointcyclecount: 0,
                            a_direction: get_1Adata[get_1Adata.length - 1].direction,
                            a_cyclecount: get_1Adata[get_1Adata.length - 1].cyclecount,
                            a_indication_voltage: get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardindicationvoltage : get_1Adata[get_1Adata.length - 1].reverseindicationvoltage,
                            a_current_max: get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardcurrentpeak : get_1Adata[get_1Adata.length - 1].reversecurrentpeak,
                            a_current_avg: get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardcurrentavg : get_1Adata[get_1Adata.length - 1].reversecurrentavg,
                            a_voltage: get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardvoltage : get_1Adata[get_1Adata.length - 1].reversevoltage,
                            a_time: get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardtime : get_1Adata[get_1Adata.length - 1].reversetime,
                            a_vibration_x: get_1Adata[get_1Adata.length - 1].vibrationx,
                            a_vibration_y: get_1Adata[get_1Adata.length - 1].vibrationy,
                            a_vibration_z: get_1Adata[get_1Adata.length - 1].vibrationz,
                            b_direction: get_1Bdata[get_1Bdata.length - 1].direction,
                            b_cyclecount: get_1Bdata[get_1Bdata.length - 1].cyclecount,
                            b_indication_voltage: get_1Bdata[get_1Bdata.length - 1].reverseindicationvoltage,
                            b_current_max: get_1Bdata[get_1Bdata.length - 1].reversecurrentpeak,
                            b_current_avg: get_1Bdata[get_1Bdata.length - 1].reversecurrentavg,
                            b_voltage: get_1Bdata[get_1Bdata.length - 1].reversevoltage,
                            b_time: get_1Bdata[get_1Bdata.length - 1].reversetime,
                            b_vibration_x: get_1Bdata[get_1Bdata.length - 1].vibrationx,
                            b_vibration_y: get_1Bdata[get_1Bdata.length - 1].vibrationy,
                            b_vibration_z: get_1Bdata[get_1Bdata.length - 1].vibrationz,
                            log: get_1Adata[get_1Adata.length - 1].log == 1 ? 1 : get_1Bdata[get_1Bdata.length - 1].log,
                            createddate: get_1Adata[get_1Adata.length - 1].createddate,
                            isdele: false
                        })
                    }
                }

                if (Apointcyle.length >= Bpointcyle.length) {
                    let count = finalbcycle
                    for await (const Aelement of a_pointmachinedata) {
                        data_insert.push({
                            pointmachineid: parseInt(data.pointmachineid),
                            direction: 'Normal',
                            pointcyclecount: 0,
                            a_direction: Aelement.direction,
                            a_cyclecount: Aelement.cyclecount,
                            a_indication_voltage: Aelement.direction == 'Normal' ? Aelement.forwardindicationvoltage : Aelement.reverseindicationvoltage,
                            a_current_max: Aelement.direction == 'Normal' ? Aelement.forwardcurrentpeak : Aelement.reversecurrentpeak,
                            a_current_avg: Aelement.direction == 'Normal' ? Aelement.forwardcurrentavg : Aelement.reversecurrentavg,
                            a_voltage: Aelement.direction == 'Normal' ? Aelement.forwardvoltage : Aelement.reversevoltage,
                            a_time: Aelement.direction == 'Normal' ? Aelement.forwardtime : Aelement.reversetime,
                            a_vibration_x: Aelement.vibrationx,
                            a_vibration_y: Aelement.vibrationy,
                            a_vibration_z: Aelement.vibrationz,
                            b_direction: get_1Bdata.length > count ? get_1Bdata[count].direction : get_1Bdata.length === 0 ? '' : get_1Bdata[get_1Bdata.length - 1].direction,
                            b_cyclecount: get_1Bdata.length > count ? get_1Bdata[count].cyclecount : get_1Bdata.length === 0 ? 0 : get_1Bdata[get_1Bdata.length - 1].cyclecount,
                            b_indication_voltage: get_1Bdata.length > count ? get_1Bdata[count].direction == 'Normal' ? get_1Bdata.length === 0 ? 0 : get_1Bdata[count - 1].forwardindicationvoltage : get_1Bdata[count - 1].reverseindicationvoltage : get_1Bdata.length === 0 ? 0 : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardindicationvoltage : get_1Bdata[get_1Bdata.length - 1].reverseindicationvoltage,
                            b_current_max: get_1Bdata.length > count ? get_1Bdata[count].direction == 'Normal' ? get_1Bdata.length === 0 ? 0 : get_1Bdata[count - 1].forwardcurrentpeak : get_1Bdata[count - 1].reversecurrentpeak : get_1Bdata.length === 0 ? 0 : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardcurrentpeak : get_1Bdata[get_1Bdata.length - 1].reversecurrentpeak,
                            b_current_avg: get_1Bdata.length > count ? get_1Bdata[count].direction == 'Normal' ? get_1Bdata.length === 0 ? 0 : get_1Bdata[count - 1].forwardcurrentavg : get_1Bdata[count - 1].reversecurrentavg : get_1Bdata.length === 0 ? 0 : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardcurrentavg : get_1Bdata[get_1Bdata.length - 1].reversecurrentavg,
                            b_voltage: get_1Bdata.length > count ? get_1Bdata[count].direction == 'Normal' ? get_1Bdata.length === 0 ? 0 : get_1Bdata[count - 1].forwardvoltage : get_1Bdata[count - 1].reversevoltage : get_1Bdata.length === 0 ? 0 : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardvoltage : get_1Bdata[get_1Bdata.length - 1].reversevoltage,
                            b_time: get_1Bdata.length > count ? get_1Bdata[count].direction == 'Normal' ? get_1Bdata.length === 0 ? 0 : get_1Bdata[count - 1].forwardtime : get_1Bdata[count - 1].reversetime : get_1Bdata.length === 0 ? 0 : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardtime : get_1Bdata[get_1Bdata.length - 1].reversetime,
                            b_vibration_x: get_1Bdata.length > count ? get_1Bdata[count].vibrationx : get_1Bdata.length === 0 ? 0 : get_1Bdata[get_1Bdata.length - 1].vibrationx,
                            b_vibration_y: get_1Bdata.length > count ? get_1Bdata[count].vibrationy : get_1Bdata.length === 0 ? 0 : get_1Bdata[get_1Bdata.length - 1].vibrationy,
                            b_vibration_z: get_1Bdata.length > count ? get_1Bdata[count].vibrationz : get_1Bdata.length === 0 ? 0 : get_1Bdata[get_1Bdata.length - 1].vibrationz,
                            log: Aelement.log == 1 ? 1 : get_1Bdata.length > count ? get_1Bdata[count].log : get_1Bdata.length === 0 ? 0 : get_1Bdata[get_1Bdata.length - 1].log,
                            createddate: Aelement.createddate,
                            isdele: false
                        })
                        count++
                    }
                }
                else {
                    let count = finalacycle
                    for await (const Belement of b_pointmachinedata) {
                        data_insert.push({
                            pointmachineid: parseInt(data.pointmachineid),
                            direction: 'Normal',
                            pointcyclecount: 0,
                            a_direction: get_1Adata.length > count ? get_1Adata[count].direction : get_1Adata.length === 0 ? '' : get_1Adata[get_1Adata.length - 1].direction,
                            a_cyclecount: get_1Adata.length > count ? get_1Adata[count].cyclecount : get_1Adata.length === 0 ? 0 : get_1Adata[get_1Adata.length - 1].cyclecount,
                            a_indication_voltage: get_1Adata.length > count ? get_1Adata[count].direction == 'Normal' ? get_1Adata.length === 0 ? 0 : get_1Adata[count - 1].forwardindicationvoltage : get_1Adata[count - 1].reverseindicationvoltage : get_1Adata.length === 0 ? 0 : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardindicationvoltage : get_1Adata[get_1Adata.length - 1].reverseindicationvoltage,
                            a_current_max: get_1Adata.length > count ? get_1Adata[count].direction == 'Normal' ? get_1Adata.length === 0 ? 0 : get_1Adata[count - 1].forwardcurrentpeak : get_1Adata[count - 1].reversecurrentpeak : get_1Adata.length === 0 ? 0 : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardcurrentpeak : get_1Adata[get_1Adata.length - 1].reversecurrentpeak,
                            a_current_avg: get_1Adata.length > count ? get_1Adata[count].direction == 'Normal' ? get_1Adata.length === 0 ? 0 : get_1Adata[count - 1].forwardcurrentavg : get_1Adata[count - 1].reversecurrentavg : get_1Adata.length === 0 ? 0 : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardcurrentavg : get_1Adata[get_1Adata.length - 1].reversecurrentavg,
                            a_voltage: get_1Adata.length > count ? get_1Adata[count].direction == 'Normal' ? get_1Adata.length === 0 ? 0 : get_1Adata[count - 1].forwardvoltage : get_1Adata[count - 1].reversevoltage : get_1Adata.length === 0 ? 0 : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardvoltage : get_1Adata[get_1Adata.length - 1].reversevoltage,
                            a_time: get_1Adata.length > count ? get_1Adata[count].direction == 'Normal' ? get_1Adata.length === 0 ? 0 : get_1Adata[count - 1].forwardtime : get_1Adata[count - 1].reversetime : get_1Adata.length === 0 ? 0 : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardtime : get_1Adata[get_1Adata.length - 1].reversetime,
                            a_vibration_x: get_1Adata.length > count ? get_1Adata[count].vibrationx : get_1Adata.length === 0 ? 0 : get_1Adata[get_1Adata.length - 1].vibrationx,
                            a_vibration_y: get_1Adata.length > count ? get_1Adata[count].vibrationy : get_1Adata.length === 0 ? 0 : get_1Adata[get_1Adata.length - 1].vibrationy,
                            a_vibration_z: get_1Adata.length > count ? get_1Adata[count].vibrationz : get_1Adata.length === 0 ? 0 : get_1Adata[get_1Adata.length - 1].vibrationz,
                            b_direction: Belement.direction,
                            b_cyclecount: Belement.cyclecount,
                            b_indication_voltage: Belement.direction == 'Normal' ? Belement.forwardindicationvoltage : Belement.reverseindicationvoltage,
                            b_current_max: Belement.direction == 'Normal' ? Belement.forwardcurrentpeak : Belement.reversecurrentpeak,
                            b_current_avg: Belement.direction == 'Normal' ? Belement.forwardcurrentavg : Belement.reversecurrentavg,
                            b_voltage: Belement.direction == 'Normal' ? Belement.forwardvoltage : Belement.reversevoltage,
                            b_time: Belement.direction == 'Normal' ? Belement.forwardtime : Belement.reversetime,
                            b_vibration_x: Belement.vibrationx,
                            b_vibration_y: Belement.vibrationy,
                            b_vibration_z: Belement.vibrationz,
                            log: Belement.log == 1 ? 1 : get_1Adata.length > count ? get_1Adata[count].log : get_1Adata.length === 0 ? 0 : get_1Adata[get_1Adata.length - 1].log,
                            createddate: Belement.createddate,
                            isdele: false
                        })
                        count++
                    }
                }
            }
            else {
                if (get_1Adata.length >= get_1Bdata.length) {
                    let count = 1
                    for await (const Aelement of get_1Adata) {
                        if (count == 1) {
                            if (get_1Bdata.length == 0) {
                                data_insert.push({
                                    pointmachineid: parseInt(data.pointmachineid),
                                    direction: 'Normal',
                                    pointcyclecount: 0,
                                    a_direction: Aelement.direction,
                                    a_cyclecount: Aelement.cyclecount,
                                    a_indication_voltage: Aelement.direction == 'Normal' ? Aelement.forwardindicationvoltage : Aelement.reverseindicationvoltage,
                                    a_current_max: Aelement.direction == 'Normal' ? Aelement.forwardcurrentpeak : Aelement.reversecurrentpeak,
                                    a_current_avg: Aelement.direction == 'Normal' ? Aelement.forwardcurrentavg : Aelement.reversecurrentavg,
                                    a_voltage: Aelement.direction == 'Normal' ? Aelement.forwardvoltage : Aelement.reversevoltage,
                                    a_time: Aelement.direction == 'Normal' ? Aelement.forwardtime : Aelement.reversetime,
                                    a_vibration_x: Aelement.vibrationx,
                                    a_vibration_y: Aelement.vibrationy,
                                    a_vibration_z: Aelement.vibrationz,
                                    b_direction: '',
                                    b_cyclecount: 0,
                                    b_indication_voltage: 0,
                                    b_current_max: 0,
                                    b_current_avg: 0,
                                    b_voltage: 0,
                                    b_time: 0,
                                    b_vibration_x: 0,
                                    b_vibration_y: 0,
                                    b_vibration_z: 0,
                                    log: Aelement.log == 1 ? 1 : 0,
                                    createddate: Aelement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                data_insert.push({
                                    pointmachineid: parseInt(data.pointmachineid),
                                    direction: 'Normal',
                                    pointcyclecount: 0,
                                    a_direction: Aelement.direction,
                                    a_cyclecount: Aelement.cyclecount,
                                    a_indication_voltage: Aelement.direction == 'Normal' ? Aelement.forwardindicationvoltage : Aelement.reverseindicationvoltage,
                                    a_current_max: Aelement.direction == 'Normal' ? Aelement.forwardcurrentpeak : Aelement.reversecurrentpeak,
                                    a_current_avg: Aelement.direction == 'Normal' ? Aelement.forwardcurrentavg : Aelement.reversecurrentavg,
                                    a_voltage: Aelement.direction == 'Normal' ? Aelement.forwardvoltage : Aelement.reversevoltage,
                                    a_time: Aelement.direction == 'Normal' ? Aelement.forwardtime : Aelement.reversetime,
                                    a_vibration_x: Aelement.vibrationx,
                                    a_vibration_y: Aelement.vibrationy,
                                    a_vibration_z: Aelement.vibrationz,
                                    b_direction: get_1Bdata.length > count ? get_1Bdata[count - 1].direction : get_1Bdata[get_1Bdata.length - 1].direction,
                                    b_cyclecount: get_1Bdata.length > count ? get_1Bdata[count - 1].cyclecount : get_1Bdata[get_1Bdata.length - 1].cyclecount,
                                    b_indication_voltage: get_1Bdata.length > count ? get_1Bdata[count - 1].direction == 'Normal' ? get_1Bdata[count - 1].forwardindicationvoltage : get_1Bdata[count - 1].reverseindicationvoltage : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardindicationvoltage : get_1Bdata[get_1Bdata.length - 1].reverseindicationvoltage,
                                    b_current_max: get_1Bdata.length > count ? get_1Bdata[count - 1].direction == 'Normal' ? get_1Bdata[count - 1].forwardcurrentpeak : get_1Bdata[count - 1].reversecurrentpeak : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardcurrentpeak : get_1Bdata[get_1Bdata.length - 1].reversecurrentpeak,
                                    b_current_avg: get_1Bdata.length > count ? get_1Bdata[count - 1].direction == 'Normal' ? get_1Bdata[count - 1].forwardcurrentavg : get_1Bdata[count - 1].reversecurrentavg : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardcurrentavg : get_1Bdata[get_1Bdata.length - 1].reversecurrentavg,
                                    b_voltage: get_1Bdata.length > count ? get_1Bdata[count - 1].direction == 'Normal' ? get_1Bdata[count - 1].forwardvoltage : get_1Bdata[count - 1].reversevoltage : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardvoltage : get_1Bdata[get_1Bdata.length - 1].reversevoltage,
                                    b_time: get_1Bdata.length > count ? get_1Bdata[count - 1].direction == 'Normal' ? get_1Bdata[count - 1].forwardtime : get_1Bdata[count - 1].reversetime : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardtime : get_1Bdata[get_1Bdata.length - 1].reversetime,
                                    b_vibration_x: get_1Bdata.length > count ? get_1Bdata[count - 1].vibrationx : get_1Bdata[get_1Bdata.length - 1].vibrationx,
                                    b_vibration_y: get_1Bdata.length > count ? get_1Bdata[count - 1].vibrationy : get_1Bdata[get_1Bdata.length - 1].vibrationy,
                                    b_vibration_z: get_1Bdata.length > count ? get_1Bdata[count - 1].vibrationz : get_1Bdata[get_1Bdata.length - 1].vibrationz,
                                    log: Aelement.log == 1 ? 1 : get_1Bdata.length > count ? get_1Bdata[count - 1].log : get_1Bdata[get_1Bdata.length - 1].log,
                                    createddate: Aelement.createddate,
                                    isdele: false
                                })
                            }
                        }
                        else {
                            if (get_1Bdata.length == 0) {
                                data_insert.push({
                                    pointmachineid: parseInt(data.pointmachineid),
                                    direction: 'Normal',
                                    pointcyclecount: 0,
                                    a_direction: Aelement.direction,
                                    a_cyclecount: Aelement.cyclecount,
                                    a_indication_voltage: Aelement.direction == 'Normal' ? Aelement.forwardindicationvoltage : Aelement.reverseindicationvoltage,
                                    a_current_max: Aelement.direction == 'Normal' ? Aelement.forwardcurrentpeak : Aelement.reversecurrentpeak,
                                    a_current_avg: Aelement.direction == 'Normal' ? Aelement.forwardcurrentavg : Aelement.reversecurrentavg,
                                    a_voltage: Aelement.direction == 'Normal' ? Aelement.forwardvoltage : Aelement.reversevoltage,
                                    a_time: Aelement.direction == 'Normal' ? Aelement.forwardtime : Aelement.reversetime,
                                    a_vibration_x: Aelement.vibrationx,
                                    a_vibration_y: Aelement.vibrationy,
                                    a_vibration_z: Aelement.vibrationz,
                                    b_direction: '',
                                    b_cyclecount: 0,
                                    b_indication_voltage: 0,
                                    b_current_max: 0,
                                    b_current_avg: 0,
                                    b_voltage: 0,
                                    b_time: 0,
                                    b_vibration_x: 0,
                                    b_vibration_y: 0,
                                    b_vibration_z: 0,
                                    log: Aelement.log == 1 ? 1 : 0,
                                    createddate: Aelement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                data_insert.push({
                                    pointmachineid: parseInt(data.pointmachineid),
                                    direction: 'Normal',
                                    pointcyclecount: 0,
                                    a_direction: Aelement.direction,
                                    a_cyclecount: Aelement.cyclecount,
                                    a_indication_voltage: Aelement.direction == 'Normal' ? Aelement.forwardindicationvoltage : Aelement.reverseindicationvoltage,
                                    a_current_max: Aelement.direction == 'Normal' ? Aelement.forwardcurrentpeak : Aelement.reversecurrentpeak,
                                    a_current_avg: Aelement.direction == 'Normal' ? Aelement.forwardcurrentavg : Aelement.reversecurrentavg,
                                    a_voltage: Aelement.direction == 'Normal' ? Aelement.forwardvoltage : Aelement.reversevoltage,
                                    a_time: Aelement.direction == 'Normal' ? Aelement.forwardtime : Aelement.reversetime,
                                    a_vibration_x: Aelement.vibrationx,
                                    a_vibration_y: Aelement.vibrationy,
                                    a_vibration_z: Aelement.vibrationz,
                                    b_direction: get_1Bdata.length > count ? get_1Bdata[count - 1].direction : get_1Bdata[get_1Bdata.length - 1].direction,
                                    b_cyclecount: get_1Bdata.length > count ? get_1Bdata[count - 1].cyclecount : get_1Bdata[get_1Bdata.length - 1].cyclecount,
                                    b_indication_voltage: get_1Bdata.length > count ? get_1Bdata[count - 1].direction == 'Normal' ? get_1Bdata[count - 1].forwardindicationvoltage : get_1Bdata[count - 1].reverseindicationvoltage : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardindicationvoltage : get_1Bdata[get_1Bdata.length - 1].reverseindicationvoltage,
                                    b_current_max: get_1Bdata.length > count ? get_1Bdata[count - 1].direction == 'Normal' ? get_1Bdata[count - 1].forwardcurrentpeak : get_1Bdata[count - 1].reversecurrentpeak : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardcurrentpeak : get_1Bdata[get_1Bdata.length - 1].reversecurrentpeak,
                                    b_current_avg: get_1Bdata.length > count ? get_1Bdata[count - 1].direction == 'Normal' ? get_1Bdata[count - 1].forwardcurrentavg : get_1Bdata[count - 1].reversecurrentavg : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardcurrentavg : get_1Bdata[get_1Bdata.length - 1].reversecurrentavg,
                                    b_voltage: get_1Bdata.length > count ? get_1Bdata[count - 1].direction == 'Normal' ? get_1Bdata[count - 1].forwardvoltage : get_1Bdata[count - 1].reversevoltage : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardvoltage : get_1Bdata[get_1Bdata.length - 1].reversevoltage,
                                    b_time: get_1Bdata.length > count ? get_1Bdata[count - 1].direction == 'Normal' ? get_1Bdata[count - 1].forwardtime : get_1Bdata[count - 1].reversetime : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardtime : get_1Bdata[get_1Bdata.length - 1].reversetime,
                                    b_vibration_x: get_1Bdata.length > count ? get_1Bdata[count - 1].vibrationx : get_1Bdata[get_1Bdata.length - 1].vibrationx,
                                    b_vibration_y: get_1Bdata.length > count ? get_1Bdata[count - 1].vibrationy : get_1Bdata[get_1Bdata.length - 1].vibrationy,
                                    b_vibration_z: get_1Bdata.length > count ? get_1Bdata[count - 1].vibrationz : get_1Bdata[get_1Bdata.length - 1].vibrationz,
                                    log: Aelement.log == 1 ? 1 : get_1Bdata.length > count ? get_1Bdata[count - 1].log : get_1Bdata[get_1Bdata.length - 1].log,
                                    createddate: Aelement.createddate,
                                    isdele: false
                                })
                            }

                        }
                        count++;
                    }
                }
                else {
                    let count = 1
                    for await (const Belement of get_1Bdata) {
                        if (count == 1) {
                            if (get_1Adata.length == 0) {
                                data_insert.push({
                                    pointmachineid: parseInt(data.pointmachineid),
                                    direction: 'Normal',
                                    pointcyclecount: 0,
                                    a_direction: '',
                                    a_cyclecount: 0,
                                    a_indication_voltage: 0,
                                    a_current_max: 0,
                                    a_current_avg: 0,
                                    a_voltage: 0,
                                    a_time: 0,
                                    a_vibration_x: 0,
                                    a_vibration_y: 0,
                                    a_vibration_z: 0,
                                    b_direction: Belement.direction,
                                    b_cyclecount: Belement.cyclecount,
                                    b_indication_voltage: Belement.direction == 'Normal' ? Belement.forwardindicationvoltage : Belement.reverseindicationvoltage,
                                    b_current_max: Belement.direction == 'Normal' ? Belement.forwardcurrentpeak : Belement.reversecurrentpeak,
                                    b_current_avg: Belement.direction == 'Normal' ? Belement.forwardcurrentavg : Belement.reversecurrentavg,
                                    b_voltage: Belement.direction == 'Normal' ? Belement.forwardvoltage : Belement.reversevoltage,
                                    b_time: Belement.direction == 'Normal' ? Belement.forwardtime : Belement.reversetime,
                                    b_vibration_x: Belement.vibrationx,
                                    b_vibration_y: Belement.vibrationy,
                                    b_vibration_z: Belement.vibrationz,
                                    log: Belement.log == 1 ? 1 : 0,
                                    createddate: Belement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                data_insert.push({
                                    pointmachineid: parseInt(data.pointmachineid),
                                    direction: 'Normal',
                                    pointcyclecount: 0,
                                    a_direction: get_1Adata.length > count ? get_1Adata[count - 1].direction : get_1Adata[get_1Adata.length - 1].direction,
                                    a_cyclecount: get_1Adata.length > count ? get_1Adata[count - 1].cyclecount : get_1Adata[get_1Adata.length - 1].cyclecount,
                                    a_indication_voltage: get_1Adata.length > count ? get_1Adata[count - 1].direction == 'Normal' ? get_1Adata[count - 1].forwardindicationvoltage : get_1Adata[count - 1].reverseindicationvoltage : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardindicationvoltage : get_1Adata[get_1Adata.length - 1].reverseindicationvoltage,
                                    a_current_max: get_1Adata.length > count ? get_1Adata[count - 1].direction == 'Normal' ? get_1Adata[count - 1].forwardcurrentpeak : get_1Adata[count - 1].reversecurrentpeak : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardcurrentpeak : get_1Adata[get_1Adata.length - 1].reversecurrentpeak,
                                    a_current_avg: get_1Adata.length > count ? get_1Adata[count - 1].direction == 'Normal' ? get_1Adata[count - 1].forwardcurrentavg : get_1Adata[count - 1].reversecurrentavg : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardcurrentavg : get_1Adata[get_1Adata.length - 1].reversecurrentavg,
                                    a_voltage: get_1Adata.length > count ? get_1Adata[count - 1].direction == 'Normal' ? get_1Adata[count - 1].forwardvoltage : get_1Adata[count - 1].reversevoltage : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardvoltage : get_1Adata[get_1Adata.length - 1].reversevoltage,
                                    a_time: get_1Adata.length > count ? get_1Adata[count - 1].direction == 'Normal' ? get_1Adata[count - 1].forwardtime : get_1Adata[count - 1].reversetime : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardtime : get_1Adata[get_1Adata.length - 1].reversetime,
                                    a_vibration_x: get_1Adata.length > count ? get_1Adata[count - 1].vibrationx : get_1Adata[get_1Adata.length - 1].vibrationx,
                                    a_vibration_y: get_1Adata.length > count ? get_1Adata[count - 1].vibrationy : get_1Adata[get_1Adata.length - 1].vibrationy,
                                    a_vibration_z: get_1Adata.length > count ? get_1Adata[count - 1].vibrationz : get_1Adata[get_1Adata.length - 1].vibrationz,
                                    b_direction: Belement.direction,
                                    b_cyclecount: Belement.cyclecount,
                                    b_indication_voltage: Belement.direction == 'Normal' ? Belement.forwardindicationvoltage : Belement.reverseindicationvoltage,
                                    b_current_max: Belement.direction == 'Normal' ? Belement.forwardcurrentpeak : Belement.reversecurrentpeak,
                                    b_current_avg: Belement.direction == 'Normal' ? Belement.forwardcurrentavg : Belement.reversecurrentavg,
                                    b_voltage: Belement.direction == 'Normal' ? Belement.forwardvoltage : Belement.reversevoltage,
                                    b_time: Belement.direction == 'Normal' ? Belement.forwardtime : Belement.reversetime,
                                    b_vibration_x: Belement.vibrationx,
                                    b_vibration_y: Belement.vibrationy,
                                    b_vibration_z: Belement.vibrationz,
                                    log: Belement.log == 1 ? 1 : get_1Adata.length > count ? get_1Adata[count - 1].log : get_1Adata[get_1Adata.length - 1].log,
                                    createddate: Belement.createddate,
                                    isdele: false
                                })
                            }

                        }
                        else {
                            if (get_1Adata.length == 0) {
                                data_insert.push({
                                    pointmachineid: parseInt(data.pointmachineid),
                                    direction: 'Normal',
                                    pointcyclecount: 0,
                                    a_direction: '',
                                    a_cyclecount: 0,
                                    a_indication_voltage: 0,
                                    a_current_max: 0,
                                    a_current_avg: 0,
                                    a_voltage: 0,
                                    a_time: 0,
                                    a_vibration_x: 0,
                                    a_vibration_y: 0,
                                    a_vibration_z: 0,
                                    b_direction: Belement.direction,
                                    b_cyclecount: Belement.cyclecount,
                                    b_indication_voltage: Belement.direction == 'Normal' ? Belement.forwardindicationvoltage : Belement.reverseindicationvoltage,
                                    b_current_max: Belement.direction == 'Normal' ? Belement.forwardcurrentpeak : Belement.reversecurrentpeak,
                                    b_current_avg: Belement.direction == 'Normal' ? Belement.forwardcurrentavg : Belement.reversecurrentavg,
                                    b_voltage: Belement.direction == 'Normal' ? Belement.forwardvoltage : Belement.reversevoltage,
                                    b_time: Belement.direction == 'Normal' ? Belement.forwardtime : Belement.reversetime,
                                    b_vibration_x: Belement.vibrationx,
                                    b_vibration_y: Belement.vibrationy,
                                    b_vibration_z: Belement.vibrationz,
                                    log: Belement.log == 1 ? 1 : 0,
                                    createddate: Belement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                data_insert.push({
                                    pointmachineid: parseInt(data.pointmachineid),
                                    direction: 'Normal',
                                    pointcyclecount: 0,
                                    a_direction: get_1Adata.length > count ? get_1Adata[count - 1].direction : get_1Adata[get_1Adata.length - 1].direction,
                                    a_cyclecount: get_1Adata.length > count ? get_1Adata[count - 1].cyclecount : get_1Adata[get_1Adata.length - 1].cyclecount,
                                    a_indication_voltage: get_1Adata.length > count ? get_1Adata[count - 1].direction == 'Normal' ? get_1Adata[count - 1].forwardindicationvoltage : get_1Adata[count - 1].reverseindicationvoltage : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardindicationvoltage : get_1Adata[get_1Adata.length - 1].reverseindicationvoltage,
                                    a_current_max: get_1Adata.length > count ? get_1Adata[count - 1].direction == 'Normal' ? get_1Adata[count - 1].forwardcurrentpeak : get_1Adata[count - 1].reversecurrentpeak : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardcurrentpeak : get_1Adata[get_1Adata.length - 1].reversecurrentpeak,
                                    a_current_avg: get_1Adata.length > count ? get_1Adata[count - 1].direction == 'Normal' ? get_1Adata[count - 1].forwardcurrentavg : get_1Adata[count - 1].reversecurrentavg : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardcurrentavg : get_1Adata[get_1Adata.length - 1].reversecurrentavg,
                                    a_voltage: get_1Adata.length > count ? get_1Adata[count - 1].direction == 'Normal' ? get_1Adata[count - 1].forwardvoltage : get_1Adata[count - 1].reversevoltage : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardvoltage : get_1Adata[get_1Adata.length - 1].reversevoltage,
                                    a_time: get_1Adata.length > count ? get_1Adata[count - 1].direction == 'Normal' ? get_1Adata[count - 1].forwardtime : get_1Adata[count - 1].reversetime : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardtime : get_1Adata[get_1Adata.length - 1].reversetime,
                                    a_vibration_x: get_1Adata.length > count ? get_1Adata[count - 1].vibrationx : get_1Adata[get_1Adata.length - 1].vibrationx,
                                    a_vibration_y: get_1Adata.length > count ? get_1Adata[count - 1].vibrationy : get_1Adata[get_1Adata.length - 1].vibrationy,
                                    a_vibration_z: get_1Adata.length > count ? get_1Adata[count - 1].vibrationz : get_1Adata[get_1Adata.length - 1].vibrationz,
                                    b_direction: Belement.direction,
                                    b_cyclecount: Belement.cyclecount,
                                    b_indication_voltage: Belement.direction == 'Normal' ? Belement.forwardindicationvoltage : Belement.reverseindicationvoltage,
                                    b_current_max: Belement.direction == 'Normal' ? Belement.forwardcurrentpeak : Belement.reversecurrentpeak,
                                    b_current_avg: Belement.direction == 'Normal' ? Belement.forwardcurrentavg : Belement.reversecurrentavg,
                                    b_voltage: Belement.direction == 'Normal' ? Belement.forwardvoltage : Belement.reversevoltage,
                                    b_time: Belement.direction == 'Normal' ? Belement.forwardtime : Belement.reversetime,
                                    b_vibration_x: Belement.vibrationx,
                                    b_vibration_y: Belement.vibrationy,
                                    b_vibration_z: Belement.vibrationz,
                                    log: Belement.log == 1 ? 1 : get_1Adata.length > count ? get_1Adata[count - 1].log : get_1Adata[get_1Adata.length - 1].log,
                                    createddate: Belement.createddate,
                                    isdele: false
                                })
                            }

                        }
                        count++;
                    }
                }
            }

            if (data_insert.length == 1) {
                logs.info('1A_data_insert_acyclecount', data_insert.map(a => a.a_cyclecount))
                logs.info('1A_data_insert_bcyclecount', data_insert.map(a => a.b_cyclecount))

                let transaction = await db.transaction({ autocommit: false });
                try {
                    let insert_dataid = ""
                    const create_data = await PointMachineData
                        .create(data_insert[0], { transaction: transaction }).then(res => insert_dataid = res.id)
                    logs.info('pointmachine1A_data_insert', insert_dataid)
                    await insert_pointmachine(data, data_insert[0], insert_dataid);
                    await transaction.commit();
                }
                catch (ex) {
                    await transaction.rollback();
                    logs.error('station point machine 1A data error' + ex);
                    //console.log('station point machine 1A data error' + ex);
                }
            }
            else if (data_insert.length > 1) {
                logs.info('1A_data_insert_acyclecount', data_insert.map(a => a.a_cyclecount))
                logs.info('1A_data_insert_bcyclecount', data_insert.map(a => a.b_cyclecount))

                let transaction = await db.transaction({ autocommit: false });
                try {
                    let insert_dataid = []
                    const create_data = await PointMachineData
                        .bulkCreate(data_insert, { transaction: transaction }).then(res => insert_dataid = res)
                    for await (const insert_element of insert_dataid) {
                        logs.info('point machine1A_data_insert', insert_element.dataValues.id)
                        await insert_pointmachine(data, insert_element.dataValues, insert_element.dataValues.id);
                    }
                    logs.info("point machine1A_data_inserted", insert_dataid.length)
                    await transaction.commit();

                }
                catch (ex) {
                    await transaction.rollback();
                    logs.error('station point machine 1A data error' + ex);
                    //console.log('station point machine 1A data error' + ex);
                }
            }
        }
        catch (ex) {
            logs.error('station point machine 1A data error' + ex);
            //console.log('station point machine 1A data error' + ex);
        }
    }

    // InActive - old - Point Machine 1B
    async function insert_Bpointnotification1(data) {
        logs.info(`insert station pointmachine 1B data started`);
        //console.log(`insert station pointmachine A data started`);
        try {
            alert_value_list = require("./alertvalue").getValues();
            let station_id = data.stationid
            let data_insert = []
            var get_finalpointmachine_datas = [await PointMachineData.findOne({ limit: 1, where: { isdele: false, pointmachineid: parseInt(data.pointmachineid) }, order: [["id", "DESC"]] })];
            get_finalpointmachine_datas = get_finalpointmachine_datas[0] !== null ? get_finalpointmachine_datas : []
            const get_1Adata = await PointmachineAdata.findAll({ where: { isdele: false, pointmachineid: parseInt(data.pointmachineid) } });
            const get_1Bdata = await PointmachineBdata.findAll({ where: { isdele: false, pointmachineid: parseInt(data.pointmachineid) } });

            if (get_finalpointmachine_datas.length > 0) {
                let finalacycle = get_finalpointmachine_datas[0].a_cyclecount === 0 ? 1 : get_finalpointmachine_datas[0].a_cyclecount;
                let finalbcycle = get_finalpointmachine_datas[0].b_cyclecount === 0 ? 1 : get_finalpointmachine_datas[0].b_cyclecount;

                var a_pointmachinedata = [];
                var b_pointmachinedata = [];
                var Apointcyle = [];
                var Bpointcyle = [];

                if (get_1Adata.length > 0) {
                    a_pointmachinedata = lodash.filter(get_1Adata, ({ cyclecount }) => cyclecount > finalacycle)
                    Apointcyle = a_pointmachinedata.map(a => a.cyclecount)
                }

                if (get_1Bdata.length > 0) {
                    b_pointmachinedata = lodash.filter(get_1Bdata, ({ cyclecount }) => cyclecount > finalbcycle)
                    Bpointcyle = b_pointmachinedata.map(a => a.cyclecount)

                    if (get_1Bdata.length === 1 && Bpointcyle.length === 0 && Apointcyle.length === 0) {
                        data_insert.push({
                            pointmachineid: parseInt(data.pointmachineid),
                            direction: 'Normal',
                            pointcyclecount: 0,
                            a_direction: get_1Adata[get_1Adata.length - 1].direction,
                            a_cyclecount: get_1Adata[get_1Adata.length - 1].cyclecount,
                            a_indication_voltage: get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardindicationvoltage : get_1Adata[get_1Adata.length - 1].reverseindicationvoltage,
                            a_current_max: get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardcurrentpeak : get_1Adata[get_1Adata.length - 1].reversecurrentpeak,
                            a_current_avg: get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardcurrentavg : get_1Adata[get_1Adata.length - 1].reversecurrentavg,
                            a_voltage: get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardvoltage : get_1Adata[get_1Adata.length - 1].reversevoltage,
                            a_time: get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardtime : get_1Adata[get_1Adata.length - 1].reversetime,
                            a_vibration_x: get_1Adata[get_1Adata.length - 1].vibrationx,
                            a_vibration_y: get_1Adata[get_1Adata.length - 1].vibrationy,
                            a_vibration_z: get_1Adata[get_1Adata.length - 1].vibrationz,
                            b_direction: get_1Bdata[get_1Bdata.length - 1].direction,
                            b_cyclecount: get_1Bdata[get_1Bdata.length - 1].cyclecount,
                            b_indication_voltage: get_1Bdata[get_1Bdata.length - 1].reverseindicationvoltage,
                            b_current_max: get_1Bdata[get_1Bdata.length - 1].reversecurrentpeak,
                            b_current_avg: get_1Bdata[get_1Bdata.length - 1].reversecurrentavg,
                            b_voltage: get_1Bdata[get_1Bdata.length - 1].reversevoltage,
                            b_time: get_1Bdata[get_1Bdata.length - 1].reversetime,
                            b_vibration_x: get_1Bdata[get_1Bdata.length - 1].vibrationx,
                            b_vibration_y: get_1Bdata[get_1Bdata.length - 1].vibrationy,
                            b_vibration_z: get_1Bdata[get_1Bdata.length - 1].vibrationz,
                            log: get_1Adata[get_1Adata.length - 1].log == 1 ? 1 : get_1Bdata[get_1Bdata.length - 1].log,
                            createddate: get_1Adata[get_1Adata.length - 1].createddate,
                            isdele: false
                        })
                    }
                }

                if (Apointcyle.length >= Bpointcyle.length) {
                    let count = finalbcycle
                    for await (const Aelement of a_pointmachinedata) {
                        data_insert.push({
                            pointmachineid: parseInt(data.pointmachineid),
                            direction: 'Normal',
                            pointcyclecount: 0,
                            a_direction: Aelement.direction,
                            a_cyclecount: Aelement.cyclecount,
                            a_indication_voltage: Aelement.direction == 'Normal' ? Aelement.forwardindicationvoltage : Aelement.reverseindicationvoltage,
                            a_current_max: Aelement.direction == 'Normal' ? Aelement.forwardcurrentpeak : Aelement.reversecurrentpeak,
                            a_current_avg: Aelement.direction == 'Normal' ? Aelement.forwardcurrentavg : Aelement.reversecurrentavg,
                            a_voltage: Aelement.direction == 'Normal' ? Aelement.forwardvoltage : Aelement.reversevoltage,
                            a_time: Aelement.direction == 'Normal' ? Aelement.forwardtime : Aelement.reversetime,
                            a_vibration_x: Aelement.vibrationx,
                            a_vibration_y: Aelement.vibrationy,
                            a_vibration_z: Aelement.vibrationz,
                            b_direction: get_1Bdata.length > count ? get_1Bdata[count].direction : get_1Bdata.length === 0 ? '' : get_1Bdata[get_1Bdata.length - 1].direction,
                            b_cyclecount: get_1Bdata.length > count ? get_1Bdata[count].cyclecount : get_1Bdata.length === 0 ? 0 : get_1Bdata[get_1Bdata.length - 1].cyclecount,
                            b_indication_voltage: get_1Bdata.length > count ? get_1Bdata[count].direction == 'Normal' ? get_1Bdata.length === 0 ? 0 : get_1Bdata[count - 1].forwardindicationvoltage : get_1Bdata[count - 1].reverseindicationvoltage : get_1Bdata.length === 0 ? 0 : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardindicationvoltage : get_1Bdata[get_1Bdata.length - 1].reverseindicationvoltage,
                            b_current_max: get_1Bdata.length > count ? get_1Bdata[count].direction == 'Normal' ? get_1Bdata.length === 0 ? 0 : get_1Bdata[count - 1].forwardcurrentpeak : get_1Bdata[count - 1].reversecurrentpeak : get_1Bdata.length === 0 ? 0 : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardcurrentpeak : get_1Bdata[get_1Bdata.length - 1].reversecurrentpeak,
                            b_current_avg: get_1Bdata.length > count ? get_1Bdata[count].direction == 'Normal' ? get_1Bdata.length === 0 ? 0 : get_1Bdata[count - 1].forwardcurrentavg : get_1Bdata[count - 1].reversecurrentavg : get_1Bdata.length === 0 ? 0 : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardcurrentavg : get_1Bdata[get_1Bdata.length - 1].reversecurrentavg,
                            b_voltage: get_1Bdata.length > count ? get_1Bdata[count].direction == 'Normal' ? get_1Bdata.length === 0 ? 0 : get_1Bdata[count - 1].forwardvoltage : get_1Bdata[count - 1].reversevoltage : get_1Bdata.length === 0 ? 0 : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardvoltage : get_1Bdata[get_1Bdata.length - 1].reversevoltage,
                            b_time: get_1Bdata.length > count ? get_1Bdata[count].direction == 'Normal' ? get_1Bdata.length === 0 ? 0 : get_1Bdata[count - 1].forwardtime : get_1Bdata[count - 1].reversetime : get_1Bdata.length === 0 ? 0 : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardtime : get_1Bdata[get_1Bdata.length - 1].reversetime,
                            b_vibration_x: get_1Bdata.length > count ? get_1Bdata[count].vibrationx : get_1Bdata.length === 0 ? 0 : get_1Bdata[get_1Bdata.length - 1].vibrationx,
                            b_vibration_y: get_1Bdata.length > count ? get_1Bdata[count].vibrationy : get_1Bdata.length === 0 ? 0 : get_1Bdata[get_1Bdata.length - 1].vibrationy,
                            b_vibration_z: get_1Bdata.length > count ? get_1Bdata[count].vibrationz : get_1Bdata.length === 0 ? 0 : get_1Bdata[get_1Bdata.length - 1].vibrationz,
                            log: Aelement.log == 1 ? 1 : get_1Bdata.length > count ? get_1Bdata[count].log : get_1Bdata.length === 0 ? 0 : get_1Bdata[get_1Bdata.length - 1].log,
                            createddate: Aelement.createddate,
                            isdele: false
                        })
                        count++
                    }
                }
                else {
                    let count = finalacycle
                    for await (const Belement of b_pointmachinedata) {
                        data_insert.push({
                            pointmachineid: parseInt(data.pointmachineid),
                            direction: 'Normal',
                            pointcyclecount: 0,
                            a_direction: get_1Adata.length > count ? get_1Adata[count].direction : get_1Adata.length === 0 ? '' : get_1Adata[get_1Adata.length - 1].direction,
                            a_cyclecount: get_1Adata.length > count ? get_1Adata[count].cyclecount : get_1Adata.length === 0 ? 0 : get_1Adata[get_1Adata.length - 1].cyclecount,
                            a_indication_voltage: get_1Adata.length > count ? get_1Adata[count].direction == 'Normal' ? get_1Adata.length === 0 ? 0 : get_1Adata[count - 1].forwardindicationvoltage : get_1Adata[count - 1].reverseindicationvoltage : get_1Adata.length === 0 ? 0 : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardindicationvoltage : get_1Adata[get_1Adata.length - 1].reverseindicationvoltage,
                            a_current_max: get_1Adata.length > count ? get_1Adata[count].direction == 'Normal' ? get_1Adata.length === 0 ? 0 : get_1Adata[count - 1].forwardcurrentpeak : get_1Adata[count - 1].reversecurrentpeak : get_1Adata.length === 0 ? 0 : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardcurrentpeak : get_1Adata[get_1Adata.length - 1].reversecurrentpeak,
                            a_current_avg: get_1Adata.length > count ? get_1Adata[count].direction == 'Normal' ? get_1Adata.length === 0 ? 0 : get_1Adata[count - 1].forwardcurrentavg : get_1Adata[count - 1].reversecurrentavg : get_1Adata.length === 0 ? 0 : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardcurrentavg : get_1Adata[get_1Adata.length - 1].reversecurrentavg,
                            a_voltage: get_1Adata.length > count ? get_1Adata[count].direction == 'Normal' ? get_1Adata.length === 0 ? 0 : get_1Adata[count - 1].forwardvoltage : get_1Adata[count - 1].reversevoltage : get_1Adata.length === 0 ? 0 : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardvoltage : get_1Adata[get_1Adata.length - 1].reversevoltage,
                            a_time: get_1Adata.length > count ? get_1Adata[count].direction == 'Normal' ? get_1Adata.length === 0 ? 0 : get_1Adata[count - 1].forwardtime : get_1Adata[count - 1].reversetime : get_1Adata.length === 0 ? 0 : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardtime : get_1Adata[get_1Adata.length - 1].reversetime,
                            a_vibration_x: get_1Adata.length > count ? get_1Adata[count].vibrationx : get_1Adata.length === 0 ? 0 : get_1Adata[get_1Adata.length - 1].vibrationx,
                            a_vibration_y: get_1Adata.length > count ? get_1Adata[count].vibrationy : get_1Adata.length === 0 ? 0 : get_1Adata[get_1Adata.length - 1].vibrationy,
                            a_vibration_z: get_1Adata.length > count ? get_1Adata[count].vibrationz : get_1Adata.length === 0 ? 0 : get_1Adata[get_1Adata.length - 1].vibrationz,
                            b_direction: Belement.direction,
                            b_cyclecount: Belement.cyclecount,
                            b_indication_voltage: Belement.direction == 'Normal' ? Belement.forwardindicationvoltage : Belement.reverseindicationvoltage,
                            b_current_max: Belement.direction == 'Normal' ? Belement.forwardcurrentpeak : Belement.reversecurrentpeak,
                            b_current_avg: Belement.direction == 'Normal' ? Belement.forwardcurrentavg : Belement.reversecurrentavg,
                            b_voltage: Belement.direction == 'Normal' ? Belement.forwardvoltage : Belement.reversevoltage,
                            b_time: Belement.direction == 'Normal' ? Belement.forwardtime : Belement.reversetime,
                            b_vibration_x: Belement.vibrationx,
                            b_vibration_y: Belement.vibrationy,
                            b_vibration_z: Belement.vibrationz,
                            log: Belement.log == 1 ? 1 : get_1Adata.length > count ? get_1Adata[count].log : get_1Adata.length === 0 ? 0 : get_1Adata[get_1Adata.length - 1].log,
                            createddate: Belement.createddate,
                            isdele: false
                        })
                        count++
                    }
                }
            }
            else {
                if (get_1Adata.length >= get_1Bdata.length) {
                    let count = 1
                    for await (const Aelement of get_1Adata) {
                        if (count == 1) {
                            if (get_1Bdata.length == 0) {
                                data_insert.push({
                                    pointmachineid: parseInt(data.pointmachineid),
                                    direction: 'Normal',
                                    pointcyclecount: 0,
                                    a_direction: Aelement.direction,
                                    a_cyclecount: Aelement.cyclecount,
                                    a_indication_voltage: Aelement.direction == 'Normal' ? Aelement.forwardindicationvoltage : Aelement.reverseindicationvoltage,
                                    a_current_max: Aelement.direction == 'Normal' ? Aelement.forwardcurrentpeak : Aelement.reversecurrentpeak,
                                    a_current_avg: Aelement.direction == 'Normal' ? Aelement.forwardcurrentavg : Aelement.reversecurrentavg,
                                    a_voltage: Aelement.direction == 'Normal' ? Aelement.forwardvoltage : Aelement.reversevoltage,
                                    a_time: Aelement.direction == 'Normal' ? Aelement.forwardtime : Aelement.reversetime,
                                    a_vibration_x: Aelement.vibrationx,
                                    a_vibration_y: Aelement.vibrationy,
                                    a_vibration_z: Aelement.vibrationz,
                                    b_direction: '',
                                    b_cyclecount: 0,
                                    b_indication_voltage: 0,
                                    b_current_max: 0,
                                    b_current_avg: 0,
                                    b_voltage: 0,
                                    b_time: 0,
                                    b_vibration_x: 0,
                                    b_vibration_y: 0,
                                    b_vibration_z: 0,
                                    log: Aelement.log == 1 ? 1 : 0,
                                    createddate: Aelement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                data_insert.push({
                                    pointmachineid: parseInt(data.pointmachineid),
                                    direction: 'Normal',
                                    pointcyclecount: 0,
                                    a_direction: Aelement.direction,
                                    a_cyclecount: Aelement.cyclecount,
                                    a_indication_voltage: Aelement.direction == 'Normal' ? Aelement.forwardindicationvoltage : Aelement.reverseindicationvoltage,
                                    a_current_max: Aelement.direction == 'Normal' ? Aelement.forwardcurrentpeak : Aelement.reversecurrentpeak,
                                    a_current_avg: Aelement.direction == 'Normal' ? Aelement.forwardcurrentavg : Aelement.reversecurrentavg,
                                    a_voltage: Aelement.direction == 'Normal' ? Aelement.forwardvoltage : Aelement.reversevoltage,
                                    a_time: Aelement.direction == 'Normal' ? Aelement.forwardtime : Aelement.reversetime,
                                    a_vibration_x: Aelement.vibrationx,
                                    a_vibration_y: Aelement.vibrationy,
                                    a_vibration_z: Aelement.vibrationz,
                                    b_direction: get_1Bdata.length > count ? get_1Bdata[count - 1].direction : get_1Bdata[get_1Bdata.length - 1].direction,
                                    b_cyclecount: get_1Bdata.length > count ? get_1Bdata[count - 1].cyclecount : get_1Bdata[get_1Bdata.length - 1].cyclecount,
                                    b_indication_voltage: get_1Bdata.length > count ? get_1Bdata[count - 1].direction == 'Normal' ? get_1Bdata[count - 1].forwardindicationvoltage : get_1Bdata[count - 1].reverseindicationvoltage : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardindicationvoltage : get_1Bdata[get_1Bdata.length - 1].reverseindicationvoltage,
                                    b_current_max: get_1Bdata.length > count ? get_1Bdata[count - 1].direction == 'Normal' ? get_1Bdata[count - 1].forwardcurrentpeak : get_1Bdata[count - 1].reversecurrentpeak : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardcurrentpeak : get_1Bdata[get_1Bdata.length - 1].reversecurrentpeak,
                                    b_current_avg: get_1Bdata.length > count ? get_1Bdata[count - 1].direction == 'Normal' ? get_1Bdata[count - 1].forwardcurrentavg : get_1Bdata[count - 1].reversecurrentavg : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardcurrentavg : get_1Bdata[get_1Bdata.length - 1].reversecurrentavg,
                                    b_voltage: get_1Bdata.length > count ? get_1Bdata[count - 1].direction == 'Normal' ? get_1Bdata[count - 1].forwardvoltage : get_1Bdata[count - 1].reversevoltage : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardvoltage : get_1Bdata[get_1Bdata.length - 1].reversevoltage,
                                    b_time: get_1Bdata.length > count ? get_1Bdata[count - 1].direction == 'Normal' ? get_1Bdata[count - 1].forwardtime : get_1Bdata[count - 1].reversetime : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardtime : get_1Bdata[get_1Bdata.length - 1].reversetime,
                                    b_vibration_x: get_1Bdata.length > count ? get_1Bdata[count - 1].vibrationx : get_1Bdata[get_1Bdata.length - 1].vibrationx,
                                    b_vibration_y: get_1Bdata.length > count ? get_1Bdata[count - 1].vibrationy : get_1Bdata[get_1Bdata.length - 1].vibrationy,
                                    b_vibration_z: get_1Bdata.length > count ? get_1Bdata[count - 1].vibrationz : get_1Bdata[get_1Bdata.length - 1].vibrationz,
                                    log: Aelement.log == 1 ? 1 : get_1Bdata.length > count ? get_1Bdata[count - 1].log : get_1Bdata[get_1Bdata.length - 1].log,
                                    createddate: Aelement.createddate,
                                    isdele: false
                                })
                            }
                        }
                        else {
                            if (get_1Bdata.length == 0) {
                                data_insert.push({
                                    pointmachineid: parseInt(data.pointmachineid),
                                    direction: 'Normal',
                                    pointcyclecount: 0,
                                    a_direction: Aelement.direction,
                                    a_cyclecount: Aelement.cyclecount,
                                    a_indication_voltage: Aelement.direction == 'Normal' ? Aelement.forwardindicationvoltage : Aelement.reverseindicationvoltage,
                                    a_current_max: Aelement.direction == 'Normal' ? Aelement.forwardcurrentpeak : Aelement.reversecurrentpeak,
                                    a_current_avg: Aelement.direction == 'Normal' ? Aelement.forwardcurrentavg : Aelement.reversecurrentavg,
                                    a_voltage: Aelement.direction == 'Normal' ? Aelement.forwardvoltage : Aelement.reversevoltage,
                                    a_time: Aelement.direction == 'Normal' ? Aelement.forwardtime : Aelement.reversetime,
                                    a_vibration_x: Aelement.vibrationx,
                                    a_vibration_y: Aelement.vibrationy,
                                    a_vibration_z: Aelement.vibrationz,
                                    b_direction: '',
                                    b_cyclecount: 0,
                                    b_indication_voltage: 0,
                                    b_current_max: 0,
                                    b_current_avg: 0,
                                    b_voltage: 0,
                                    b_time: 0,
                                    b_vibration_x: 0,
                                    b_vibration_y: 0,
                                    b_vibration_z: 0,
                                    log: Aelement.log == 1 ? 1 : 0,
                                    createddate: Aelement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                data_insert.push({
                                    pointmachineid: parseInt(data.pointmachineid),
                                    direction: 'Normal',
                                    pointcyclecount: 0,
                                    a_direction: Aelement.direction,
                                    a_cyclecount: Aelement.cyclecount,
                                    a_indication_voltage: Aelement.direction == 'Normal' ? Aelement.forwardindicationvoltage : Aelement.reverseindicationvoltage,
                                    a_current_max: Aelement.direction == 'Normal' ? Aelement.forwardcurrentpeak : Aelement.reversecurrentpeak,
                                    a_current_avg: Aelement.direction == 'Normal' ? Aelement.forwardcurrentavg : Aelement.reversecurrentavg,
                                    a_voltage: Aelement.direction == 'Normal' ? Aelement.forwardvoltage : Aelement.reversevoltage,
                                    a_time: Aelement.direction == 'Normal' ? Aelement.forwardtime : Aelement.reversetime,
                                    a_vibration_x: Aelement.vibrationx,
                                    a_vibration_y: Aelement.vibrationy,
                                    a_vibration_z: Aelement.vibrationz,
                                    b_direction: get_1Bdata.length > count ? get_1Bdata[count - 1].direction : get_1Bdata[get_1Bdata.length - 1].direction,
                                    b_cyclecount: get_1Bdata.length > count ? get_1Bdata[count - 1].cyclecount : get_1Bdata[get_1Bdata.length - 1].cyclecount,
                                    b_indication_voltage: get_1Bdata.length > count ? get_1Bdata[count - 1].direction == 'Normal' ? get_1Bdata[count - 1].forwardindicationvoltage : get_1Bdata[count - 1].reverseindicationvoltage : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardindicationvoltage : get_1Bdata[get_1Bdata.length - 1].reverseindicationvoltage,
                                    b_current_max: get_1Bdata.length > count ? get_1Bdata[count - 1].direction == 'Normal' ? get_1Bdata[count - 1].forwardcurrentpeak : get_1Bdata[count - 1].reversecurrentpeak : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardcurrentpeak : get_1Bdata[get_1Bdata.length - 1].reversecurrentpeak,
                                    b_current_avg: get_1Bdata.length > count ? get_1Bdata[count - 1].direction == 'Normal' ? get_1Bdata[count - 1].forwardcurrentavg : get_1Bdata[count - 1].reversecurrentavg : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardcurrentavg : get_1Bdata[get_1Bdata.length - 1].reversecurrentavg,
                                    b_voltage: get_1Bdata.length > count ? get_1Bdata[count - 1].direction == 'Normal' ? get_1Bdata[count - 1].forwardvoltage : get_1Bdata[count - 1].reversevoltage : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardvoltage : get_1Bdata[get_1Bdata.length - 1].reversevoltage,
                                    b_time: get_1Bdata.length > count ? get_1Bdata[count - 1].direction == 'Normal' ? get_1Bdata[count - 1].forwardtime : get_1Bdata[count - 1].reversetime : get_1Bdata[get_1Bdata.length - 1].direction == 'Normal' ? get_1Bdata[get_1Bdata.length - 1].forwardtime : get_1Bdata[get_1Bdata.length - 1].reversetime,
                                    b_vibration_x: get_1Bdata.length > count ? get_1Bdata[count - 1].vibrationx : get_1Bdata[get_1Bdata.length - 1].vibrationx,
                                    b_vibration_y: get_1Bdata.length > count ? get_1Bdata[count - 1].vibrationy : get_1Bdata[get_1Bdata.length - 1].vibrationy,
                                    b_vibration_z: get_1Bdata.length > count ? get_1Bdata[count - 1].vibrationz : get_1Bdata[get_1Bdata.length - 1].vibrationz,
                                    log: Aelement.log == 1 ? 1 : get_1Bdata.length > count ? get_1Bdata[count - 1].log : get_1Bdata[get_1Bdata.length - 1].log,
                                    createddate: Aelement.createddate,
                                    isdele: false
                                })
                            }

                        }
                        count++;
                    }
                }
                else {
                    let count = 1
                    for await (const Belement of get_1Bdata) {
                        if (count == 1) {
                            if (get_1Adata.length == 0) {
                                data_insert.push({
                                    pointmachineid: parseInt(data.pointmachineid),
                                    direction: 'Normal',
                                    pointcyclecount: 0,
                                    a_direction: '',
                                    a_cyclecount: 0,
                                    a_indication_voltage: 0,
                                    a_current_max: 0,
                                    a_current_avg: 0,
                                    a_voltage: 0,
                                    a_time: 0,
                                    a_vibration_x: 0,
                                    a_vibration_y: 0,
                                    a_vibration_z: 0,
                                    b_direction: Belement.direction,
                                    b_cyclecount: Belement.cyclecount,
                                    b_indication_voltage: Belement.direction == 'Normal' ? Belement.forwardindicationvoltage : Belement.reverseindicationvoltage,
                                    b_current_max: Belement.direction == 'Normal' ? Belement.forwardcurrentpeak : Belement.reversecurrentpeak,
                                    b_current_avg: Belement.direction == 'Normal' ? Belement.forwardcurrentavg : Belement.reversecurrentavg,
                                    b_voltage: Belement.direction == 'Normal' ? Belement.forwardvoltage : Belement.reversevoltage,
                                    b_time: Belement.direction == 'Normal' ? Belement.forwardtime : Belement.reversetime,
                                    b_vibration_x: Belement.vibrationx,
                                    b_vibration_y: Belement.vibrationy,
                                    b_vibration_z: Belement.vibrationz,
                                    log: Belement.log == 1 ? 1 : 0,
                                    createddate: Belement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                data_insert.push({
                                    pointmachineid: parseInt(data.pointmachineid),
                                    direction: 'Normal',
                                    pointcyclecount: 0,
                                    a_direction: get_1Adata.length > count ? get_1Adata[count - 1].direction : get_1Adata[get_1Adata.length - 1].direction,
                                    a_cyclecount: get_1Adata.length > count ? get_1Adata[count - 1].cyclecount : get_1Adata[get_1Adata.length - 1].cyclecount,
                                    a_indication_voltage: get_1Adata.length > count ? get_1Adata[count - 1].direction == 'Normal' ? get_1Adata[count - 1].forwardindicationvoltage : get_1Adata[count - 1].reverseindicationvoltage : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardindicationvoltage : get_1Adata[get_1Adata.length - 1].reverseindicationvoltage,
                                    a_current_max: get_1Adata.length > count ? get_1Adata[count - 1].direction == 'Normal' ? get_1Adata[count - 1].forwardcurrentpeak : get_1Adata[count - 1].reversecurrentpeak : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardcurrentpeak : get_1Adata[get_1Adata.length - 1].reversecurrentpeak,
                                    a_current_avg: get_1Adata.length > count ? get_1Adata[count - 1].direction == 'Normal' ? get_1Adata[count - 1].forwardcurrentavg : get_1Adata[count - 1].reversecurrentavg : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardcurrentavg : get_1Adata[get_1Adata.length - 1].reversecurrentavg,
                                    a_voltage: get_1Adata.length > count ? get_1Adata[count - 1].direction == 'Normal' ? get_1Adata[count - 1].forwardvoltage : get_1Adata[count - 1].reversevoltage : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardvoltage : get_1Adata[get_1Adata.length - 1].reversevoltage,
                                    a_time: get_1Adata.length > count ? get_1Adata[count - 1].direction == 'Normal' ? get_1Adata[count - 1].forwardtime : get_1Adata[count - 1].reversetime : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardtime : get_1Adata[get_1Adata.length - 1].reversetime,
                                    a_vibration_x: get_1Adata.length > count ? get_1Adata[count - 1].vibrationx : get_1Adata[get_1Adata.length - 1].vibrationx,
                                    a_vibration_y: get_1Adata.length > count ? get_1Adata[count - 1].vibrationy : get_1Adata[get_1Adata.length - 1].vibrationy,
                                    a_vibration_z: get_1Adata.length > count ? get_1Adata[count - 1].vibrationz : get_1Adata[get_1Adata.length - 1].vibrationz,
                                    b_direction: Belement.direction,
                                    b_cyclecount: Belement.cyclecount,
                                    b_indication_voltage: Belement.direction == 'Normal' ? Belement.forwardindicationvoltage : Belement.reverseindicationvoltage,
                                    b_current_max: Belement.direction == 'Normal' ? Belement.forwardcurrentpeak : Belement.reversecurrentpeak,
                                    b_current_avg: Belement.direction == 'Normal' ? Belement.forwardcurrentavg : Belement.reversecurrentavg,
                                    b_voltage: Belement.direction == 'Normal' ? Belement.forwardvoltage : Belement.reversevoltage,
                                    b_time: Belement.direction == 'Normal' ? Belement.forwardtime : Belement.reversetime,
                                    b_vibration_x: Belement.vibrationx,
                                    b_vibration_y: Belement.vibrationy,
                                    b_vibration_z: Belement.vibrationz,
                                    log: Belement.log == 1 ? 1 : get_1Adata.length > count ? get_1Adata[count - 1].log : get_1Adata[get_1Adata.length - 1].log,
                                    createddate: Belement.createddate,
                                    isdele: false
                                })
                            }

                        }
                        else {
                            if (get_1Adata.length == 0) {
                                data_insert.push({
                                    pointmachineid: parseInt(data.pointmachineid),
                                    direction: 'Normal',
                                    pointcyclecount: 0,
                                    a_direction: '',
                                    a_cyclecount: 0,
                                    a_indication_voltage: 0,
                                    a_current_max: 0,
                                    a_current_avg: 0,
                                    a_voltage: 0,
                                    a_time: 0,
                                    a_vibration_x: 0,
                                    a_vibration_y: 0,
                                    a_vibration_z: 0,
                                    b_direction: Belement.direction,
                                    b_cyclecount: Belement.cyclecount,
                                    b_indication_voltage: Belement.direction == 'Normal' ? Belement.forwardindicationvoltage : Belement.reverseindicationvoltage,
                                    b_current_max: Belement.direction == 'Normal' ? Belement.forwardcurrentpeak : Belement.reversecurrentpeak,
                                    b_current_avg: Belement.direction == 'Normal' ? Belement.forwardcurrentavg : Belement.reversecurrentavg,
                                    b_voltage: Belement.direction == 'Normal' ? Belement.forwardvoltage : Belement.reversevoltage,
                                    b_time: Belement.direction == 'Normal' ? Belement.forwardtime : Belement.reversetime,
                                    b_vibration_x: Belement.vibrationx,
                                    b_vibration_y: Belement.vibrationy,
                                    b_vibration_z: Belement.vibrationz,
                                    log: Belement.log == 1 ? 1 : 0,
                                    createddate: Belement.createddate,
                                    isdele: false
                                })
                            }
                            else {
                                data_insert.push({
                                    pointmachineid: parseInt(data.pointmachineid),
                                    direction: 'Normal',
                                    pointcyclecount: 0,
                                    a_direction: get_1Adata.length > count ? get_1Adata[count - 1].direction : get_1Adata[get_1Adata.length - 1].direction,
                                    a_cyclecount: get_1Adata.length > count ? get_1Adata[count - 1].cyclecount : get_1Adata[get_1Adata.length - 1].cyclecount,
                                    a_indication_voltage: get_1Adata.length > count ? get_1Adata[count - 1].direction == 'Normal' ? get_1Adata[count - 1].forwardindicationvoltage : get_1Adata[count - 1].reverseindicationvoltage : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardindicationvoltage : get_1Adata[get_1Adata.length - 1].reverseindicationvoltage,
                                    a_current_max: get_1Adata.length > count ? get_1Adata[count - 1].direction == 'Normal' ? get_1Adata[count - 1].forwardcurrentpeak : get_1Adata[count - 1].reversecurrentpeak : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardcurrentpeak : get_1Adata[get_1Adata.length - 1].reversecurrentpeak,
                                    a_current_avg: get_1Adata.length > count ? get_1Adata[count - 1].direction == 'Normal' ? get_1Adata[count - 1].forwardcurrentavg : get_1Adata[count - 1].reversecurrentavg : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardcurrentavg : get_1Adata[get_1Adata.length - 1].reversecurrentavg,
                                    a_voltage: get_1Adata.length > count ? get_1Adata[count - 1].direction == 'Normal' ? get_1Adata[count - 1].forwardvoltage : get_1Adata[count - 1].reversevoltage : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardvoltage : get_1Adata[get_1Adata.length - 1].reversevoltage,
                                    a_time: get_1Adata.length > count ? get_1Adata[count - 1].direction == 'Normal' ? get_1Adata[count - 1].forwardtime : get_1Adata[count - 1].reversetime : get_1Adata[get_1Adata.length - 1].direction == 'Normal' ? get_1Adata[get_1Adata.length - 1].forwardtime : get_1Adata[get_1Adata.length - 1].reversetime,
                                    a_vibration_x: get_1Adata.length > count ? get_1Adata[count - 1].vibrationx : get_1Adata[get_1Adata.length - 1].vibrationx,
                                    a_vibration_y: get_1Adata.length > count ? get_1Adata[count - 1].vibrationy : get_1Adata[get_1Adata.length - 1].vibrationy,
                                    a_vibration_z: get_1Adata.length > count ? get_1Adata[count - 1].vibrationz : get_1Adata[get_1Adata.length - 1].vibrationz,
                                    b_direction: Belement.direction,
                                    b_cyclecount: Belement.cyclecount,
                                    b_indication_voltage: Belement.direction == 'Normal' ? Belement.forwardindicationvoltage : Belement.reverseindicationvoltage,
                                    b_current_max: Belement.direction == 'Normal' ? Belement.forwardcurrentpeak : Belement.reversecurrentpeak,
                                    b_current_avg: Belement.direction == 'Normal' ? Belement.forwardcurrentavg : Belement.reversecurrentavg,
                                    b_voltage: Belement.direction == 'Normal' ? Belement.forwardvoltage : Belement.reversevoltage,
                                    b_time: Belement.direction == 'Normal' ? Belement.forwardtime : Belement.reversetime,
                                    b_vibration_x: Belement.vibrationx,
                                    b_vibration_y: Belement.vibrationy,
                                    b_vibration_z: Belement.vibrationz,
                                    createddate: Belement.createddate,
                                    log: Belement.log == 1 ? 1 : get_1Adata.length > count ? get_1Adata[count - 1].log : get_1Adata[get_1Adata.length - 1].log,
                                    isdele: false
                                })
                            }

                        }
                        count++;
                    }
                }
            }

            if (data_insert.length == 1) {
                logs.info('1B_data_insert_acyclecount', data_insert.map(a => a.a_cyclecount))
                logs.info('1B_data_insert_bcyclecount', data_insert.map(a => a.b_cyclecount))

                let transaction = await db.transaction({ autocommit: false });
                try {
                    let insert_dataid = ""
                    const create_data = await PointMachineData
                        .create(data_insert[0], { transaction: transaction }).then(res => insert_dataid = res.id)
                    logs.info('point machine1B_data_insert', insert_dataid)
                    await insert_pointmachine(data, data_insert[0], insert_dataid);
                    await transaction.commit();
                }
                catch (ex) {
                    await transaction.rollback();
                    logs.error('station point machine 1B data error' + ex);
                    //console.log(ex);
                }
            }
            else if (data_insert.length > 1) {
                logs.info('1B_data_insert_acyclecount', data_insert.map(a => a.a_cyclecount))
                logs.info('1B_data_insert_bcyclecount', data_insert.map(a => a.b_cyclecount))

                let transaction = await db.transaction({ autocommit: false });
                try {
                    let insert_dataid = []
                    const create_data = await PointMachineData
                        .bulkCreate(data_insert, { transaction: transaction }).then(res => insert_dataid = res)
                    for await (const insert_element of insert_dataid) {
                        logs.info('point machine1B_data_insert', insert_element.dataValues.id)
                        await insert_pointmachine(data, insert_element.dataValues, insert_element.dataValues.id);
                    }
                    await transaction.commit();
                }
                catch (ex) {
                    await transaction.rollback();
                    logs.error('station point machine 1B data error' + ex);
                    //console.log('station point machine 1B data error' + ex);
                }
            }

        }
        catch (ex) {
            logs.error('station pointmachine 1B data error' + ex);
            //console.log('station point machine 1B data error' + ex);
        }
    }

}
catch (ex) {
    logs.error('Mqtt error-' + ex);
    //console.log('Mqtt error-' + ex);
}
